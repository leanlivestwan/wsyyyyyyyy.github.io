<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>延时消息:如何实现高性能的定时/延时消息？</title>
      <link href="/2023/08/27/%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E5%AE%9A%E6%97%B6-%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%EF%BC%9F/"/>
      <url>/2023/08/27/%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E5%AE%9A%E6%97%B6-%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="延时消息的场景和定义"><a href="#延时消息的场景和定义" class="headerlink" title="延时消息的场景和定义"></a>延时消息的场景和定义</h2><p>先来看一个延时消息典型的使用场景。在网上购买商品下单的过程中，有个功能是：下单完成后 30 分钟如果没有完成支付，则这个订单就自动被取消。如下图所示，从技术上来看，为了实现这个功能，最直观的思路是我们可以将订单数据存在 DB 的表中。然后通过定时程序每秒定时去扫描订单数据，判断如果超过 30 分钟则进行后续的处理。</p><p>如下图所示，从技术上来看，为了实现这个功能，最直观的思路是我们可以将订单数据存在 DB 的表中。然后通过定时程序每秒定时去扫描订单数据，判断如果超过 30 分钟则进行后续的处理。</p><img src="/2023/08/27/%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E5%AE%9A%E6%97%B6-%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%EF%BC%9F/image-20230827104652397.png" class="" title="image-20230827104652397"><p>这个方案的问题是，业务方维护成本较高，需要开发维护定时任务并处理扩缩容，以保证数据处理的及时性。当订单数据量很大时，就容易出现性能问题。另外可能无法实现高精度的延时。因此理想状态是延时逻辑下沉到某个底层的引擎去实现，业务不需要感知任何延时逻辑，正常处理数据即可。在技术体系中，这个底层引擎一般由消息队列来担任。因此只要在类似这种需要定时或者延时触发某个行为的场景，都可以用到延时消息。(<strong>像把订单数据存在数据库当中 然后用定时任务fetch 维护成本高并且需要缩容 订单数据量比较大的时候就会出现性能的问题 没有办法实现高精度的延时 将延时的逻辑下沉到底层的引擎当中去实现</strong>)</p><p>因此理想状态是延时逻辑下沉到某个底层的引擎去实现，业务不需要感知任何延时逻辑，正常处理数据即可。在技术体系中，这个底层引擎一般由消息队列来担任。<strong>因此只要在类似这种需要定时或者延时触发某个行为的场景，都可以用到延时消息</strong>。</p><p>从技术上看，消息队列中延时消息的定义是：<strong>客户端发送设置了到期时间的消息到 Broker 后，该消息在时间到期后能被下游消费到</strong>。从功能表现来看，就是 <strong>Broker 接收到客户端发送的延时消息后，将消息设置为不可见，在时间到期后把消息从不可见变为可见</strong>，从而让下游可以消费到数据。接下来我们从技术上来拆解一下延时消息。</p><p>从技术上拆解延时消息先通过下面这张图来了解一下延时消息的生命周期。</p><img src="/2023/08/27/%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E5%AE%9A%E6%97%B6-%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%EF%BC%9F/image-20230827105148227.png" class="" title="image-20230827105148227"><p>从使用上来看，假设生产端发送定时 30 分钟后或者明天早上 8 点可见的消息给 Broker，Broker 在接收到延时消息后，会先持久化存储消息，然后标记这个消息不可见。再通过内部实现的定时机制，延时到期后将不可见消息变为可见消息，从而让客户端可以正常消费到这条数据。</p><p>所以从技术上来看，消息队列实现延时消息主要包含<strong>数据存储</strong>、如何让消息可见、定时机制、<strong>主动推送</strong>四个部分。</p><h2 id="如何让消息可见"><a href="#如何让消息可见" class="headerlink" title="如何让消息可见"></a>如何让消息可见</h2><p>这节课我们重点讲解“如何让消息可见”和“定时机制”</p><p>在技术上看，消息队列让消息从不可见变为可见的核心思路都是：</p><p>先将数据写入到一个<strong>临时存储</strong>，然后<strong>根据一定的机制</strong>在数据到期后让消费端可以消费到这条消息。</p><p>这个临时存储一般有以下 3 种选择：</p><p>单独设计的数据结构   独立的 Topic 本  地的某个存储引擎（如 RocksDB、Mnesia 等）</p><p>​为了在延时到期后消费者可以消费到这些消息，从技术上看主要两个实现思路：定时检测写入消费时判断数据是否可见定时检测写入，如下图所示，是指 Broker 收到数据后先将数据存储到某一个存储中（比如某个内置 Topic），同时有独立的线程去判断数据是否到期。如果数据到期，则将数据拉出来写入到实际的 Topic，从而让消费端可以正常消费数据。</p><p>​为了在延时到期后消费者可以消费到这些消息，从技术上看主要两个实现思路：1.定时检测写入 2.消费时判断数据是否可见</p><p>​<strong>定时检测写入</strong>，如下图所示，是指 Broker 收到数据后先将数据存储到某一个存储中（比如某个内置 Topic），同时有独立的线程去判断数据是否到期。如果数据到期，则将数据拉出来写入到实际的 Topic，从而让消费端可以正常消费数据。</p><img src="/2023/08/27/%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E5%AE%9A%E6%97%B6-%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%EF%BC%9F/image-20230827105858654.png" class="" title="image-20230827105858654"><p>这种方案的好处是，对生产消费的主流程改造较小。只需要在写入的时候做一个区分逻辑，然后独立实现定时检测，将到期数据写入到目标 Topic 即可。缺点是在延时消息量大的时候，到期时间不会那么精准。</p><p>​<strong>消费时判断数据是否可见</strong>，是指每次消费时判断是否有到期的延时消息，是的话就从第三方存储拉取延时消息返回给消费者，从而实现消息从不可见到可见。</p><img src="/2023/08/27/%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E5%AE%9A%E6%97%B6-%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%EF%BC%9F/image-20230827110043246.png" class="" title="image-20230827110043246"><p>​如上图所示，生产端在写入数据的时候也会将数据写入到第三方存储。但是和前一种方案不同的是，每次消费时会主动去判断第三方存储中是否有消息到期，有的话就把到期数据返回给客户端。这种方案的好处是省去了定时线程的检测写入逻辑，流程简单许多。但是因为消费操作的 QPS 一般很高，在设计这个第三方存储的时候，需要尽量提高获取操作的性能，并降低对内存的占用。另外每次都去检测是否有延时消息，可能会出现性能问题。从业界具体实现来看，大多都是选择<strong>定时检测写入</strong>的方式。因为消费是客户端发起的，频率不可控，每次消费都去检查是否有延时消息，可能会对集群的性能造成影响。</p><h2 id="定时机制的实现"><a href="#定时机制的实现" class="headerlink" title="定时机制的实现"></a>定时机制的实现</h2><p>直观上来看，定时机制的核心逻辑是：随着时间的推进，拿出到期的延时消息进行处理。所以从技术上看，定时机制可以拆解为定时器和延时消息定位处理两部分。定时器指按照时间向前推进，比如毫秒、秒级、分钟级向前推进。下面是一个最简单的定时器实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while (true)&#123;</span><br><span class="line">    //todo</span><br><span class="line">    Thread.sleep(10L); //单位ms</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>延时消息定位处理指的是随着定时器推进，在每个时间刻度可以高效定位，获得需要处理的延时消息列表。即需要重点关注添加、获取的时间复杂度。我们用一张图来讲一下这两个概念，下图是一个最大延时 5 秒的延时功能。</p><img src="/2023/08/27/%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E5%AE%9A%E6%97%B6-%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%EF%BC%9F/image-20230827110535827.png" class="" title="image-20230827110535827"><p>从延时消息的生命周期来看，主要分为 3 步：</p><p>初始化数据结构，来存储数据。</p><p>添加延时事件，根据延时的时间，将数据挂到图中对应的刻度下。</p><p>获取延时事件，当时间刻度往前走，延时到期时将图中这个刻度下的数据都取出来处理。</p><p>在这个示例中我们可以用一个二维数组来存储数据，即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int arr=new int [5][10] //表示5个刻度，每个刻度中最多放10条延时消息</span><br></pre></td></tr></table></figure><p>不过这个示例的局限性很大，真实的延时消息一般需要满足下面 6 点要求：需要支持任意的延时精度，比如秒级，甚至毫秒级。需要支持尽可能长的延时消息，比如一个月、一年。可支持的延时消息的数量应该很大，比如十万级或者百万级。添加、获取延时事件的时间复杂度要尽量低。延时消息要保证可靠不丢失。在实现时需要尽量控制对内存的占用。为了满足以上要求，下面我们来看看延时消息的两种主流技术方案。</p><h2 id="延时消息的技术方案"><a href="#延时消息的技术方案" class="headerlink" title="延时消息的技术方案"></a>延时消息的技术方案</h2><p>延时消息的实现主要有基于轮询检测机制的实现和基于时间轮机制的实现两种方案。</p><h3 id="基于轮询检测机制的实现"><a href="#基于轮询检测机制的实现" class="headerlink" title="基于轮询检测机制的实现"></a>基于轮询检测机制的实现</h3><p>该方案的核心思路是：将延时消息写入到独立的存储中，利用类似 while + sleep 的定时器，来推进时间，通过独立线程检测数据是否到期，然后从第三方存储中取出到期的数据进行处理。该方案由<strong>定时线程</strong>和<strong>第三方存储</strong>两部分组成。</p><p>如上图所示，该方案不需要维护时间刻度，只要设计合适的数据结构来存储延时消息列表，以达到精度和性能的要求即可。从操作上看，主要由<strong>插入</strong>和<strong>获取</strong>两个操作组成，此时需要关注的是插入和获取的时间复杂度。我们追求的目标是这两个操作的时间复杂度尽量低，因此关键的工作是选择合适的底层存储结构。下面我们先整理了一下常用的数据结构在插入和获取方面的时间复杂度。</p><img src="/2023/08/27/%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E5%AE%9A%E6%97%B6-%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%EF%BC%9F/image-20230827111018506.png" class="" title="image-20230827111018506"><p>由表格数据可以知道，如果更关注插入的性能，那么就得选择红黑树和链表。如果更关注获取的性能，则可以选择排序链表和堆。</p><p>因为插入和获取的时间复杂度不全是 O(1)，所以当某个 Topic 的数据量很大时，还是会出现性能问题。我们可以通过分治的思想来缓解性能并提高精度。如下图所示，我们可以将原来的每个 Topic 一个存储结构，拆分为多个存储结构。</p><p>比如可以根据时间进行拆分，如 1 小时、6 小时、12 小时、1 天、大于 1 天等 5 个维度。从而降低每个存储结构的长度，在一定程度上解决性能问题。</p><img src="/2023/08/27/%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E5%AE%9A%E6%97%B6-%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%EF%BC%9F/image-20230827111155581.png" class="" title="image-20230827111155581"><p>这种方案的优点是实现相对简单，开发成本较低。缺点是延时的精度太粗，无法做到精准的延时。但是从实际业务上来看，因为大部分业务不需要非常精准的延时消息，也允许在延时消息的场景中有一定的性能下降。所以这种方案基本能够满足大部分延时消息的需求，这也是业界很多主流消息队列都采用的方案。</p><h3 id="基于时间轮机制的实现"><a href="#基于时间轮机制的实现" class="headerlink" title="基于时间轮机制的实现"></a>基于时间轮机制的实现</h3><p>方案的核心思路也是：将延时消息写入到独立的存储中，然后通过构建多级时间轮，在每个时间刻度上挂载需要处理的延时消息的索引列表。再依赖时间轮的推进，获取到需要处理的延时消息列表，进行后续的处理。</p><img src="/2023/08/27/%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E5%AE%9A%E6%97%B6-%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%EF%BC%9F/image-20230827111259709.png" class="" title="image-20230827111259709"><p>本质上看，时间轮和基于轮询检测的思路是一样的。区别在于，基于时间轮机制可以达到以下 4 个效果：</p><p>插入和获取的时间复杂度都是 O(1) 可以支持任意时间精度的延时消息 可以支持任何时长的延时消息 每个时间刻度都可以支持任意多的元素</p><p>时间轮是一个很成熟的算法，分为单级时间轮和多级时间轮，多级时间轮是单级时间轮的扩展。它的核心思想是：先设定好最小的时间精度，然后将时间划分为多个维度，比如年、月、日、时、分、秒。通过多级的时间轮来表示时间。在每个刻度上挂上一个待处理的延时消息链表，链表的元素存储了延时消息的索引信息。添加延时消息时，找到刻度对应的链表，在链表最后加上该元素，所以时间复杂度为 O(1)。获取延时消息时，找到刻度对应的链表，把这个刻度对应的链表都拿出来处理，时间复杂度也是 O(1)。</p><img src="/2023/08/27/%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E5%AE%9A%E6%97%B6-%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%EF%BC%9F/image-20230827111436060.png" class="" title="image-20230827111436060"><p>如上图所示，这是包含 Seconds、Minutes、Hours 三个级别的时间轮，每一个时间轮的最大刻度为 8，上一级时间轮最小刻度等于下一级时间轮刻度的总和。当我们设定好时间精度和时间轮的维度后，如果是添加延时消息，则在多级时间轮上找到对应时间的延时消息列表，把消息插入到列表中。如果是获取到期的延时消息，也是根据时间轮找到当前时间的延时消息列表，然后把整个列表拿出来处理即可。对时间轮算法细节有兴趣的同学，可以研究一下</p><p>在我看来，时间轮算法的核心思路比较好理解，难的是在工程实现方面。它的核心是：对于<strong>内存使用量的控制和状态持久化</strong>两个方面。即在实现多级时间轮的功能的基础上，要尽量减少这个时间轮对内存资源的占用。对于时间轮的工程实现，这里就不展开了，建议你去研究一下 Kafka 的延时机制，Kakfa 的延时机制底层就是时间轮算法，它的实现在性能和空间占用方面的表现都非常好。</p><p>从理论上看，基于时间轮算法来实现延时消息是一个更好的方案。但是在编码实现上的挑战，就比基于轮询检测的方案大很多。需要重点考虑以下 4 点：</p><p>如何通过合适的数据结构，使插入和获取的时间复杂度都为 O(1)？</p><p>如何尽量降低对于内存的消耗？</p><p>如何完成时间轮信息的持久化和多节点间的同步？</p><p>在代码实现层面，如何低成本实现时间轮？</p><h2 id="RocketMQ-延时消息的设计思路"><a href="#RocketMQ-延时消息的设计思路" class="headerlink" title="RocketMQ 延时消息的设计思路"></a>RocketMQ 延时消息的设计思路</h2><p>社区版本的 RocketMQ，不支持任意时间的延迟，它提供了 18 个级别的延时消息，分别是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</span><br></pre></td></tr></table></figure><p>从原理来看，RocketMQ 的延时消息是基于轮询检测机制的思路来实现的</p><img src="/2023/08/27/%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E5%AE%9A%E6%97%B6-%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%EF%BC%9F/image-20230827111712983.png" class="" title="image-20230827111712983"><p>如上图所示，RocketMQ 在内核定义了名为 SCHEDULE_TOPIC_XXXX 的 Topic 来存储延迟消息。该 Topic 包含 18 个队列，每个队列对应一个延迟级别。比如队列 0 就代表延迟 1s 的队列，队列 1 就代表延迟 5s 的队列。生产者把延迟消息发送到 Broker 之后，Broker 会根据生产者定义的延迟级别放到对应的队列中。而消息原本应该去的 Topic 和队列，会暂时存放在消息的属性（property）中。在 RocketMQ 中，会有专门的线程池去处理延迟消息。比如 18 个延迟级别，就会生成 18 个定时任务，每个任务对应一个队列。这个任务每隔 100 毫秒就会去查看对应队列中的消息，判断消息的执行时间。如果到了执行时间，那么就会把消息发送到其本该投递的 Topic 中，这样消费者就能消费到消息了。</p><h2 id="RabbitMQ-延时消息的设计思路"><a href="#RabbitMQ-延时消息的设计思路" class="headerlink" title="RabbitMQ 延时消息的设计思路"></a>RabbitMQ 延时消息的设计思路</h2><p>RabbitMQ 的延迟消息有基于死信队列和集成延迟插件两种实现方案。基于死信队列是指使用两个队列，一个队列接收消息不消费，然后等待指定时间过后消息过期，再由该队列绑定的死信 Exchange 机制再次将其路由到另一个队列提供业务消费。实际流程如下所示：</p><img src="/2023/08/27/%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E5%AE%9A%E6%97%B6-%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%EF%BC%9F/image-20230827115506033.png" class="" title="image-20230827115506033"><p>集成延迟插件（rabbitmq-delayed-message-exchange）是指延时消息不直接投递到队列中，而是先转储到本地 Mnesia 数据库中，然后定时器在消息到期后再将其投递到队列中。实际流程如下所示：</p><img src="/2023/08/27/%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E5%AE%9A%E6%97%B6-%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%EF%BC%9F/image-20230827115523272.png" class="" title="image-20230827115523272"><p>从根本上看，RabbitMQ 的这两种方案也属于是基于轮询检测机制的一种。</p><h2 id="Pulsar-延时消息的设计思路"><a href="#Pulsar-延时消息的设计思路" class="headerlink" title="Pulsar 延时消息的设计思路"></a>Pulsar 延时消息的设计思路</h2><p>Pulsar 实现延迟消息的思路是比较特殊，也比较取巧，没有独立线程来检测消息到期，而是在消费的时候通过消费动作来触发检测。</p><img src="/2023/08/27/%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E5%AE%9A%E6%97%B6-%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%EF%BC%9F/image-20230827115600296.png" class="" title="image-20230827115600296"><p>如上图所示，延迟投递的消息会先保存到一个叫做 Delayed Message Tracker 的数据结构中。Delayed Message Tracker 在堆外内存维护一个 delayed index 优先级队列，这个优先级队列会根据延迟时间进行堆排序，延迟时间最短的会放在队列的头部，时间越长越靠近队列尾部。消费者消费时，会先去 Delayed Message Tracker 检查，是否有到期需要投递的消息。如果有到期的消息，则从 Tracker 中拿出对应的 index，找到对应的消息进行消费。如果没有到期的消息，则直接消费正常的消息。如果集群出现 Broker 宕机或者 Topic 的 Leader 切换，Pulsar 会重建 delayed index 队列，来保证延迟投递的消息能够正常工作。从根本上来看，Pulsar 的方案也是基于轮询检测机制的一种，只是用来检测的线程是消费线程而已。</p><p><a href="https://time.geekbang.org/column/article/690417">29｜延时消息：如何实现高性能的定时&#x2F;延时消息？ (geekbang.org)</a></p><h2 id="Kafka-延时机制的设计思路"><a href="#Kafka-延时机制的设计思路" class="headerlink" title="Kafka 延时机制的设计思路"></a>Kafka 延时机制的设计思路</h2><p>kafka 本身不支持延时消息，但是支持延时机制，用于延时回包、延时确认的场景。从技术上看，Kafka 的延时机制是典型的基于时间轮算法来实现的。它的实现核心是多级时间轮以及使用 Java 的 DelayQueue 来保存延时数据和推进时间，整体实现性能和实现方案是非常优雅的。这块网上的资料很多，就不展开讲细节了，有兴趣的话可以自己去研究下。</p><p>总结消息队列的延时消息，解决的是客户端发送的消息在一定时间后可以被消费端消费到的问题。从技术上拆解，可以分为数据存储、如何让消息可见、定时机制、主动推送四个部分。其中如何让消息可见和定时机制是这节课重点解决的问题。</p><p>如何让消息可见，从技术上来看，有定时检测写入和消费时判断数据是否可见两个思路。两种方案都是先将数据写入到一个独立的存储。区别在于，前一种方案会有独立线程定时检测数据是否到期，然后将到期的数据写入到实际的 Topic。后一种方案是指每次消费时都去检查一下是否有消息到期，有的话就直接返回给消费者，省去了写入原 Topic 的步骤。</p><p>个人推荐前一种方案。定时机制的核心逻辑是随着时间的推进，能够精准高效获得到期的延时消息进行处理。从技术上看，可以拆解为定时器和延时消息定位处理两部分。定时器负责推进时间，延时消息定位处理是指设计合适的数据结构，来高效完成延时消息的定位和取出。在延时消息的整体技术方案层面，主要有基于轮询检测机制的实现和基于时间轮机制的实现两种方案。目前主流消息队列主要采用前一种方案，原因是时间轮的方案实现较为复杂，实现成本较高。从技术合理性来看，时间轮是一种更好的方案。主流消息队列中，RocketMQ、RabbitMQ、Pulsar 都实现了延时消息，Kafka 没有实现延时消息，但是支持延时机制。RocketMQ、RabbitMQ、Pulsar 的设计思路都是基于轮询检测机制的实现，Kafka 的延时机制是经典的时间轮实现，支持毫秒级的任意时长的延时机制。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>API网关调研报告</title>
      <link href="/2023/08/25/API%E7%BD%91%E5%85%B3%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/"/>
      <url>/2023/08/25/API%E7%BD%91%E5%85%B3%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="项目的选型"><a href="#项目的选型" class="headerlink" title="项目的选型"></a>项目的选型</h2><p>分布式架构下选择SpringMVC不是不可行，只是不是最佳的选择，不适合微服务的架构，无法实现服务的发现和负载均衡，缺少统一的认证和鉴权，无法处理大量的请求</p><p>互联网现代分布式架构应用技术主要以 RPC 通信的微服务模型为主，代表技术如；Dubbo、gRPC、Thrift，它们的通信协议为 RPC 协议（Remote Procedure Call，远程过程调用），这样的调用方式可以提高微服务间的通信性能。</p><p>介绍你的项目一句话概括：</p><p>它可以通过RPC服务的注册和发现机制，把接口注册网关中心，再通过网关算力执行接收 HTTP 请求协议进行解析做 RPC 接口的泛化调用。</p><img src="/2023/08/25/API%E7%BD%91%E5%85%B3%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/image-20230825214200979.png" class="" title="image-20230825214200979"><p>一 SpringGateWay和API网关的区别：</p><p>1.Spring Cloud 网关和此项目 API 网关的不同之处在于它们服务的范围和实现方式，Spring Cloud网关服务于微服务架构中的服务治理，而API网关则服务于分布式系统中的RPC调用管理。 </p><p>1.1 功能特点： Spring Cloud网关是一种微服务网关技术，它主要提供路由、限流、鉴权、负载均衡等基本功能，通过Spring Cloud Gateway等组件来实现。相比于API网关，它更加专注于处理微服务之间的HTTP通信问题。 API网关则是一种面向API接口的网关技术，它可以提供API管理、鉴权、熔断、限流、路由等各类所需自行扩展的功能。相比于Spring Cloud网关，API网关更加适用于更适合使用各类RPC通信的大型微服务分布式系统架构。在中大型有自研能力的互联网公司用途广泛，包括；字节、阿里、京东、美团、滴滴等。 </p><p>1.2 技术架构： Spring Cloud网关使用Spring Cloud Gateway等微服务框架组件来实现，通常采用Java语言进行开发。API 网关则使用Java、Netty、RPC、GRPC等技术实现，可以使用多种语言进行开发，如Java、Go等，自主扩展性强。 </p><p>2.如果使用我们套API网关，首先是你们的服务有一定的体量规模，微服务较多，RPC使用频繁。需要对 RPC 接口到 HTTP 的转换进行统一管理和对外发布 HTTP 协议接口。那么可以使用。使用时，看是那套 RPC 如果是 Dubbo 那么我们正好已经开发，只需要简单配置即可使用。但前提是需要在你们公司部署一套我们的 API网关系统。</p><p>二 ZK和网关的注册中心的区别：</p><p>RPC 注册中心是 RPC 一套体系的内容，与网关不是一个注册中心。网关维护的是网关算力和 RPC 注册服务的连接分配以及服务发现等功能，都是给网关使用的。但 RPC 不一定都是 Dubbo 还可能是其他的，这与网关是分开的，任何一个RPC泛化调用都可以被配置到网关中使用.</p><p>三 池化和路由策略</p><p>连接的引入是希望可复用 RPC 链接，以避免每个请求都要重新建立连接的开销。有点像数据库的连接池一样路由策略体现在 API 网关的调用上，可以进行PIN 哈希路由做切量处理。</p><p>四 网关如何实现高可用</p><p>部署多个实例 监控与自动恢复 调用RPC失败重传 网管相当于只是协议转发 如果失败重新配置超时和重试的机制</p><p>五 API网关的性能瓶颈在哪</p><p>API网关主要的通信都在Core核心层，其他动作都是讲接口拉取下来后做映射操作，不消耗性能。最终的性能体现就是在接收 HTTP请求 -&gt;协议转换 -&gt; 验证-&gt;获取映射接口-&gt; 泛化调用，这条链路上。所以可能发生的瓶颈点为;<br>1.网络I&#x2F;0性能:如果网关处理不当，会导致请求堆积、响应延迟等问题。可以通过优化网络I&#x2F;0的方式来提高系统的性能，例如使用 Netty 的异步非阻塞模型，使用季拷贝技术等。<br>2.Dubbo服务性能: API 网关的主要作用是将 HTTP 请求转换为 Dubbo 泛化调用，因此 Dubbo 服务的性能也是个关键因素。如果 Dubbo 服务本身存在性能问题，会导致 API 网关的性能下降。可以通过优化 Dubbo 服务的方式来提高系统的性能，例如使用 Dubbo 的异步调用、负载均衡分布式部多套]等.<br>3.线程池性能:API 网关需要处理大量的请求，因此线程池的性能也是一个关键因素。如果线程池的参数设置不合理，会导致线程池过度消耗 CPU、内存等资源，从而影响系统的性能。可以通过优化线程池的方式来提高系统的性能，例如设置合理的线程池大小、队列长度、拒绝策略等。[尽量要做到快速释放，超时四时间需要设置好]<br>4.内存使用:API 网关需要维护大量的连接和请求，因此内存使用也是一个关键因素。如果内存使用不当，会导致内存泄漏、内存溢出等问题，从而影响系统的性能。可以通过优化内存使用的方式来提高系统的性能，例如使用内存池、避免创建过多的对象等。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> api网关 </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sanfor实习-数据信道</title>
      <link href="/2023/08/25/Sanfor%E5%AE%9E%E4%B9%A0-%E6%95%B0%E6%8D%AE%E4%BF%A1%E9%81%93/"/>
      <url>/2023/08/25/Sanfor%E5%AE%9E%E4%B9%A0-%E6%95%B0%E6%8D%AE%E4%BF%A1%E9%81%93/</url>
      
        <content type="html"><![CDATA[<h1 id="0-介绍"><a href="#0-介绍" class="headerlink" title="0 介绍"></a>0 介绍</h1><h2 id="0-1-背景"><a href="#0-1-背景" class="headerlink" title="0.1 背景"></a>0.1 背景</h2><p>SAWF的数据信道模块目前主要是指的接口层，由许多标准化的restful API组成，其价值如下：</p><p>在AIOps算法服务上解耦数据和计算，对于数据的读写操作均通过API进行，屏蔽各种数据库的具体细节，使得算法能专注于模型和计算；<br>具备一定的数据处理功能，能够将不同数据源（VM、Mongodb、mySQL等）的数据加工成统一的、算法易于使用的数据格式；<br>利于AI计算结果的存储和查询，缩短从上线到运营结果的时间；<br>更好的可扩展性，对于后续引入其他算法和数据源，可以加入相应的api来获取和存储数据，不影响其他已有的功能，整体改动小，降低开发成本；<br>标准化数据的获取和存储，优雅管理、减少维护、便于统计；</p><h2 id="0-2-需求场景及问题"><a href="#0-2-需求场景及问题" class="headerlink" title="0.2 需求场景及问题"></a>0.2 需求场景及问题</h2><p>目标是将数据信道模块建设成易使用、高可用、易扩展的基础模块。</p><p>SAWF数据源：</p><p>VictoriaMetrics：时序数据等（主要）<br>MongoDB：配置数据、结果数据、告警等（主要）<br>MySQL：配置信息等<br>ClickHouse：日志信息等<br>nebula：图数据库<br>（待扩展）<br>主要需求：</p><p>Read API：<br>AIOps算法需要从各种数据源拉取各种数据进行计算；<br>算法的结果数据可被二次查询。<br>Write API：<br>算法的计算结果存入aiops的数据库（MongoDB）；<br>产生的告警数据存储到aiops的数据库（MongoDB）；<br>日志服务产生的日志信息需要存入aiops数据库（ClickHouse）。<br>健康检查：检查后端存储数据库是否健康状态；<br>批量处理：支持读写的批量操作，提高查询和读写效率。<br>目标和问题：</p><p>易使用：数据的读写更简单易用，数据的格式更标准统一，改变现在各自为战、风格迥异的现状。<br>高可用：将数据信道模块建设成统一的数据入口和出口，可以复用代码、减少开发成本、避免重复工作，但是也会带来性能、容错等问题，特别是VictoriaMetrics的访问压力较大，需要保证模块的可用性和容错性。<br>易扩展：无论是引入新的算法模型、新的数据库还是新的数据源，均可以在不影响其他模块和功能的前提下，以较小的改动（例如仅仅修改配置文件）来支撑新的内容。</p><h2 id="0-3-选型结论"><a href="#0-3-选型结论" class="headerlink" title="0.3 选型结论"></a>0.3 选型结论</h2><p>基于goFrame框架建立一整套覆盖各个数据源的restful风格的API，以HTTP请求的方式读写数据，具备一定的计算能力，支持对数据格式进行灵活的变换。<br>gf框架支持docker镜像编译，默认提供了Kubernetes集群化部署的Yaml模板，通过kustomize管理。<br>gf框架的ORM组件功能完备、扩展性强，但仅支持mySQL和redis，其他数据源需根据情况自行开发。</p><h1 id="1-开发"><a href="#1-开发" class="headerlink" title="1 开发"></a>1 开发</h1><h2 id="1-1-框架选型"><a href="#1-1-框架选型" class="headerlink" title="1.1 框架选型"></a>1.1 框架选型</h2><table><thead><tr><th></th><th>Gin</th><th>GoFrame</th></tr></thead><tbody><tr><td>优势</td><td>轻量级，简单易用，高效</td><td>活跃的中文社区，详细的中文文档，模块化设计和工程化设计思想，组件丰富</td></tr><tr><td>社区</td><td>英语</td><td>中文（国内）</td></tr><tr><td>缺点</td><td>缺少配套的开发组件</td><td>缺少成熟的实践</td></tr><tr><td>框架性能</td><td>快</td><td>较快</td></tr><tr><td>开发组件</td><td>基本没有，需要自行实现或者用第三方</td><td>全面、开箱即用且不断更新优化中</td></tr><tr><td>路由算法</td><td>压缩前缀树：快，但是规则苛刻</td><td>快，精准匹配用哈希表；带参数路由用链表；对象注册路由的方式方便实现mvc</td></tr><tr><td>官方文档</td><td><a href="https://gin-gonic.com/zh-cn/docs/">https://gin-gonic.com/zh-cn/docs/</a></td><td><a href="https://goframe.org/pages/viewpage.action?pageId=1114399">https://goframe.org/pages/viewpage.action?pageId=1114399</a></td></tr><tr><td>简介</td><td>Go语言写的轻量级HTTP Web框架。它提供了Martini风格的API并有更好的性能。</td><td>工程完备、简单易用，模块化、高质量、高性能、企业级开发框架。</td></tr><tr><td>项目地址</td><td><a href="http://github.com/gin-gonic/gin">http://github.com/gin-gonic/gin</a></td><td><a href="http://github.com/gogf/gf">http://github.com/gogf/gf</a></td></tr></tbody></table><p>GoFrame框架更加适合，主要优势：</p><p>针对业务项目而言，提供了开发规范、项目规范、命名规范、设计模式、开发工具链、丰富的模块、高质量代码和详细的文档，社区活跃。<br>提供了常用的核心开发组件，如：缓存、日志、文件、时间、队列、数组、集合、字符串、定时器、命令行、文件锁、内存锁、对象池、连接池、数据校验、数据编码、文件监控、定时任务、数据库ORM、TCP&#x2F;UDP组件、进程管理&#x2F;通信、 并发安全容器等等。<br>提供了Web服务开发的系列核心组件，如：Router、Cookie、Session、路由注册、配置管理、模板引擎等等，支持热重启、热更新、多域名、多端口、多服务、HTTPS、Rewrite等特性。</p><h2 id="1-2-工程组织"><a href="#1-2-工程组织" class="headerlink" title="1.2 工程组织"></a>1.2 工程组织</h2><p>gf框架给出了详细且严格的组织目录模板，通过gf命令可自动生成：gf init demo -u</p><img src="/2023/08/25/Sanfor%E5%AE%9E%E4%B9%A0-%E6%95%B0%E6%8D%AE%E4%BF%A1%E9%81%93/image-20230827201602810.png" class="" title="image-20230827201602810"><table><thead><tr><th>目录&#x2F;文件名</th><th>说明</th><th>描述</th><th>具体业务</th></tr></thead><tbody><tr><td>- api</td><td>对外接口</td><td></td><td>N&#x2F;A</td></tr><tr><td>|L v1</td><td>当前接口版本</td><td></td><td>N&#x2F;A</td></tr><tr><td>||- victoria.go</td><td>vm接口文件</td><td></td><td>路由注册</td></tr><tr><td>||-mangodb.go</td><td>mangodb接口文件</td><td></td><td>路由注册</td></tr><tr><td>|L XXX</td><td>待扩展</td><td></td><td>可扩展mySQL、redis等</td></tr><tr><td>|-hack</td><td>工具脚本</td><td>存放项目开发工具、脚本等内容，主要是CLI工具的配置。</td><td>暂时不用</td></tr><tr><td>|- internal</td><td>内部逻辑</td><td>业务逻辑存放目录。通过Golang internal特性对外部隐藏可见性。</td><td>N&#x2F;A</td></tr><tr><td>||-cmd</td><td>入口命令</td><td>项目的总管理目录</td><td>总路由管理</td></tr><tr><td>||-const</td><td>常量定义</td><td>项目所有常量定义。</td><td>所有常量定义</td></tr><tr><td>||-controller</td><td>接口处理</td><td>接收&#x2F;解析用户输入参数的入口&#x2F;接口层，转到具体的业务逻辑。</td><td>转到logic处理数据</td></tr><tr><td>||-dao</td><td>数据操作对象</td><td>通过对象方式访问底层数据源，底层基于ORM组件实现。往往需要结合entity和do通用使用。其中的文件按照数据表名称进行命名，一个数据表一个文件及其一个对应的DAO对象。操作数据表即是通过DAO对象以及相关操作方法实现。支持MySQL。</td><td>暂时不用</td></tr><tr><td>||-logic</td><td>业务封装</td><td>业务逻辑实现和封装。</td><td>业务逻辑：获取数据、处理数据、存储数据等。</td></tr><tr><td>||-model</td><td>结构模型</td><td></td><td>N&#x2F;A</td></tr><tr><td>|||-do</td><td>数据转换模型</td><td>由gf gen dao生成。数据转换模型用于业务模型到数据模型的转换，由工具维护，不能修改。</td><td>N&#x2F;A</td></tr><tr><td>|||-entity</td><td>数据模型</td><td>由gf gen dao生成。数据模型即与数据表一一对应的数据结构，不能修改。</td><td>N&#x2F;A</td></tr><tr><td>|||-victoria.go</td><td>业务模型文件</td><td>业务模型即是与业务相关的数据结构，自行按需定义。</td><td>自定义所需的数据结构</td></tr><tr><td>||Lmango.go</td><td>业务模型文件</td><td>业务模型即是与业务相关的数据结构，自行按需定义。</td><td>自定义所需的数据结构</td></tr><tr><td>|Lservice</td><td>业务接口</td><td>由gf gen service根据logic包生成。生成后需要1)在每个业务模块中加上接口的具体实现注入；2)在main包的最顶部合适位置引入同步生成的一个接口实现注册文件logic.go</td><td>N&#x2F;A</td></tr><tr><td>|-manifest</td><td>交付清单</td><td>包含程序编译、部署、运行、配置的文件。</td><td>N&#x2F;A</td></tr><tr><td>||-config</td><td>配置管理</td><td>配置文件存放目录。</td><td>项目配置文件（用toml），会自动解析。</td></tr><tr><td>||-docker</td><td>镜像文件</td><td>Docker镜像相关依赖文件，脚本文件等等。</td><td>暂时不用</td></tr><tr><td>|Ldeploy</td><td>部署文件</td><td>部署相关的文件。默认提供了Kubernetes集群化部署的Yaml模板，通过kustomize管理。</td><td>暂时不用</td></tr><tr><td>|-utility</td><td>工具函数</td><td></td><td>公共函数在这里</td></tr><tr><td>Lmango.go</td><td>入口文件</td><td>程序入口。</td><td>程序入口。</td></tr></tbody></table><h1 id="2-设计细节"><a href="#2-设计细节" class="headerlink" title="2 设计细节"></a>2 设计细节</h1><p>遵循数据信道模块的目标：易使用、高可用、易扩展的基础模块，仅实现对各数据源的封装，提供restful的API供其他业务模块（前端、算法等）使用。</p><h2 id="2-1-易用性"><a href="#2-1-易用性" class="headerlink" title="2.1 易用性"></a>2.1 易用性</h2><p>模块设计了一整套满足restful风格的API，逐步覆盖各类数据源，通过HTTP请求获取JSON格式的数据，以HTTP请求方法区分、参数控制。</p><p>具体请参考本文档第3节【接口设计】。</p><h2 id="2-2-可用性"><a href="#2-2-可用性" class="headerlink" title="2.2 可用性"></a>2.2 可用性</h2><h3 id="2-2-1-横向扩展"><a href="#2-2-1-横向扩展" class="headerlink" title="2.2.1 横向扩展"></a>2.2.1 横向扩展</h3><p>横向扩展能力主要是指模块水平扩展：主要是指面对业务压力时，能够通过水平扩展达到负载均衡，从而保证服务的可用性。</p><p>压力主要集中在Victoria Metrics数据库，VM数据库天然支持水平扩展。而API作为VM数据库的数据出口同样也会面临访问压力，因此，一方面，模块需要保证无状态来支持水平扩展；另外一方面，所选用的开发框架gf默认支持docker镜像部署和Kubernetes集群化部署，通过kustomize管理（默认提供了Kubernetes集群化部署的Yaml模板，细节需要后续深入学习），能够进行水平扩展，通过分布式多节点来实现负载均衡。</p><h3 id="2-2-2-查询缓存"><a href="#2-2-2-查询缓存" class="headerlink" title="2.2.2 查询缓存"></a>2.2.2 查询缓存</h3><p>AIOps中的算法、前端等业务对数据的操作均已读为主，对于短时间重复的读操作，若能设置查询缓存，将能有效的提升查询性能。</p><p>单进程内存缓存：优点是性能非常高效，但是只能在单进程内使用，若服务采用分布式多点部署，多节点之间的缓存可能会失效&#x2F;产生数据不一致的情况。</p><p>分布式查询缓存：更加适用大多数的场景，通过Redis服务器来实现查询数据的缓存，Redis缓存在多节点保证缓存的数据一致性时非常有用。</p><p>gf框架支持缓存管理：内置的gcache模块采用了适配器设计模式，提供了Adapter适配器接口，任何实现了Adapter接口的对象均可注册到缓存管理对象中，使得开发者可以对缓存管理对象进行灵活的扩展。并且框架通过社区模块提供了gcache的Redis缓存适配实现，API服务可以直接拿来使用。仓库地址：<a href="https://github.com/gogf/gcache-adapter%E3%80%82">https://github.com/gogf/gcache-adapter。</a></p><h3 id="2-2-3-流量治理"><a href="#2-2-3-流量治理" class="headerlink" title="2.2.3 流量治理"></a>2.2.3 流量治理</h3><p>开发框架gf正在设计自己的微服务熔断和限制模块。</p><p>1.服务容错</p><p>AIOps中不可避免的会出现一些意外情况，比如数据库不可用&#x2F;响应超时、API本身崩溃、网络中断等，为了防止整个系统雪崩或者因为错误占用大量服务器资源，服务需要具备一定的容错性才能保证其可用性</p><table><thead><tr><th align="left">问题</th><th>容错设计思路</th><th>说明</th><th align="left">参考实现</th></tr></thead><tbody><tr><td align="left">数据库不可用&#x2F;响应超时</td><td>熔断</td><td>如果某个数据库不可用或者大量超时，此时，熔断数据库的调用，对于后续调用请求，不在继续调用目标服务，直接返回，快速释放资源。如果目标服务情况好转则恢复调用。</td><td align="left">Netflix的开源项目Hystrix、go-kratos&#x2F;aegis实现的google_sre算法</td></tr><tr><td align="left">API模块崩溃</td><td>重启</td><td>因为意外情况服务挂掉</td><td align="left">K8S支持监控并重启</td></tr></tbody></table><p> 2.流量控制</p><p>作为AIOps的数据出入口，API服务会承受流量压力。算法等上游服务对本服务请求QPS过大时，需要通过一定的策略（如延迟处理、拒绝处理）对上游服务的请求量进行限制，以保证本服务不被压垮，从而持续提供稳定服务。常见的限流算法有滑动窗口、令牌桶、漏桶等。</p><table><thead><tr><th>算法</th><th>优点</th><th>缺点</th><th>参考实现</th></tr></thead><tbody><tr><td>自适应模式（容器化）</td><td>根据硬件配置，设置load或者cpu占用率，根据设置的cpu占用率和load阈值，获取过去一段时间内的请求数量。将这个数量作为限流，如果系统负载达到这个显示，将这个请求数量作为请求阈值。</td><td>根据系统资源利用率进行限流，会因为其它程序或进程的高cpu占用率触发限流。这部分可以采用docker 封装，获取docker 的相关占用率进行避免。</td><td>alibaba&#x2F;Sentinel、go-kratos&#x2F;kratos</td></tr><tr><td>漏桶模式</td><td>实现简单；基本实现了平滑处理，在单位时间内，可以控制请求数量。</td><td>1. 不考虑服务器负载，如果有大量请求会对请求进行缓存，按照漏桶流量进行处理；2. 难以配置合适的参数。</td><td>N&#x2F;A</td></tr><tr><td>滑动窗口模式</td><td>细分时间精度可以避免请求超过阈值，可以应对简单的突发流量。</td><td>1. 使用内存或者redis来维护窗口，如果时间颗粒度太细，会造空间容量过大；2. 否决式限流，很难进行阻塞等待处理，无法“削峰填谷”。</td><td>N&#x2F;A</td></tr><tr><td>令牌桶模式（非容器化）</td><td>实现简单；限制平均流入速率，允许一定程度突发请求（支持一次拿多个令牌）。</td><td>不好估算流入速度， 需要根据不同机器或环境进行配置。</td><td>N&#x2F;A</td></tr></tbody></table><p>3.服务降级</p><p>API自身服务压力增大时，采取一些手段，增强自身服务的处理能力，以保障服务的持续可用，常用的手段有读旧数据、降低实时性、降低数据一致性等。</p><p>需要在后续根据实际业务情况具体分析。</p><h2 id="2-3-扩展性"><a href="#2-3-扩展性" class="headerlink" title="2.3 扩展性"></a>2.3 扩展性</h2><p>在不影响已有功能和服务其他模块的前提下，以较小的改动（例如仅仅修改配置文件）来引入新的业务需求、新的数据库还是新的数据源。</p><table><thead><tr><th>场景</th><th>说明</th><th>解决思路</th></tr></thead><tbody><tr><td>新增业务需求</td><td>主要是指当有新的算法模型、业务模块需要使用数据时调用API。</td><td>API的设计在满足易用的前提下，应该提供尽可能全面可用的接口供上层业务（包括算法、前端等）使用，避免接口开发不完备和冗余。</td></tr><tr><td>新增已有数据库实例</td><td>能够在不更改代码的情况下通过增加&#x2F;修改配置文件的方式引入新的已有的数据库实例。</td><td>gf框架的数据库ORM支持mySQL和redis的相关实现，对于AIOps使用较多的mongodb缺乏支持，需要根据gf的源码自行实现&#x2F;寻找成熟的开源实现（七牛封装了一个）。</td></tr><tr><td>新增数据源</td><td>主要是指当业务有需要时引入新的数据库类型，例如后续可能会加入的图数据库nebula。</td><td>当有此类需求时需要对模块的代码进行迭代，新增代码对相应的数据库类型的功能进行封装，并且不会影响已有的功能和业务。</td></tr></tbody></table><h1 id="3-接口设计"><a href="#3-接口设计" class="headerlink" title="3 接口设计"></a>3 接口设计</h1><h2 id="3-1-Read-API（P1）"><a href="#3-1-Read-API（P1）" class="headerlink" title="3.1 Read API（P1）"></a>3.1 Read API（P1）</h2><p>支持以GET接口的方式获取AIOps算法需要的数据，后续还需要支持获取结果数据（从VM，MongoDB中）供前端、监控等模块使用。</p><p>边界定义如下：</p><p>单次请求获取数据时间范围不超过7天<br>单次请求获取数据返回的总条数不超过10万条<br>单次请求超时时间为3s</p><h3 id="3-1-1-Victoria-Metrics-API"><a href="#3-1-1-Victoria-Metrics-API" class="headerlink" title="3.1.1 Victoria Metrics API"></a>3.1.1 Victoria Metrics API</h3><p>Victoria Metrics数据库&#x2F;普罗米修斯提供默认且全面的restful api接口，因此数据信道模块只需要在原始接口的基础上进行封装，使得整体接口的风格统一。</p><table><thead><tr><th>配置字段名</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>vm_url</td><td>实际普罗米修斯API的url</td><td><a href="http://10.109.134.70:30481/select/0/prometheus/api/v1/">http://10.109.134.70:30481/select/0/prometheus/api/v1/</a></td></tr></tbody></table><p>查询单点时序数据</p><table><thead><tr><th>接口名称</th><th>查询单点数据</th></tr></thead><tbody><tr><td>所属模块</td><td>v1&#x2F;victoria</td></tr><tr><td>接口功能</td><td>查询单时间点数据v1&#x2F;victoria</td></tr><tr><td>方法</td><td>GET</td></tr><tr><td>URL</td><td>&#x2F;v1&#x2F;victoria&#x2F;single</td></tr><tr><td>请求参数</td><td></td></tr><tr><td>参数名</td><td>类型</td></tr><tr><td>————</td><td>——————</td></tr><tr><td>metrics</td><td>string</td></tr><tr><td>includeEndpoints</td><td>string</td></tr><tr><td>excludeEndpoints</td><td>string</td></tr><tr><td>includeTags</td><td>string</td></tr><tr><td>excludeTags</td><td>string</td></tr><tr><td>aggrFunc</td><td>string</td></tr><tr><td>aggrKeys</td><td>string</td></tr><tr><td>time</td><td>uint64</td></tr><tr><td>isTransform</td><td>bool</td></tr><tr><td>customAdditionalKey</td><td>string</td></tr><tr><td>others</td><td>map[string]string</td></tr><tr><td>响应参数(转换)</td><td></td></tr><tr><td>参数名</td><td>类型</td></tr><tr><td>————</td><td>——————</td></tr><tr><td>metric</td><td>string</td></tr><tr><td>endpoint</td><td>string</td></tr><tr><td>tags</td><td>map[string]interface{}</td></tr><tr><td>values</td><td>[]map[string]float</td></tr></tbody></table><p>请求示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/v1/victoria/single?metrics=host_net_dp_sess_use&amp;includeEndpoints=host-0894efb78dc1</span><br></pre></td></tr></table></figure><p>接口正常 (不转换)</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;success&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;isPartial&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;resultType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;matrix&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;result&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;metric&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;__name__&quot;</span><span class="punctuation">:</span> <span class="string">&quot;host_net_recv_bytes_per_second&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;az_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;87feb6f5-10a6-40fa-961f-4aac9fa1bacb&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;cloud_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;6338720532&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;cluster_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;6338720597&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;endpoint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;host-0894efb78dc1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;iface&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eth0&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;region_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;4aa88ced54da4d4ab305c3b8a3d72174&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sf_server&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;step&quot;</span><span class="punctuation">:</span> <span class="string">&quot;30&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;values&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="punctuation">[</span></span><br><span class="line">                        <span class="number">1664453644</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;138184.2&quot;</span></span><br><span class="line">                    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="punctuation">[</span></span><br><span class="line">                        <span class="number">1664453944</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="string">&quot;104945.9&quot;</span></span><br><span class="line">                    <span class="punctuation">]</span></span><br><span class="line">                <span class="punctuation">]</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            ......</span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>响应示例 (转换)</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> n<span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;metric&quot;</span><span class="punctuation">:</span> <span class="string">&quot;host_net_recv_bytes_per_second&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;endpoint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;host-0894efb78dc1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;az_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;87feb6f5-10a6-40fa-961f-4aac9fa1bacb&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;cloud_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;6338720532&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;cluster_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;6338720597&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;iface&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eth0&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;region_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;4aa88ced54da4d4ab305c3b8a3d72174&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sf_server&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;step&quot;</span><span class="punctuation">:</span> <span class="string">&quot;30&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;values&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span><span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1664453644</span><span class="punctuation">,</span> <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;138184.2&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span><span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1664453944</span><span class="punctuation">,</span> <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;104945.9&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        ......</span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ok&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;success&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>接口异常响应参数：</p><table><thead><tr><th>参数名</th><th>类型</th><th>必选</th><th>说明</th></tr></thead><tbody><tr><td>success</td><td>int</td><td>Y</td><td>接口异常响应时为0</td></tr><tr><td>errcode</td><td>int</td><td>Y</td><td>scc错误码</td></tr><tr><td>message</td><td>string</td><td>Y</td><td>错误信息（unicode编码）</td></tr></tbody></table><p>接口异常响应示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;success&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;errcode&quot;</span><span class="punctuation">:</span> <span class="number">503</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;系统繁忙，请稍后重试&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p> 查询范围时序数据</p><img src="/2023/08/25/Sanfor%E5%AE%9E%E4%B9%A0-%E6%95%B0%E6%8D%AE%E4%BF%A1%E9%81%93/image-20230827211603834.png" class="" title="image-20230827211603834"><img src="/2023/08/25/Sanfor%E5%AE%9E%E4%B9%A0-%E6%95%B0%E6%8D%AE%E4%BF%A1%E9%81%93/image-20230827211642744.png" class="" title="image-20230827211642744"><img src="/2023/08/25/Sanfor%E5%AE%9E%E4%B9%A0-%E6%95%B0%E6%8D%AE%E4%BF%A1%E9%81%93/image-20230827211658672.png" class="" title="image-20230827211658672"><p>查询标签</p><img src="/2023/08/25/Sanfor%E5%AE%9E%E4%B9%A0-%E6%95%B0%E6%8D%AE%E4%BF%A1%E9%81%93/image-20230827211740287.png" class="" title="image-20230827211740287"><img src="/2023/08/25/Sanfor%E5%AE%9E%E4%B9%A0-%E6%95%B0%E6%8D%AE%E4%BF%A1%E9%81%93/image-20230827211752347.png" class="" title="image-20230827211752347"><h3 id="3-1-2-MongoDB-API"><a href="#3-1-2-MongoDB-API" class="headerlink" title="3.1.2 MongoDB API"></a>3.1.2 MongoDB API</h3><p>目前的gf框架不支持mongodb，需要额外引入第三方库，go语言常用mongodb驱动是mgo和mongo-go-driver，二者的比较如下：</p><table><thead><tr><th></th><th>mgo</th><th>mango-go-driver</th></tr></thead><tbody><tr><td>优点</td><td>特性丰富<br/>实践丰富<br/>文档充足<br/>简单易上手</td><td>官方驱动<br/>设计底层，效率更高<br/>支持事务<br/>功能更全面</td></tr><tr><td>缺点</td><td>停止维护</td><td>上手较复杂</td></tr></tbody></table><p>考虑到代码之后的扩展性，选择功能更加强大且全面的官方驱动mongo-go-driver，并且mongo-go-driver支持在建立连接时可以通过option设置超时时间等加入限制，更加贴合业务需求。</p><p>可配置信息</p><img src="/2023/08/25/Sanfor%E5%AE%9E%E4%B9%A0-%E6%95%B0%E6%8D%AE%E4%BF%A1%E9%81%93/image-20230827211952456.png" class="" title="image-20230827211952456"><img src="/2023/08/25/Sanfor%E5%AE%9E%E4%B9%A0-%E6%95%B0%E6%8D%AE%E4%BF%A1%E9%81%93/image-20230827212010369.png" class="" title="image-20230827212010369"><img src="/2023/08/25/Sanfor%E5%AE%9E%E4%B9%A0-%E6%95%B0%E6%8D%AE%E4%BF%A1%E9%81%93/image-20230827212027345.png" class="" title="image-20230827212027345"><p>查询文档数量</p><img src="/2023/08/25/Sanfor%E5%AE%9E%E4%B9%A0-%E6%95%B0%E6%8D%AE%E4%BF%A1%E9%81%93/image-20230827212045497.png" class="" title="image-20230827212045497"><h2 id="3-2-Write-API（P1）"><a href="#3-2-Write-API（P1）" class="headerlink" title="3.2 Write API（P1）"></a>3.2 Write API（P1）</h2><p>支持以POST接口的方式写入数据。</p><p>主要接收数据如下：</p><p>AIOps算法的结果数据，写入MongoDB<br>告警数据，写入MongoDB<br>边界定义如下：</p><p>单次请求写入数据大小不超过10MB，如果超过，需要以迭代形式处理<br>单次请求超时时间为3s</p><h2 id="3-3-Healthy-API（P1）"><a href="#3-3-Healthy-API（P1）" class="headerlink" title="3.3 Healthy API（P1）"></a>3.3 Healthy API（P1）</h2><p>支持检查后端存储是否健康状态，支持检查的后端存储有：</p><p>MongoDB<br>VictoriaMetrics<br>ClickHouse<br>MySQL</p><h2 id="3-4-Batch-API（P2）"><a href="#3-4-Batch-API（P2）" class="headerlink" title="3.4 Batch API（P2）"></a>3.4 Batch API（P2）</h2><p>支持批量读写数据，是在Read API 和 Write API上的二次封装。主要用于批量操作，提高查询和读写效率。</p><h1 id="4-REST-API错误代码"><a href="#4-REST-API错误代码" class="headerlink" title="4.REST API错误代码"></a>4.REST API错误代码</h1><p>rest api应当有合适的状态码或者响应码来反映错误，通常控制在20个以内常用的，并且出错后需要在响应体补充细化的error信息（包含code和message）。</p><table><thead><tr><th>代码</th><th>描述</th><th>说明</th></tr></thead><tbody><tr><td>200</td><td>描述正确</td><td>不明确区分时返回</td></tr><tr><td>201</td><td>资源正确创建</td><td>Write API成功写入数据时返回</td></tr><tr><td>202</td><td>请求正确，处理中</td><td>计算&#x2F;处理中，暂时没法返回结果</td></tr><tr><td>204</td><td>请求正确，无返回</td><td>Write API成功删除数据时返回</td></tr><tr><td>400</td><td>请求错误</td><td>参数不正确</td></tr><tr><td>401</td><td>未授权&#x2F;未认证</td><td>请求的时候没有带上Token&#x2F;认证失败</td></tr><tr><td>403</td><td>禁止访问</td><td>访问权限不对</td></tr><tr><td>404</td><td>找不到资源</td><td></td></tr><tr><td>405</td><td>不可使用的HTTP方法</td><td></td></tr><tr><td>409</td><td></td><td>唯一性的资源冲突等</td></tr><tr><td>500</td><td>服务器错误</td><td>不明确区分时返回</td></tr><tr><td>503</td><td>服务不可用</td><td>超时&#x2F;数据库连接失败等</td></tr></tbody></table><h1 id="5-安全与校验"><a href="#5-安全与校验" class="headerlink" title="5.安全与校验"></a>5.安全与校验</h1><p>JWT：Json Web Token</p><p>优点：基于JSON，通用；构成简单，便于传送；服务端不保存会话信息，易于横向扩展；可附加一定的非敏感信息。</p><p>GoFrame的gvalid。</p><h1 id="6-hydra性能测试"><a href="#6-hydra性能测试" class="headerlink" title="6.hydra性能测试"></a>6.hydra性能测试</h1><p>本次测试了1）通过hydra连接mongodb和直连mongodb获取数据性能差别；2）hydra分批获取数据性能差别，如下表所示：</p><img src="/2023/08/25/Sanfor%E5%AE%9E%E4%B9%A0-%E6%95%B0%E6%8D%AE%E4%BF%A1%E9%81%93/image-20230827212203089.png" class="" title="image-20230827212203089"><p>说明：查询循环10次。</p><p>结论：通过hydra查询数据相较于直连mongodb会有额外时间开销：单次获取数据区别不大，连续获取数据hydra耗时约为直连的2~3倍（因为连续获取同库同集合数据直连会有导管加速）。</p><img src="/2023/08/25/Sanfor%E5%AE%9E%E4%B9%A0-%E6%95%B0%E6%8D%AE%E4%BF%A1%E9%81%93/image-20230827212218358.png" class="" title="image-20230827212218358"><p>结论：分批查询数据会造成较大的额外时间开销。</p>]]></content>
      
      
      <categories>
          
          <category> Sanfor实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> minio </tag>
            
            <tag> dvc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>API网关-注册中心的设计与开发</title>
      <link href="/2023/08/17/API%E7%BD%91%E5%85%B3-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/"/>
      <url>/2023/08/17/API%E7%BD%91%E5%85%B3-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>在实现了apigateway的core通信模块之后，已经开发出了一个核心通信组件，下一步开发api-gateway-center</p><h2 id="apigateway-center"><a href="#apigateway-center" class="headerlink" title="apigateway-center"></a>apigateway-center</h2><h3 id="网关注册中心服务的初始创建"><a href="#网关注册中心服务的初始创建" class="headerlink" title="网关注册中心服务的初始创建"></a>网关注册中心服务的初始创建</h3><img src="/2023/08/17/API%E7%BD%91%E5%85%B3-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/image-20230817141935745.png" class="" title="image-20230817141935745"><p>如图所示，api-gateway-core 是最核心的通信层。那么它还需要把注册的网关接口在通信核心<br>服务中启动起来。那么怎么启动呢?<br>这个启动过程首先来自于 api-gateway-sdk 向 api-gateway-center 推送注册接口，之后在通过网关引擎 api-gateway-engin 拉取接口并在本地服务完成注册。最后再调用到网关接口时，则是通过 api-gateway-core 调用到对应的 RPC 应用中那么 api-gateway-sdk 并不是主要工程，没有它的是可以通过 api-gateway-admin 配置。所以在整个流程中 api-gateway-center、api-gateway-core 是两个核心工程，能更好的串联流程。</p><p>apigateway-center采用DDD领域驱动设计，具体的领域驱动设计的好处，会再出一章进行讲解</p><h3 id="网关注册中心库表结构设计"><a href="#网关注册中心库表结构设计" class="headerlink" title="网关注册中心库表结构设计"></a>网关注册中心库表结构设计</h3><p>网关注册中心，一手管理通信一手管理服务，让RPC注册到通信层，在用户调用HTTP接口的时候，把协议转换调用到对应的RPC服务上去</p><img src="/2023/08/17/API%E7%BD%91%E5%85%B3-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/image-20230817143215873.png" class="" title="image-20230817143215873"><h3 id="库表设计"><a href="#库表设计" class="headerlink" title="库表设计"></a>库表设计</h3><img src="/2023/08/17/API%E7%BD%91%E5%85%B3-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/image-20230817143330816.png" class="" title="image-20230817143330816"><h3 id="网关注册算力节点领域服务实现"><a href="#网关注册算力节点领域服务实现" class="headerlink" title="网关注册算力节点领域服务实现"></a>网关注册算力节点领域服务实现</h3><img src="/2023/08/17/API%E7%BD%91%E5%85%B3-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/image-20230817145333524.png" class="" title="image-20230817145333524">]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> api网关 </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sanfor实习-大模型数据存储调研方案</title>
      <link href="/2023/08/14/Sanfor%E5%AE%9E%E4%B9%A0-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E8%B0%83%E7%A0%94%E6%96%B9%E6%A1%88/"/>
      <url>/2023/08/14/Sanfor%E5%AE%9E%E4%B9%A0-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E8%B0%83%E7%A0%94%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="大模型数据存储方案调研"><a href="#大模型数据存储方案调研" class="headerlink" title="大模型数据存储方案调研"></a><strong>大模型数据存储方案调研</strong></h1><h1 id="背景和需求"><a href="#背景和需求" class="headerlink" title="背景和需求"></a>背景和需求</h1><p>在训练大模型时，通常需要使用大量的数据来训练模型。这些数据通常以CSV或JSON等文件格式存储。</p><p>需求描述：</p><p>为了解决数据版本管理的难题，需要开发一个数据管理系统，该系统能够支持以下功能：</p><p>1.数据上传与下载：用户可以通过系统将数据上传到系统中，并能够从系统中下载数据。</p><p>2.数据格式支持：系统应该支持CSV和JSON等常见的数据格式，以确保用户可以方便地上传和下载数据。</p><p>3.数据版本管理：系统应该能够跟踪数据的版本，并记录数据的修改历史。每次数据更新后，系统应该自动记录并保存新版本的数据，并能够让用户方便地查看和比较不同版本的数据。</p><p>4.数据权限管理：系统应该能够为每个用户分配不同的数据权限。例如，某些用户可能只能查看数据，而其他用户可能能够修改和删除数据。</p><p>5.数据备份与恢复：系统应该能够定期备份数据，并能够在需要时快速恢复数据。此外，系统应该能够提供数据恢复历史记录，以便用户可以查看以前备份的数据版本。</p><p>6.数据安全性：系统应该采取适当的安全措施来保护数据的安全性和隐私性，例如加密和身份验证等。</p><p>7.用户交互性：系统应该提供友好的用户界面或者简单的脚本，使用户可以方便地上传、下载、查看和比较不同版本的数据。</p><h1 id="业界方案"><a href="#业界方案" class="headerlink" title="业界方案"></a>业界方案</h1><h2 id="2-1版本控制工具对比"><a href="#2-1版本控制工具对比" class="headerlink" title="2.1版本控制工具对比"></a>2.1版本控制工具对比</h2><table><thead><tr><th>组件名称</th><th>优点</th><th>缺点</th><th>参考</th></tr></thead><tbody><tr><td>Git LFS</td><td>1.与Git集成紧密，易于使用和学习。2.开源免费。3.支持多种云存储服务，如GitHub，GitLab，Bitbucket等。4.可以通过指定文件大小或文件类型来选择哪些文件需要使用LFS管理。</td><td>1.LFS存储需要额外的云存储空间和带宽，可能会增加成本。2.对于大型二进制文件，速度较慢，可能会影响开发效率。3.不支持文件锁定，可能造成冲突。</td><td><a href="../text">https://docs.atrust.sangfor.com/pages/viewpage.action?pageId=177161067#id-01-skm-multi%E6%89%93%E5%8C%85%E6%94%B9%E8%BF%9Bgitlfs%E6%94%AF%E6%8C%81-%E6%96%B9%E6%A1%88%E9%80%89%E6%8B%A9</a>（内网）</td></tr><tr><td>DVC</td><td>1.兼容 Git对存储没有限制 2.低冲突分支 3.与语言和框架无关 4.支持HDFS、Hive 和 Apache Spark 4.不受 Git 托管限制。5.DVC 优化了大文件的存储和传输。</td><td>在大型项目中，数据管道可能变得非常复杂，这可能使得使用 DVC 变得困难。虽然 DVC 与 Git 集成得非常好，但是与其他数据科学和机器学习工具的集成可能不那么顺畅。</td><td><a href="../text">快速入门</a>DVC（三）：数据与模型版本管理 - 掘金<a href="../text">Version Data and Code - DagsHub Docs</a><a href="../text">python - Installation DVC on MinIO storage - Stack Overflow</a></td></tr><tr><td>pachyderm</td><td>1.Pachyderm 提供了对数据的版本管理功能，使您能够跟踪数据的变化历史。2.Pachyderm 通过记录每个数据版本的元数据和变化历史，确保数据处理管道的可重现性。3.Pachyderm 具备分布式处理的能力，可以处理大规模的数据集和复杂的处理管道。 它使用容器和分布式计算框架（如 Kubernetes）来实现高性能的数据处理和存储。</td><td>配置繁琐，组件太新了。Pachyderm 的配置和管理可能需要一些额外的工作。 需要设置和管理数据管道、存储和计算资源等。</td><td>在单服务器创建服务的话，连接会超时。借用sealosK8s环境，有很多依赖要配置很多信息，pod无法启动。</td></tr><tr><td>ArtiVC</td><td>1.一个方便的命令行工具，用于在云存储上进行数据版本控制。2.快照数据并在版本之间切换数据。3.ArtiVC支持三个主要的云提供商（AWS S3，Google Cloud Storage，Azure Blob Storage）和使用SSH的远程文件系统。</td><td>avc 在能力上部分git 的命令支持并不是很多，但是从简单上来说还是很方便的不需要外部依赖，lakefs 是一个不错的基于git 的数据管理能力，而且社区也比较活跃。目前avc 似乎更偏向于fix 了，新功能比较少了，avc 代码量并不大。</td><td><a href="../inline">GitHub - InfuseAI&#x2F;ArtiVC: A version control system to manage large files.</a><a href="../inline">Rclone</a>找到了一个方法需要依赖rclone：<a href="../text">GitHub - rongfengliang&#x2F;minio_rclone_artivc_learning: minio_rclone_artivc_learning</a></td></tr><tr><td>Git Annex</td><td>1.Git Annex 允许在不下载整个大文件的情况下获取其元数据。2.可以选择只在需要时获取大文件。</td><td>1.Git Annex 的命令和工作流程与标准的 Git 工作流程不同。2.跨平台支持有限：虽然 Git Annex 支持多种操作系统，但在某些系统上的表现可能不如其他工具。</td><td>与git工作流不太一样，不推荐</td></tr><tr><td>Lake FS</td><td>lakeFS 提供对数据湖的版本控制，并使用类似 Git 的语义来创建和访问这些版本。它与格式无关。1.适用于众多数据工具和平台。通过写入时复制机制最大限度地减少数据重复。2.在任何规模的数据湖中都能保持高性能。包括可配置的垃圾回收功能。3.在生产中得到了证明，并拥有一个活跃的社区。</td><td>命令行操作的话需要lakectl，要是想要提交和合并分支的话，需要用脚本来</td><td>后期维护成本不确定</td></tr><tr><td>Mercurial Largefiles Extension</td><td>1.Mercurial 是一个分布式版本控制系统，与 Git 类似。Largefiles Extension 是 Mercurial 的一个扩展，用于处理大文件。2.Largefiles Extension 的命令和工作流程与标准的 Mercurial 工作流程一致。</td><td>1.需要 Mercurial：这是一个 Mercurial 的扩展，如果项目使用 Git，可能不合适。2.跨平台支持有限：虽然 Mercurial 支持多种操作系统，但在某些系统上的表现可能不如其他工具。</td><td>与git不兼容，不推荐</td></tr><tr><td>Perforce Helix Core</td><td>1.支持大规模文件管理，具有高度可扩展性和可定制性。2.支持文件级别的锁定和权限控制。3.支持多种操作系统，包括Windows，Linux和MacOS等。</td><td>1.需要学习新的工具和命令。2.价格较高，需要购买许可证。3.对于小型项目，可能会过于复杂。</td><td>不开源，不推荐。</td></tr><tr><td>SVN LFS</td><td>1.与Subversion集成紧密，易于使用和学习。2.开源免费。3.支持多种云存储服务，如GitHub，GitLab，Bitbucket等。4.可以通过指定文件大小或文件类型来选择哪些文件需要使用LFS管理。</td><td>1.对于大型二进制文件，速度较慢，可能会影响开发效率。2.不支持文件锁定，可能造成冲突。</td><td>和其他组件集成有版本冲突问题，不推荐。</td></tr><tr><td>Plastic SCM</td><td>1.可视化的界面，易于使用和学习。2.分布式架构，支持多种工作流程。3.支持文件锁定和权限控制。</td><td>1.价格较高，需要购买许可证。2.在大型团队或大型项目中，可能会出现性能问题3.不如Git或Subversion流行，缺乏相关社区和支持。</td><td>不开源，不推荐。</td></tr></tbody></table><h2 id="2-2挂载存储调研"><a href="#2-2挂载存储调研" class="headerlink" title="2.2挂载存储调研"></a>2.2挂载存储调研</h2><table><thead><tr><th>特性</th><th>ceph</th><th>minio</th><th></th></tr></thead><tbody><tr><td>开发语言</td><td>C</td><td>go</td><td></td></tr><tr><td>一致性</td><td>强一致性</td><td>强一致性</td><td></td></tr><tr><td>用户</td><td>可拓展云原生数据库</td><td>可拓展云原生数据库</td><td></td></tr><tr><td>存储方式</td><td>块对象文件</td><td>对象存储</td><td></td></tr><tr><td>活跃度</td><td>高</td><td>高</td><td></td></tr><tr><td>github star数</td><td>12.2k</td><td>40.1k</td><td></td></tr><tr><td>管理工具</td><td>命令行和原生DashBoard</td><td>命令行和操作界面</td><td></td></tr><tr><td>操作界面</td><td>提供可视化界面面</td><td>提供可视化界面</td><td></td></tr><tr><td>数据恢复</td><td>Recove和backfill是Ceph数据修复中最重要的两个部分。</td><td>使用纠删码、Checksum来防止错误和静默数据污染，数据恢复性好，即使丢失1&#x2F;2的磁盘也能恢复数据。</td><td></td></tr><tr><td>官网</td><td><a href="https://ceph.com/en/">Ceph.io — Home</a></td><td><a href="http://minio.org.cn/">MinIO | 高性能, Kubernetes 原生对象存储</a></td><td></td></tr><tr><td>学习成本</td><td>高</td><td>中</td><td></td></tr><tr><td>版本管理</td><td>支持</td><td>支持</td><td></td></tr><tr><td>组件兼容</td><td>S3兼容API，并与所有现代数据框架（如Spark，Hive，AWS Athena，DuckDB和Presto）无缝协作。</td><td>支持Veeak、SPark大数据处理组件、Hive数据仓库工具、AWS CLI底层存储服务，Nginx负载均衡组件等。</td><td></td></tr><tr><td>社区链接</td><td><a href="https://ceph.com/en/community/">Ceph.io — Community</a></td><td><a href="https://blog.minio.org.cn/">MinIO 博客</a></td><td></td></tr><tr><td>读写权限</td><td></td><td>nginx<a href="https://cloud.tencent.com/developer/article/2076784">使用Nginx反向代理minio，提供文件公共访问-腾讯云开发者社区-腾讯云</a></td><td></td></tr></tbody></table><h1 id="方案选型结论"><a href="#方案选型结论" class="headerlink" title="方案选型结论"></a>方案选型结论</h1><p>1.开发者角色（做数据修改、更新、提交）：dvc+minIO做版本管理，类git方式后台操作（补充dvc刚才说的项目创建和提交流程）。</p><p>2.标注员角色（观察数据）：lakeFS激活分支，lakectel+rclone同步迁移minIO-&gt;lakeFS分支，前端通过激活的分支观测数据。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="4-1Lakefs"><a href="#4-1Lakefs" class="headerlink" title="4.1Lakefs"></a>4.1Lakefs</h2><p>docker部署lakefs，使用默认存储。</p><p>内网测试链接：<a href="../text">http://10.109.97.231:8000/repositories/quickstart/objects</a></p><p>access_key_id: AKIAJL66XTCWW6O6IRNQ</p><p>secret_access_key: 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</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="language-bash"> --name lakefs --pull always \</span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line">-p <span class="number">8000</span>:<span class="number">8000</span> \</span><br><span class="line"></span><br><span class="line">treeverse/lakefs:latest \</span><br><span class="line"></span><br><span class="line"><span class="keyword">run</span><span class="language-bash"> --local-settings</span></span><br></pre></td></tr></table></figure> <img src="/2023/08/14/Sanfor%E5%AE%9E%E4%B9%A0-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E8%B0%83%E7%A0%94%E6%96%B9%E6%A1%88/png.png" class="" title="img"><img src="/2023/08/14/Sanfor%E5%AE%9E%E4%B9%A0-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E8%B0%83%E7%A0%94%E6%96%B9%E6%A1%88/png-1691987397650-3.png" class="" title="img"><img src="/2023/08/14/Sanfor%E5%AE%9E%E4%B9%A0-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E8%B0%83%E7%A0%94%E6%96%B9%E6%A1%88/png-1691987405190-6.png" class="" title="img"><img src="/2023/08/14/Sanfor%E5%AE%9E%E4%B9%A0-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E8%B0%83%E7%A0%94%E6%96%B9%E6%A1%88/png-1691987416895-9.png" class="" title="img"><p>docker部署lakefs，使用minio作为底层存储，需要dremio组件。</p><ol><li>构建dremio的dockerfile。</li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> DREMIO/DREMIO-OSS:<span class="number">20.1</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">USER</span> ROOT</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> DREMIO-ENV /OPT/DREMIO/CONF/DREMIO-ENV</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> JPROFILER\_LINUX\_12\_0\_4.DEB /OPT/JPROFILER\_LINUX\_12\_0\_4.DEB</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> DPKG -I /OPT/JPROFILER\_LINUX\_12\_0\_4.DEB</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">USER</span> DREMIO</span><br></pre></td></tr></table></figure><p> 2.创建docker-copose.yaml文件，进行编排。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="language-bash"> --name lakefs --pull always \</span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line">-p <span class="number">8000</span>:<span class="number">8000</span> \</span><br><span class="line"></span><br><span class="line">treeverse/lakefs:latest \</span><br><span class="line"></span><br><span class="line"><span class="keyword">run</span><span class="language-bash"> --local-settings</span></span><br><span class="line"></span><br><span class="line">lakefs搭配minio的配置文件</span><br></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.docker-compose.yaml</span><br><span class="line"></span><br><span class="line">VERSION: <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line">SERVICES:</span><br><span class="line"></span><br><span class="line">LAKEFS:</span><br><span class="line"></span><br><span class="line">IMAGE: DALONGRONG/LAKEFS:DEV-<span class="number">2022</span>-<span class="number">02</span>-<span class="number">09</span></span><br><span class="line"></span><br><span class="line">PORTS:</span><br><span class="line"></span><br><span class="line">- <span class="string">&quot;8000:8000&quot;</span></span><br><span class="line"></span><br><span class="line">DEPENDS\_ON:</span><br><span class="line"></span><br><span class="line">- <span class="string">&quot;POSTGRES&quot;</span></span><br><span class="line"></span><br><span class="line">ENVIRONMENT:</span><br><span class="line"></span><br><span class="line">- LAKEFS\_AUTH\_ENCRYPT\_SECRET\_KEY=$&#123;LAKEFS\_AUTH\_ENCRYPT\_SECRET\_KEY:-SOME RANDOM SECRET STRING&#125;</span><br><span class="line"></span><br><span class="line">- LAKEFS\_DATABASE\_CONNECTION\_STRING=$&#123;LAKEFS\_DATABASE\_CONNECTION\_STRING:-POSTGRES://LAKEFS:LAKEFS@POSTGRES/POSTGRES?SSLMODE=DISABLE&#125;</span><br><span class="line"></span><br><span class="line">- LAKEFS\_BLOCKSTORE\_TYPE=$&#123;LAKEFS\_BLOCKSTORE\_TYPE:-S3&#125;</span><br><span class="line"></span><br><span class="line">- LAKEFS\_BLOCKSTORE\_LOCAL\_PATH=$&#123;LAKEFS\_BLOCKSTORE\_LOCAL\_PATH:-/HOME/LAKEFS&#125;</span><br><span class="line"></span><br><span class="line">- LAKEFS\_GATEWAYS\_S3\_DOMAIN\_NAME=$&#123;LAKEFS\_GATEWAYS\_S3\_DOMAIN\_NAME:-S3.LOCAL.LAKEFS.IO:<span class="number">8000</span>&#125;</span><br><span class="line"></span><br><span class="line">- LAKEFS\_BLOCKSTORE\_S3\_CREDENTIALS\_ACCESS\_KEY\_ID=$&#123;AWS\_ACCESS\_KEY\_ID:-MINIO&#125;</span><br><span class="line"></span><br><span class="line">- LAKEFS\_BLOCKSTORE\_S3\_CREDENTIALS\_ACCESS\_SECRET\_KEY=$&#123;AWS\_SECRET\_ACCESS\_KEY:-MINIO123&#125;</span><br><span class="line"></span><br><span class="line">- LAKEFS\_LOGGING\_LEVEL=$&#123;LAKEFS\_LOGGING\_LEVEL:-INFO&#125;</span><br><span class="line"></span><br><span class="line">- LAKEFS\_STATS\_ENABLED</span><br><span class="line"></span><br><span class="line">- LAKEFS\_BLOCKSTORE\_S3\_ENDPOINT=HTTP://S3:<span class="number">9000</span></span><br><span class="line"></span><br><span class="line">- LAKEFS\_BLOCKSTORE\_S3\_FORCE\_PATH\_STYLE=TRUE</span><br><span class="line"></span><br><span class="line">- LAKEFS\_COMMITTED\_LOCAL\_CACHE\_DIR=$&#123;LAKEFS\_COMMITTED\_LOCAL\_CACHE\_DIR:-/HOME/LAKEFS/.LOCAL\_TIER&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash">:</span></span><br><span class="line"></span><br><span class="line">[</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;/APP/WAIT-FOR&quot;</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;POSTGRES:5432&quot;</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;--&quot;</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;/APP/LAKEFS&quot;</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;RUN&quot;</span></span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">POSTGRES:</span><br><span class="line"></span><br><span class="line">IMAGE: <span class="string">&quot;POSTGRES:$&#123;PG\_VERSION:-11&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">COMMAND: <span class="string">&quot;-C LOG\_MIN\_MESSAGES=FATAL&quot;</span></span><br><span class="line"></span><br><span class="line">PORTS:</span><br><span class="line"></span><br><span class="line">- <span class="string">&quot;5432:5432&quot;</span></span><br><span class="line"></span><br><span class="line">ENVIRONMENT:</span><br><span class="line"></span><br><span class="line">POSTGRES\_USER: LAKEFS</span><br><span class="line"></span><br><span class="line">POSTGRES\_PASSWORD: LAKEFS</span><br><span class="line"></span><br><span class="line">LOGGING:</span><br><span class="line"></span><br><span class="line">DRIVER: NONE</span><br><span class="line"></span><br><span class="line">DREMIO:</span><br><span class="line"></span><br><span class="line">BUILD: ./</span><br><span class="line"></span><br><span class="line">PORTS:</span><br><span class="line"></span><br><span class="line">- <span class="string">&quot;9047:9047&quot;</span></span><br><span class="line"></span><br><span class="line">- <span class="string">&quot;31010:31010&quot;</span></span><br><span class="line"></span><br><span class="line">S3:</span><br><span class="line"></span><br><span class="line">IMAGE: MINIO/MINIO</span><br><span class="line"></span><br><span class="line">ENVIRONMENT:</span><br><span class="line"></span><br><span class="line">- <span class="string">&quot;MINIO\_ACCESS\_KEY=MINIO&quot;</span></span><br><span class="line"></span><br><span class="line">- <span class="string">&quot;MINIO\_SECRET\_KEY=MINIO123&quot;</span></span><br><span class="line"></span><br><span class="line">COMMAND: SERVER /DATA --CONSOLE-ADDRESS <span class="string">&quot;:9001&quot;</span></span><br><span class="line"></span><br><span class="line">PORTS:</span><br><span class="line"></span><br><span class="line">- <span class="string">&quot;9000:9000&quot;</span></span><br><span class="line"></span><br><span class="line">- <span class="string">&quot;9001:9001&quot;</span></span><br></pre></td></tr></table></figure><h2 id="4-2dagsHub-dvc"><a href="#4-2dagsHub-dvc" class="headerlink" title="4.2dagsHub+dvc"></a>4.2dagsHub+dvc</h2><p>创建仓库之后需要，git的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git clone https://dagshub.com/wsyyyyyyyy/data-storage-test.git</span><br><span class="line"></span><br><span class="line">cd data-storage-test</span><br><span class="line"></span><br><span class="line">echo &quot;# data-storage-test&quot; \&gt;\&gt; README.md</span><br><span class="line"></span><br><span class="line">git add README.md</span><br><span class="line"></span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line"></span><br><span class="line">git branch -M main</span><br><span class="line"></span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><p>配置数据存储有四个选项，选择DVC存储。</p><img src="/2023/08/14/Sanfor%E5%AE%9E%E4%B9%A0-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E8%B0%83%E7%A0%94%E6%96%B9%E6%A1%88/png-1691987584599-12.png" class="" title="img"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mkdir data</span><br><span class="line"></span><br><span class="line">echo &quot;## Data will be uploaded to this folder&quot; \&gt;\&gt; data/readme.md</span><br><span class="line"></span><br><span class="line">dvc add data/.</span><br><span class="line"></span><br><span class="line">dvc remote add origin https://dagshub.com/wsyyyyyyyy/data-storage-test.dvc</span><br><span class="line"></span><br><span class="line">dvc remote modify origin --local auth basic</span><br><span class="line"></span><br><span class="line">dvc remote modify origin --local user wsyyyyyyyy</span><br><span class="line"></span><br><span class="line">dvc remote modify origin --local password b86f657e4d58b7944411812e2f1b9f59ee562935</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m &quot;Added dvc&quot;</span><br><span class="line"></span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line">dvc push -r origin</span><br></pre></td></tr></table></figure><p><strong>注意</strong> ： <strong>DagsHub</strong>  <strong>不支持</strong>  <strong>DVC 3.0</strong>  <strong>及其新的哈希机制。请使用</strong>  <strong>DVC 2.x</strong></p><h2 id="4-3minio-dvc"><a href="#4-3minio-dvc" class="headerlink" title="4.3minio+dvc"></a>4.3minio+dvc</h2><h3 id="minio部署"><a href="#minio部署" class="headerlink" title="minio部署"></a>minio部署</h3><p>docker创建一个节点的minio</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir minio</span><br><span class="line"></span><br><span class="line">cd minio</span><br><span class="line"></span><br><span class="line">mkdir data</span><br><span class="line"></span><br><span class="line">mkdir config</span><br></pre></td></tr></table></figure><p>需要为minio开放两个端口，一个9000端口，一个静态端口，此处为9999</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">docker run --name minio \</span><br><span class="line"></span><br><span class="line">-p 9000:9000 \</span><br><span class="line"></span><br><span class="line">-p 9999:9999 \</span><br><span class="line"></span><br><span class="line">-d --restart=always \</span><br><span class="line"></span><br><span class="line">-e &quot;MINIO\_ROOT\_USER=admin&quot; \</span><br><span class="line"></span><br><span class="line">-e &quot;MINIO\_ROOT\_PASSWORD=admin123&quot; \</span><br><span class="line"></span><br><span class="line">-v /home/minio/data:/data \</span><br><span class="line"></span><br><span class="line">-v /home/minio/config:/root/.minio \</span><br><span class="line"></span><br><span class="line">minio/minio server /data \</span><br><span class="line"></span><br><span class="line">--console-address &#x27;0.0.0.0:9999&#x27;</span><br></pre></td></tr></table></figure><p>访问<a href="../text">MinIO Console</a>即可访问 admin&#x2F;admin123</p><p>创建的存储桶的名称为using-dvc-for-version-management-of-data-storage</p><img src="/2023/08/14/Sanfor%E5%AE%9E%E4%B9%A0-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E8%B0%83%E7%A0%94%E6%96%B9%E6%A1%88/png-1691987627905-15.png" class="" title="img"><img src="/2023/08/14/Sanfor%E5%AE%9E%E4%B9%A0-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E8%B0%83%E7%A0%94%E6%96%B9%E6%A1%88/png-1691987637873-18.png" class="" title="img"><p>创建访问密钥访问密钥：2HSkCcNeJB4xeuNCRf3R</p><p>密钥：4a0GdZ69RUatfNGXxoamKTzVNoJ5TL8tnLKWpnYy</p><p>{“url”:”<a href="http://47.93.38.210:9999/api/v1/service-account-credentials%22,%22accessKey%22:%222HSkCcNeJB4xeuNCRf3R%22,%22secretKey%22:%224a0GdZ69RUatfNGXxoamKTzVNoJ5TL8tnLKWpnYy%22,%22api%22:%22s3v4%22,%22path%22:%22auto%22%7D">http://47.93.38.210:9999/api/v1/service-account-credentials&quot;,&quot;accessKey&quot;:&quot;2HSkCcNeJB4xeuNCRf3R&quot;,&quot;secretKey&quot;:&quot;4a0GdZ69RUatfNGXxoamKTzVNoJ5TL8tnLKWpnYy&quot;,&quot;api&quot;:&quot;s3v4&quot;,&quot;path&quot;:&quot;auto&quot;}</a></p><p>底层协议应该是一样的，所以可以直接调用API来进行访问</p><p>参考 <a href="../text">python - 在 MinIO 存储上安装 DVC - IT工具网</a></p><p><a href="../text">python - Installation DVC on MinIO storage - Stack Overflow</a></p><p>在 本地安装 DVC，通过DVC来进行数据管理</p><h3 id="DVC集成minio"><a href="#DVC集成minio" class="headerlink" title="DVC集成minio"></a>DVC集成minio</h3><p>首先需要安装dvc的脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install &quot;dvc[s3]&quot;</span><br></pre></td></tr></table></figure><p>设置申请的权限配置</p><p>1.设置默认远程（将”bucket名称”更改为你的minio backet）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setup default remote (change &quot;bucket-name&quot; to your minio backet name)</span><br><span class="line">dvc remote add -d minio s3://bucket-name -f</span><br><span class="line">add information about storage url (where &quot;https://minio.mysite.com&quot; your url)</span><br><span class="line">dvc remote modify minio endpointurl https://minio.mysite.com</span><br><span class="line">add info about login and password</span><br><span class="line">dvc remote modify minio access\_key\_id my\_login</span><br><span class="line">dvc remote modify minio secret\_access\_key my\_password</span><br></pre></td></tr></table></figure><h3 id="DVC文件操作"><a href="#DVC文件操作" class="headerlink" title="DVC文件操作"></a>DVC文件操作</h3><p>拉取文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dvc pull -r \&lt;old\_remote\_name\&gt; --all-commits --all-tags --all-branches</span><br></pre></td></tr></table></figure><p>提交文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dvc push -r \&lt;new\_remote\_name\&gt; --all-commits --all-tags --all-branches</span><br></pre></td></tr></table></figure><p>dvc有个问题，就是即使和git联动了，也没法在git上面透视数据，因为实际数据是存在dvc的远端存储的，git只是元数据，dagshub能很好的解决这个问题，dagshub storage可以存dvc的数据内容，所以在dagshub上面就可以直接透视数据了，可以三条路线依次去探索：</p><p>1.dvc除了用dagshub透视以外有没有别的解决方案可视化dvc数据内容，最好像dagshub一样，一个类git的页面管理和可视数据</p><p>2.dagshub号称开源，但是我没找到开源部署的方法，可以找找dagshub的部署方案</p><p>3.寻找dagshub的开源替代品，目前来看lakeFS只是复刻了版本管理的能力，和dagshub比还是差远了</p><h2 id="4-4minio-avc-rclone"><a href="#4-4minio-avc-rclone" class="headerlink" title="4.4minio+avc+rclone"></a>4.4minio+avc+rclone</h2><p>启动minio,docker-compose的配置，之前安装了可以不安装了，但是要看清是不是 Version&#x3D;3.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">minio:</span><br><span class="line"></span><br><span class="line">image: minio/minio</span><br><span class="line"></span><br><span class="line">ports:</span><br><span class="line"></span><br><span class="line">- 9000:9000</span><br><span class="line"></span><br><span class="line">- 19001:19001</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line"></span><br><span class="line">- ./data:/data/</span><br><span class="line"></span><br><span class="line">environment:</span><br><span class="line"></span><br><span class="line">MINIO\_ACCESS\_KEY: minio</span><br><span class="line"></span><br><span class="line">MINIO\_SECRET\_KEY: minio123</span><br><span class="line"></span><br><span class="line">command: server --console-address :19001 --quiet /data</span><br></pre></td></tr></table></figure><p>1.首先安装rclone</p><p>方法一：在线安装（有权限）</p><p>sudo -v ; curl <a href="https://rclone.org/install.sh">https://rclone.org/install.sh</a> | sudo bash</p><p>方法二：离线安装（内网）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~/Temp</span><br><span class="line"></span><br><span class="line">$ cd ~/Temp/</span><br><span class="line"></span><br><span class="line">$ curl -O https://downloads.rclone.org/rclone-current-linux-amd64.zip</span><br><span class="line"></span><br><span class="line">$ unzip rclone-current-linux-amd64.zip</span><br><span class="line"></span><br><span class="line">$ cd rclone-\*-linux-amd64</span><br><span class="line"></span><br><span class="line">$ mkdir ~/bin</span><br><span class="line"></span><br><span class="line">$ cp rclone ~/bin/</span><br><span class="line"></span><br><span class="line">$ export PATH=$PATH:~/bin</span><br><span class="line"></span><br><span class="line">$ echo &#x27;export PATH=$PATH:~/bin&#x27; \&gt;\&gt; ~/.bashrc # Optional, only if you want to add it to</span><br><span class="line"></span><br><span class="line">your path at every login</span><br></pre></td></tr></table></figure><p>2.配置rlcone，s3 环境准备好了之后就是进行rclone 的配置，通过配置一个minio s3 的就可以了，参考上边的配置，~&#x2F;.config&#x2F;rclone&#x2F;rclone.conf 可以直接拷贝复制(这里我也是本机的服务器，所以配置的是127.0.0.1，注意ip，为了配置简单，我们先把密钥暂且删掉。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[myremote]</span><br><span class="line"></span><br><span class="line">type = s3</span><br><span class="line"></span><br><span class="line">provider = Minio</span><br><span class="line"></span><br><span class="line">access\_key\_id = admin</span><br><span class="line"></span><br><span class="line">secret\_access\_key = admin123</span><br><span class="line"></span><br><span class="line">endpoint = http://127.0.0.1:9999/</span><br></pre></td></tr></table></figure><p>然后安装artivc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew tap infuseai/artivc</span><br><span class="line"></span><br><span class="line">brew install artivc</span><br></pre></td></tr></table></figure><p>集成使用</p><p>初始化工程init</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avc init rclone://myremote/dalong/first</span><br></pre></td></tr></table></figure><p>（这里相当于初始化之后的路径&#x2F;rclone:&#x2F;&#x2F;myremote&#x2F;&#x2F;桶的名称&#x2F;&#x2F;下面的子页面）</p><p>添加文件以及push</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;testAVC&quot; \&gt; demoapp</span><br><span class="line"></span><br><span class="line">avc push</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Sanfor实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> minio </tag>
            
            <tag> dvc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>API网关-网关核心系统设计与开发</title>
      <link href="/2023/08/10/API%E7%BD%91%E5%85%B3-%E7%BD%91%E5%85%B3%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/"/>
      <url>/2023/08/10/API%E7%BD%91%E5%85%B3-%E7%BD%91%E5%85%B3%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="网关是什么？"><a href="#网关是什么？" class="headerlink" title="网关是什么？"></a>网关是什么？</h2><p><a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E5%85%B3"><strong>网关</strong></a>（Gateway）是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。<strong>API网关</strong>也是随着对传统庞大的单体应用（All in one）拆分为众多的微服务（Microservice）以后，所引入的统一通信管理系统。用于运行在外部http请求与内部rpc服务之间的一个流量入口，实现对外部请求的<code>协议转换</code>、<code>参数校验</code>、<code>鉴权</code>、<code>切量</code>、<code>熔断</code>、<code>限流</code>、<code>监控</code>、<code>风控</code>等各类共性的通用服务。</p><p>之前的做法都是在RPC服务之上在开发一个对应的WEB服务，WEB服务可以想象成Spring MVC的服务，在Spring MVC的工程中调用RPC服务，最终提供HTTP接口给到应用中来使用。</p><img src="/2023/08/10/API%E7%BD%91%E5%85%B3-%E7%BD%91%E5%85%B3%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/image-20230810110356600.png" class="" title="image-20230810110356600"><h2 id="网关架构设计"><a href="#网关架构设计" class="headerlink" title="网关架构设计"></a>网关架构设计</h2><p>如果希望实现一个能支撑百亿级吞吐量的网关，那么它就应该是按照分布式架构思维做去中心化设计，支持横向扩展。让每一台网关服务都成为一个算力，把不同的微服务RPC接口，按照权重策略计算动态分配到各个算力组中，做到分布式运算的能力。</p><p>要把网关的通信模块、管理服务、SDK、注册中心、运营平台等依次分开单独开发实现，这样才能进行独立的组合包装使用。就像官网的通信不应该一开始就把 Netty 相关的服务全部绑定到 Spring 容器，这样即增加了维护成本，也降低了系统的扩展性。</p><p><a href="https://gitcode.net/KnowledgePlanet/gateway/api-gateway-core/-/tree/master">https://gitcode.net/KnowledgePlanet/gateway/api-gateway-core/-/tree/master</a></p><img src="/2023/08/10/API%E7%BD%91%E5%85%B3-%E7%BD%91%E5%85%B3%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/image-20230810110615757.png" class="" title="image-20230810110615757"><p>整个API网关设计的核心内容可以分为以下五块：</p><p><strong>通信协议处理</strong>：这是API网关最基本的功能，需要使用NIO框架如Netty来处理HTTP请求，并进行协议转换和泛化调用到RPC服务，然后将返回的数据信息返回给客户端。</p><p><strong>注册中心</strong>：API网关作为一个算力资源，每次部署一个网关服务，都需要向注册中心注册一个算力。注册中心还需要接收RPC接口的注册，可以通过SDK自动扫描注册或者手动管理。一旦RPC接口注册完成，注册中心会根据AHP权重计算将其分配到一组网关算力上进行使用。</p><p><strong>路由服务</strong>：每个注册的Netty通信服务都会与其对应的分组网关相关联。例如，通过配置Nginx的路由规则，将不同的接口调用请求路由到相应的Netty服务上。这样可以确保接口请求能够正确地到达目标服务。</p><p><strong>责任链下的插件模块调用</strong>：鉴权、授权、熔断、降级、限流、流量切分等服务虽然不是API网关的核心功能，但通常也会作为共性通用的服务放置在网关层进行统一设计、实现和使用。</p><p><strong>管理后台</strong>：作为一个完整的API网关项目，管理后台是必不可少的。管理后台提供接口的注册维护、模拟测试、日志查询、流量整形、网关配置管理等功能，方便对API网关进行管理和监控。</p><table><thead><tr><th>序号</th><th>系统</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>api-gateway-core</td><td>网关核心系统：处理网络通信转换，接收和处理HTTP请求，调用RPC服务，以及负责责任链模块的调用。</td></tr><tr><td>2</td><td>api-gateway-admin</td><td>网关管理系统：用于管理网关接口的后台系统，包括接口的注册、下线和停用的控制等功能。</td></tr><tr><td>3</td><td>api-gateway-sdk</td><td>网关注册组件：通过注解方式采集接口信息并发送消息进行接口的注册。</td></tr><tr><td>4</td><td>api-gateway-center</td><td>网关注册中心：提供网关注册中心服务，负责登记和管理网关接口的信息。</td></tr><tr><td>5</td><td>api-gateway-test-provider</td><td>网关测试工程：提供RPC接口的测试服务。</td></tr><tr><td>6</td><td>api-gateway-test-consumer</td><td>网关测试工程：消费RPC接口的测试服务。希望以上整理满足你的需求。如果还有其他问题，请随时提问。</td></tr></tbody></table><h2 id="api-gateway-core开发"><a href="#api-gateway-core开发" class="headerlink" title="api-gateway-core开发"></a>api-gateway-core开发</h2><h3 id="HTTP请求会话处理"><a href="#HTTP请求会话处理" class="headerlink" title="HTTP请求会话处理"></a>HTTP请求会话处理</h3><p>HTTP请求到API网关，网关再去调用对应的RPC服务，之所以被称为会话，是因为一次HTTP请求，</p><img src="/2023/08/10/API%E7%BD%91%E5%85%B3-%E7%BD%91%E5%85%B3%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/image-20230813225359254.png" class="" title="image-20230813225359254"><p>根据这份协议，拿到必要的信息去调用对应的RPC请求。</p><img src="/2023/08/10/API%E7%BD%91%E5%85%B3-%E7%BD%91%E5%85%B3%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/image-20230813225459103.png" class="" title="image-20230813225459103"><p>SessionServer是用来启动Netty服务的，也就是启动Socket的过程</p><p>Netty除了端口需要配置们还需要把对数据的处理一并初始化到Channel管道当中，也就是对应的SessionChannelInitializer的功能</p><p>在 SessionChannelInitializer类当中包装HTTP GET&#x2F;POST协议的解析，要完成网络请求也就是SessionServerHandler的内容</p><h3 id="RPC泛化调用"><a href="#RPC泛化调用" class="headerlink" title="RPC泛化调用"></a>RPC泛化调用</h3><p>为了把 HTTP与 RPC 建立连接，就像你把 DAO 与SQL执行建立连接 样两个服务的中间需要被绑定。也就是把 HTTP 地址中的接口方法与 RPC 对应的服务建立起一种关联关系，这样才能满足在调用 HTTP 网关接口时，调用到对应的 RPC 服务上。</p><img src="/2023/08/10/API%E7%BD%91%E5%85%B3-%E7%BD%91%E5%85%B3%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/image-20230814144555095.png" class="" title="image-20230814144555095"><p>就像如图所示 HTTP 经过网关调用到 RPC 中间的执行逻辑就是把两个模块用绑定的方式建立起连接，生成一个代理对象。代理对象中包装的就是执行网关接口泛化调用的参数准备和执行以及返回结果的操作。<br>这里的第一个知识点是泛化调用，它是 RPC 接口设计中提供的一种反射调用机制，只需要提供接口的方法名称、入参信息，即可调用到对应的 RPC 接口服务。可以参考官网文档: <a href="https://dubbo.apache.org/zh/docs/advanced/generic-reference%E8%BF%99%E9%87%8C%E7%9A%84%E7%AC%AC%E4%BA%8C%E4%B8%AA%E7%9F%A5%E8%AF%86%E7%82%B9%E6%98%AF%E4%BB%A3%E7%90%86%E5%8C%85%E8%A3%85%EF%BC%8C%E8%99%BD%E7%84%B6">https://dubbo.apache.org/zh/docs/advanced/generic-reference这里的第二个知识点是代理包装，虽然</a> RPC 框架提供了泛化调用，也就是说这里可以拿到网络协议转换的 HTTP 请求信息以后，就能直接调用到 RPC 接口。但这样的操作方式不太方便使用，存在硬编码的风险，后续不好迭代升级，也不好扩展其他的接口。因为每一个RPC 的实现，泛化调用的方法名称还是有所不同的，另外是扩展非 RPC 框架的逻辑，也不方便外理。所以这里需要单独提供一个代理包装逻辑这里的第二个知识点是Calib，因为有第二个知识点中代理操作的存在，我们就需要选择一种方式来做代理处理，而Calib 可以满足我们自定义创建接口的方式进行代理，同时又可以在让一个代理类有多个接口。注意:多个接口的意思是，一个接口是用于标准的描述，在于使用上。另外一个接口是自主生成的，生成的是我们的 RPC 描述性接口，相当于自主生成了class字节码。</p><img src="/2023/08/10/API%E7%BD%91%E5%85%B3-%E7%BD%91%E5%85%B3%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/image-20230814225322371.png" class="" title="image-20230814225322371"><h3 id="分治处理会话流程"><a href="#分治处理会话流程" class="headerlink" title="分治处理会话流程"></a>分治处理会话流程</h3><img src="/2023/08/10/API%E7%BD%91%E5%85%B3-%E7%BD%91%E5%85%B3%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/image-20230816111428186.png" class="" title="image-20230816111428186"><h3 id="将连接（RPC-HTTP-其他）抽象为数据源"><a href="#将连接（RPC-HTTP-其他）抽象为数据源" class="headerlink" title="将连接（RPC\HTTP\其他）抽象为数据源"></a>将连接（RPC\HTTP\其他）抽象为数据源</h3><p>进行代码重构： 划分session和socket两大块 把之前NettyServer的部分放到socket部分，把反射调用dubbo的那块留在session部分 更加细化出mapperedMethod，这一块是仿照Mybatis的处理，根据打进来的不同类型 （GET,PUT,POST,DELETE）方法，switch不同的处理方式。后续应该更细化拆分出 Executor。</p><h3 id="HTTP请求参数解析"><a href="#HTTP请求参数解析" class="headerlink" title="HTTP请求参数解析"></a>HTTP请求参数解析</h3><img src="/2023/08/10/API%E7%BD%91%E5%85%B3-%E7%BD%91%E5%85%B3%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/image-20230816144824568.png" class="" title="image-20230816144824568"><img src="/2023/08/10/API%E7%BD%91%E5%85%B3-%E7%BD%91%E5%85%B3%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BC%80%E5%8F%91/image-20230816144845519.png" class="" title="image-20230816144845519">]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> api网关 </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile、线程池和锁</title>
      <link href="/2023/08/03/volatile%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8C%E9%94%81/"/>
      <url>/2023/08/03/volatile%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8C%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h2><h3 id="如何保证变量的可见性？"><a href="#如何保证变量的可见性？" class="headerlink" title="如何保证变量的可见性？"></a>如何保证变量的可见性？</h3><p>在 Java 中，<code>volatile</code> 关键字可以保证变量的可见性，如果我们将变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p><h3 id="如何禁止指令重排序？"><a href="#如何禁止指令重排序？" class="headerlink" title="如何禁止指令重排序？"></a>如何禁止指令重排序？</h3><p><strong>防止 JVM 的指令重排序</strong>，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。</p><p>关键词：内存屏障</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">loadFence</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">storeFence</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">fullFence</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>应用：<strong>双重校验锁实现对象单例（线程安全）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p><ol><li>为 <code>uniqueInstance</code> 分配内存空间</li><li><strong>初始化 <code>uniqueInstance</code></strong></li><li>将 <code>uniqueInstance</code> 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。</p><h3 id="volatile-可以保证原子性么"><a href="#volatile-可以保证原子性么" class="headerlink" title="volatile 可以保证原子性么"></a>volatile 可以保证原子性么</h3><p><strong><code>volatile</code> 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatoleAtomicityDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="type">VolatoleAtomicityDemo</span> <span class="variable">volatoleAtomicityDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatoleAtomicityDemo</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">500</span>; j++) &#123;</span><br><span class="line">                    volatoleAtomicityDemo.increase();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待1.5秒，保证上面程序执行完成</span></span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        System.out.println(inc);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>正常情况下，运行上面的代码理应输出 <code>2500</code>。但你真正运行了上面的代码之后，你会发现每次输出结果都小于 <code>2500</code>。</p><p>为什么会出现这种情况呢？不是说好了，<code>volatile</code> 可以保证变量的可见性嘛！</p><p>也就是说，如果 <code>volatile</code> 能保证 <code>inc++</code> 操作的原子性的话。每个线程中对 <code>inc</code> 变量自增完之后，其他线程可以立即看到修改后的值。5 个线程分别进行了 500 次操作，那么最终 inc 的值应该是 5*500&#x3D;2500。</p><p>很多人会误认为自增操作 <code>inc++</code> 是原子性的，实际上，<code>inc++</code> 其实是一个复合操作，包括三步：</p><ol><li>读取 inc 的值。</li><li>对 inc 加 1。</li><li>将 inc 的值写回内存。</li></ol><p><code>volatile</code> 是无法保证这三个操作是具有原子性的，有可能导致下面这种情况出现：</p><ol><li>线程 1 对 <code>inc</code> 进行读取操作之后，还未对其进行修改。线程 2 又读取了 <code>inc</code>的值并对其进行修改（+1），再将<code>inc</code> 的值写回内存。</li><li>线程 2 操作完毕后，线程 1 对 <code>inc</code>的值进行修改（+1），再将<code>inc</code> 的值写回内存。</li></ol><p>这也就导致两个线程分别对 <code>inc</code> 进行了一次自增操作后，<code>inc</code> 实际上只增加了 1。</p><p>其实，如果想要保证上面的代码运行正确也非常简单，利用 <code>synchronized</code>、<code>Lock</code>或者<code>AtomicInteger</code>都可以。</p><p>1.使用 <code>AtomicInteger</code> 加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatoleAtomicityDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="type">VolatoleAtomicityDemo</span> <span class="variable">volatoleAtomicityDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatoleAtomicityDemo</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">500</span>; j++) &#123;</span><br><span class="line">                    volatoleAtomicityDemo.increase();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待1.5秒，保证上面程序执行完成</span></span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        System.out.println(inc);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.使用 <code>AtomicInteger</code> 改进：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatoleAtomicityDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        inc.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="type">VolatoleAtomicityDemo</span> <span class="variable">volatoleAtomicityDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatoleAtomicityDemo</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">500</span>; j++) &#123;</span><br><span class="line">                    volatoleAtomicityDemo.increase();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待1.5秒，保证上面程序执行完成</span></span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        System.out.println(inc);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li><p>使用 <code>ReentrantLock</code> 改进：</p><p>lock上锁之后，必须unlock</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatoleAtomicityDemo</span> &#123;</span><br><span class="line"><span class="comment">//    public static AtomicInteger inc = new AtomicInteger();</span></span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        inc++;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="type">VolatoleAtomicityDemo</span> <span class="variable">volatoleAtomicityDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatoleAtomicityDemo</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">500</span>; j++) &#123;</span><br><span class="line">                    volatoleAtomicityDemo.increase();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待1.5秒，保证上面程序执行完成</span></span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        System.out.println(inc);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="#什么是线程池?"></a><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0">#</a>什么是线程池?</h3><p>顾名思义，线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p><h3 id="为什么要用线程池？"><a href="#为什么要用线程池？" class="headerlink" title="为什么要用线程池？"></a>为什么要用线程池？</h3><p>池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p><p><strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）的方式。 每个<strong>线程池</strong>还维护一些基本统计信息，例如已完成任务的数量。</p><p>这里借用《Java 并发编程的艺术》提到的来说一下<strong>使用线程池的好处</strong>：</p><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li></ul><h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><h3 id="什么是悲观锁？"><a href="#什么是悲观锁？" class="headerlink" title="什么是悲观锁？"></a>什么是悲观锁？</h3><p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>。</p><p>像 Java 中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performSynchronisedTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 需要同步的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// 需要同步的操作</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。</p><h3 id="什么是乐观锁？"><a href="#什么是乐观锁？" class="headerlink" title="什么是乐观锁？"></a>什么是乐观锁？</h3><p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。</p><p>在 Java 中<code>java.util.concurrent.atomic</code>包下面的原子变量类（比如<code>AtomicInteger</code>、<code>LongAdder</code>）就是使用了乐观锁的一种实现方式 <strong>CAS</strong> 实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LongAdder 在高并发场景下会比 AtomicInteger 和 AtomicLong 的性能更好</span></span><br><span class="line"><span class="comment">// 代价就是会消耗更多的内存空间（空间换时间）</span></span><br><span class="line"><span class="type">LongAdder</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAdder</span>();</span><br><span class="line">sum.increment();</span><br></pre></td></tr></table></figure><p>高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。</p><p>不过，大量失败重试的问题也是可以解决的，像我们前面提到的 <code>LongAdder</code>以空间换时间的方式就解决了这个问题。</p><p>理论上来说：</p><ul><li>悲观锁通常<strong>多用于写比较多的情况下（多写场景，竞争激烈</strong>），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如<code>LongAdder</code>），也是可以考虑使用乐观锁的，要视实际情况而定。</li><li>乐观锁通常多于<strong>写比较少的情况下（多读场景，竞争较少</strong>），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考<code>java.util.concurrent.atomic</code>包下面的原子变量类）。</li></ul><h3 id="如何实现乐观锁？"><a href="#如何实现乐观锁？" class="headerlink" title="如何实现乐观锁？"></a>如何实现乐观锁？</h3><p>乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些，这里需要格外注意。</p><h4 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h4><p>一般是在数据表中加上一个数据版本号 <code>version</code> 字段，表示数据被修改的次数。当数据被修改时，<code>version</code> 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 <code>version</code> 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 <code>version</code> 值相等时才更新，否则重试更新操作，直到更新成功。</p><h4 id="CAS-算法"><a href="#CAS-算法" class="headerlink" title="CAS 算法"></a>CAS 算法</h4><p>CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。</p><blockquote><p><strong>原子操作</strong> 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。</p></blockquote><p>CAS 涉及到三个操作数：</p><ul><li><strong>V</strong>：要更新的变量值(Var)</li><li><strong>E</strong>：预期值(Expected)</li><li><strong>N</strong>：拟写入的新值(New)</li></ul><p>当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。</p><p><strong>举一个简单的例子</strong>：线程 A 要修改变量 i 的值为 6，i 原值为 1（V &#x3D; 1，E&#x3D;1，N&#x3D;6，假设不存在 ABA 问题）。</p><ol><li>i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。</li><li>i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。</li></ol><p>当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</p><p>Java 语言并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的（JNI 调用）。因此， CAS 的具体实现和操作系统以及 CPU 都有关系。</p><p><code>sun.misc</code>包下的<code>Unsafe</code>类提供了<code>compareAndSwapObject</code>、<code>compareAndSwapInt</code>、<code>compareAndSwapLong</code>方法来实现的对<code>Object</code>、<code>int</code>、<code>long</code>类型的 CAS 操作</p><h3 id="乐观锁存在哪些问题？"><a href="#乐观锁存在哪些问题？" class="headerlink" title="乐观锁存在哪些问题？"></a>乐观锁存在哪些问题？</h3><p>ABA 问题是乐观锁最常见的问题。</p><h4 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h4><p>如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 <strong>“ABA”问题。</strong></p><p>ABA 问题的解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。JDK 1.5 以后的 <code>AtomicStampedReference</code> 类就是用来解决 ABA 问题的，其中的 <code>compareAndSet()</code> 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><h4 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h4><p>CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。</p><p>如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用：</p><ol><li>可以延迟流水线执行指令，使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。</li><li>可以避免在退出循环的时候因内存顺序冲而引起 CPU 流水线被清空，从而提高 CPU 的执行效率</li></ol><h2 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h2><h3 id="synchronized-是什么？有什么"><a href="#synchronized-是什么？有什么" class="headerlink" title="#synchronized 是什么？有什么"></a><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#synchronized-%E6%98%AF%E4%BB%80%E4%B9%88-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8">#</a>synchronized 是什么？有什么</h3><p>在 Java 早期版本中，<code>synchronized</code> 属于 <strong>重量级锁</strong>，效率低下。这是因为监视器锁（monitor）是依赖于底层的操作系统的 <code>Mutex Lock</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p><p>不过，在 Java 6 之后， <code>synchronized</code> 引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让 <code>synchronized</code> 锁的效率提升了很多。因此， <code>synchronized</code> 还是可以在实际项目中使用的，像 JDK 源码、很多开源框架都大量使用了 <code>synchronized</code> </p><h3 id="如何使用-synchronized？"><a href="#如何使用-synchronized？" class="headerlink" title="如何使用 synchronized？"></a>如何使用 synchronized？</h3><p><code>synchronized</code> 关键字的使用方式主要有下面 3 种：</p><ol><li>修饰实例方法</li><li>修饰静态方法</li><li>修饰代码块</li></ol><p><strong>1、修饰实例方法</strong> （锁当前对象实例）</p><p>给当前对象实例加锁，进入同步代码前要获得 <strong>当前对象实例的锁</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、修饰静态方法</strong> （锁当前类）</p><p>给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 <strong>当前 class 的锁</strong>。</p><p>这是因为静态成员不属于任何一个实例对象，归整个类所有，不依赖于类的特定实例，被类的所有实例共享。</p>]]></content>
      
      
      <categories>
          
          <category> 编程基本功 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sanfor实习工作记录-6、7月</title>
      <link href="/2023/07/20/Sanfor%E5%AE%9E%E4%B9%A0%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95-6%E3%80%817%E6%9C%88/"/>
      <url>/2023/07/20/Sanfor%E5%AE%9E%E4%B9%A0%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95-6%E3%80%817%E6%9C%88/</url>
      
        <content type="html"><![CDATA[<h2 id="6月12"><a href="#6月12" class="headerlink" title="6月12"></a>6月12</h2><p>工作内容：熟悉hydra项目代码。</p><p>遇到的问题：代码在本机环境运行不起来，需要在linux的gcc环境进行编译。</p><p>疑惑：正常的开发流程的环境是远程连接虚拟机的环境进行开发的吗，那是怎么debug的？之前自己做小项目都是本地开发完再部署环境。</p><p>收获：postman简单在学习了一下，了解了全局变量和后置引言。</p><hr><h2 id="6月13"><a href="#6月13" class="headerlink" title="6月13"></a>6月13</h2><p>工作内容：postman接口测试，更新API文档。</p><p>遇到的问题：mango的db_name和coll_name信息不清楚。（已解决）</p><hr><h2 id="6月14"><a href="#6月14" class="headerlink" title="6月14"></a>6月14</h2><p>工作内容：  使用helm下载，nebula-operator。</p><p>遇到的问题：coredns重复安装，导致服务域名无法解析。（已解决）</p><p>收获：恶补了计网的知识，DNS-应用层-解析域名、TCP和HTTP。</p><p>托管云全链路-离线及线上环境Nebula Graph集群部署文档</p><hr><h2 id="6月15"><a href="#6月15" class="headerlink" title="6月15"></a>6月15</h2><p>工作内容：使用nebula-operator部署nebula集群。</p><p>  尝试解决办法1:将3个组件包括metad和graphd设置为3结果还是无法解决。<img src="/2023/07/20/Sanfor%E5%AE%9E%E4%B9%A0%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95-6%E3%80%817%E6%9C%88/image-20230802141612333.png" class="" title="image-20230802141612333"></p><p>尝试解决办法2：看到这篇博客nebula-operator安装部署的集群使用java-client数据写入一段时间就挂掉 - 提问题·用户问答 &#x2F; 使用问题 - NebulaGraph 社区 (nebula-graph.com.cn)，扩大容器的cpu和存储为原来的两倍结果仍然不行。</p><img src="/2023/07/20/Sanfor%E5%AE%9E%E4%B9%A0%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95-6%E3%80%817%E6%9C%88/image-20230802141632865.png" class="" title="image-20230802141632865"><p>目前做法：把各个组件的replicas设置为1了。</p><p>收获：k8s需要了解的概念很多，大概了解了kubectl常见的命令，里面很多yaml文件的配置，不了解每个配置项的很容易出问题。</p><hr><h2 id="6月16"><a href="#6月16" class="headerlink" title="6月16"></a>6月16</h2><p>工作内容：Nebula Console还要配置go的环境所以使用NebulaGraph Studio可视化工具，在nebula起pod，连接 Nebula Graph 集群。</p><p>遇到的问题：</p><p>参考:连接 Nebula Graph 数据库 - Nebula Graph Database 手册 (nebula-graph.com.cn)</p><p>第一步填充 deployment&#x2F;helm&#x2F;values.yaml 下的 persistent.storageClassName，如果没有 PV 需要提前创建。</p><p>第二步Studio安装位置：&#x2F;root&#x2F;tanzu&#x2F;nebula-studio-3.4.2&#x2F;</p><p>第三步 使用helm进行安装。</p><p>问题 ：studio连接不上数据库,请求错误: 500 Internal Server Error（已解决）</p><p>Graph集群向外暴露的端口</p><img src="/2023/07/20/Sanfor%E5%AE%9E%E4%B9%A0%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95-6%E3%80%817%E6%9C%88/image-20230802161114995.png" class="" title="image-20230802161114995"><p>输入信息后进行连接，连接不上。</p><img src="/2023/07/20/Sanfor%E5%AE%9E%E4%B9%A0%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95-6%E3%80%817%E6%9C%88/image-20230802161156167.png" class="" title="image-20230802161156167"><p>pod的日志信息（看不出来什么问题）</p><img src="/2023/07/20/Sanfor%E5%AE%9E%E4%B9%A0%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95-6%E3%80%817%E6%9C%88/image-20230802161214693.png" class="" title="image-20230802161214693"><p>kubectl exec -it podname – sh</p><img src="/2023/07/20/Sanfor%E5%AE%9E%E4%B9%A0%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95-6%E3%80%817%E6%9C%88/image-20230802161247575.png" class="" title="image-20230802161247575"><p>重新启动studio的pod解决问题:</p><img src="/2023/07/20/Sanfor%E5%AE%9E%E4%B9%A0%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95-6%E3%80%817%E6%9C%88/image-20230802161303402.png" class="" title="image-20230802161303402"><hr><h2 id="6月19日"><a href="#6月19日" class="headerlink" title="6月19日"></a>6月19日</h2><p>工作内容：使用kubectl 部署三个nebula节点</p><p>Argo CD 入门教程 – 云原生实验室 - Kubernetes（<a href="https://icloudnative.io/posts/getting-started-with-argocd/%EF%BC%89%E9%97%AE%E9%A2%98%EF%BC%9A%E5%B0%86replicas%E8%AE%BE%E7%BD%AE%E4%B8%BA3%EF%BC%8C%E6%9C%89pod%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8">https://icloudnative.io/posts/getting-started-with-argocd/）问题：将replicas设置为3，有pod无法启动</a></p><img src="/2023/07/20/Sanfor%E5%AE%9E%E4%B9%A0%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95-6%E3%80%817%E6%9C%88/image-20230802142122797.png" class="" title="image-20230802142122797"><p>在各个节点的运行状况：</p><img src="/2023/07/20/Sanfor%E5%AE%9E%E4%B9%A0%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95-6%E3%80%817%E6%9C%88/image-20230802142153198.png" class="" title="image-20230802142153198"><p>查看退出状态码为139：</p><img src="/2023/07/20/Sanfor%E5%AE%9E%E4%B9%A0%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95-6%E3%80%817%E6%9C%88/image-20230802142231151.png" class="" title="image-20230802142231151"><hr><h2 id="6月20日"><a href="#6月20日" class="headerlink" title="6月20日"></a>6月20日</h2><p>工作内容：调研部署3个节点出现的pod状态异常的bug。</p><p>集群yaml文件目录：&#x2F;root&#x2F;gandalf&#x2F;apps_v1alpha1_nebulacluster.yaml</p><p>当一个 pod 的退出状态码为 139 时，通常表示该 pod 是由于收到了 SIGSEGV 信号而崩溃的。SIGSEGV 信号通常是由于访问了无效的内存地址或者试图执行未授权的操作而引起的。</p><p>一文详解云上自动化部署集群管理工具 Nebula Operator (nebula-graph.com.cn)</p><p>GitHub - vesoft-inc&#x2F;nebula-operator: Operation utilities for Nebula Graph</p><p>github文档里nebula镜像的版本为3.1.0，修改镜像版本<img src="/2023/07/20/Sanfor%E5%AE%9E%E4%B9%A0%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95-6%E3%80%817%E6%9C%88/image-20230802142407981.png" class="" title="image-20230802142407981"></p><hr><h2 id="6月21日"><a href="#6月21日" class="headerlink" title="6月21日"></a>6月21日</h2><p>工作内容：继续查阅资料解决pod CrashLoopBackOff的解决办法。</p><p><a href="https://juejin.cn/post/6997662552880611341%E5%86%8D%E6%AC%A1%E6%8E%92%E6%9F%A5operator%E5%AE%89%E8%A3%85%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE%EF%BC%9A%E5%89%8D%E7%BD%AE%E4%BE%9D%E8%B5%96%E6%B2%A1%E6%9C%89%E9%97%AE%E9%A2%98">https://juejin.cn/post/6997662552880611341再次排查operator安装是否正确：前置依赖没有问题</a><img src="/2023/07/20/Sanfor%E5%AE%9E%E4%B9%A0%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95-6%E3%80%817%E6%9C%88/image-20230802142456467.png" class="" title="image-20230802142456467"></p><p>同样有问题<img src="/2023/07/20/Sanfor%E5%AE%9E%E4%B9%A0%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95-6%E3%80%817%E6%9C%88/image-20230802142512846.png" class="" title="image-20230802142512846"></p><hr><h2 id="6月25日"><a href="#6月25日" class="headerlink" title="6月25日"></a>6月25日</h2><p>继续解决bug</p><p>  <a href="https://discuss.nebula-graph.com.cn/t/topic/2660">https://discuss.nebula-graph.com.cn/t/topic/2660</a></p><hr><h2 id="6月27日"><a href="#6月27日" class="headerlink" title="6月27日"></a>6月27日</h2><p>继续解决bug</p><p>学习k8s的satatefulset configmap &amp; secret ingress的相关概念</p><p>简单操作了解nebula的图数据库的基本语法分布式图数据库 NebulaGraph 的 Index 实践 (nebula-graph.com.cn)下面是nebula的社区，star很多，很活跃。</p><p>‘crashLoopBackOff’ 的搜索结果 - NebulaGraph 社区 (nebula-graph.com.cn)<br/>在nebula社区做的提问。</p><p>k8s使用nebula operator离线安装nebula graph集群时，storaged和metad两个组件创建多个副本之后，pod会一直出现crashLoopBackOff情况，pod退出状态码为139。 - 提问题·用户问答 &#x2F; 使用问题 - NebulaGraph 社区 (nebula-graph.com.cn)</p><hr><h2 id="6月28日"><a href="#6月28日" class="headerlink" title="6月28日"></a>6月28日</h2><p>  等待社区回复，完善简历微服务项目，用jmeter对读写分离后的redis做压力测试，学习慢sql优化准备添加到项目当中。</p><hr><h2 id="6月29日"><a href="#6月29日" class="headerlink" title="6月29日"></a>6月29日</h2><p>工作内容：解决了bug，问题是nfs重复，以后创建集群的时候，先创建pvc，k8s是会驱动去创建pv的。</p><p>总算解决掉实习项目的bug了，k8s学了很多，其实和springcloud很像的还是，只不过容器层面确实觉得k8s很方便，后面打算将自己的小项目用k8s来管理，试着自己部署一下（未完成）。</p><p>图数据库学习路径 - siwei.io<br/></p><p>创建完pvc，再去创建集群。<br/></p><p>pvc的模板代码：<br/></p><p>apiVersion: v1<br/>kind: PersistentVolumeClaim<br/>metadata:<br/>name: pvc-08<br/>namespace: nebula<br/>spec:<br/>storageClassName: nfs-client<br/>accessModes:<br/>- ReadWriteMany<br/>resources:<br/>requests:<br/>storage: 4Gi<br/></p><p>apps_v1alpha1_nebulacluster.yaml</p><p>模板代码：<br/></p><p>apiVersion: apps.nebula-graph.io&#x2F;v1alpha1<br/>kind: NebulaCluster<br/>metadata:<br/>name: nebula<br/>namespace: nebula<br/>spec:<br/>graphd:<br/>resources:<br/>requests:<br/>cpu: “500m”<br/>memory: “500Mi”<br/>limits:<br/>cpu: “1”<br/>memory: “4Gi”<br/>replicas: 1<br/>image: vesoft&#x2F;nebula-graphd<br/>version: v3.2.1<br/>service:<br/>type: NodePort<br/>externalTrafficPolicy: Local<br/>logVolumeClaim:<br/>resources:<br/>requests:<br/>storage: 2Gi<br/>storageClassName: nfs-client<br/>metad:<br/>resources:<br/>requests:<br/>cpu: “500m”<br/>memory: “500Mi”<br/>limits:<br/>cpu: “1”<br/>memory: “4Gi”<br/>replicas: 1<br/>image: vesoft&#x2F;nebula-metad<br/>version: v3.2.1<br/>dataVolumeClaim:<br/>resources:<br/>requests:<br/>storage: 2Gi<br/>storageClassName: nfs-client<br/>logVolumeClaim:<br/>resources:<br/>requests:<br/>storage: 2Gi<br/>storageClassName: nfs-client<br/>storaged:<br/>resources:<br/>requests:<br/>cpu: “500m”<br/>memory: “500Mi”<br/>limits:<br/>cpu: “1”<br/>memory: “4Gi”<br/>replicas: 3<br/>image: vesoft&#x2F;nebula-storaged<br/>version: v3.2.1<br/>dataVolumeClaim:<br/>resources:<br/>requests:<br/>storage: 2Gi<br/>storageClassName: nfs-client<br/>logVolumeClaim:<br/>resources:<br/>requests:<br/>storage: 2Gi<br/>storageClassName: nfs-client<br/>reference:<br/>name: statefulsets.apps<br/>version: v1<br/>schedulerName: default-scheduler<br/>imagePullPolicy: Always</p><hr><h2 id="7月3"><a href="#7月3" class="headerlink" title="7月3"></a>7月3</h2><p>工作内容：熟悉ArgoCD配置流程，分析如何编写脚本部署到argocd上。</p><p>Argo CD 入门教程 – 云原生实验室 - Kubernetes <a href="https://www.bilibili.com/video/BV1uk4y1H7xs/?p=5&spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=b16bc6370b4580d541ef490d09f1b6aa">https://www.bilibili.com/video/BV1uk4y1H7xs/?p=5&amp;spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=b16bc6370b4580d541ef490d09f1b6aa</a> </p><p>新版 helm 模板编写指南 个人理解：先得将部署脚本提交到某个分支，或者直接写脚本生成nebula的helm chat的镜像，再在Argo当中配置helm chat的信息部署集群到某个k8s集群当中，问题首先是如何配置helm chat的镜像。</p><hr><h2 id="7月4"><a href="#7月4" class="headerlink" title="7月4"></a>7月4</h2><p>工作内容：了解helm chart制作流程。</p><p>自己的项目：nacos config读取不到nacos的配置信息。（已经解决）<br/>组件版本问题：<br/><dependency><br/><groupId>org.springframework.cloud</groupId><br/><artifactId>spring-cloud-starter-bootstrap</artifactId><br/><version>3.0.3</version><br/></dependency>整体流程<br/>CICD流程主要由千流平台+argocd协作完成；整体实现逻辑如下：<br/>1、用户提交代码到git仓库<br/>2、【千流平台】监听git仓库变更，触发ci流程（需要配置）<br/>3、【千流平台】上传helm包到制品库（需要实现）<br/>4、【argocd】监听helm制品库（需要配置）<br/>5、【argocd】自动触发部署k8s<br/>大概原理<br/>1、【argocd】监听制品库中helm的变更，发生变更能够自动根据helm部署到k8s<br/>2、所以【流水线】需要实现变更helm配置，并发布到制品库；（helm的变更主要是：docker镜像版本的变更）<br/>3、所以【流水线】还需要实现docker镜像的构建，并针对每次构建产生不同版本的docker镜像<br/>资源：<br/><a href="https://10.109.66.164:31080/">https://10.109.66.164:31080/</a>   UGJ4mk1Hp3xSsftv<br/><a href="http://10.65.232.14/index.php/category/rongqijishu/">http://10.65.232.14/index.php/category/rongqijishu/</a>  <br/>Helm Chart编写流程：</p><hr><h2 id="7月5"><a href="#7月5" class="headerlink" title="7月5"></a>7月5</h2><p>工作内容：继续了解helm chart的配置文件信息。</p><p>在 K8S 上使用 NFS 作为存储后端 <a href="http://10.65.232.14/index.php/2021/10/14/12878/">http://10.65.232.14/index.php/2021/10/14/12878/</a></p><hr><h2 id="7月6"><a href="#7月6" class="headerlink" title="7月6"></a>7月6</h2><p>  继续了解helm chart的配置文件信息。</p><p>主要就是deployment和svc的配置，然后value.yaml属于要改的属性文件。<img src="/2023/07/20/Sanfor%E5%AE%9E%E4%B9%A0%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95-6%E3%80%817%E6%9C%88/image-20230802143057336.png" class="" title="image-20230802143057336"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Synced To 1.0.0-feature-add-metrics-20230619-10 (1.0.0-feature-add-metrics-20230619-10)</span><br></pre></td></tr></table></figure><img src="/2023/07/20/Sanfor%E5%AE%9E%E4%B9%A0%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95-6%E3%80%817%E6%9C%88/image-20230802143115813.png" class="" title="image-20230802143115813"><hr><h2 id="7月7日"><a href="#7月7日" class="headerlink" title="7月7日"></a>7月7日</h2><p>工作内容：继续熟悉helm chart的配置文件信息。</p><hr><h2 id="7月10日"><a href="#7月10日" class="headerlink" title="7月10日"></a>7月10日</h2><p>工作内容：将要配置的信息和资源都整理一下，写个文档。</p><hr><h2 id="7月11日"><a href="#7月11日" class="headerlink" title="7月11日"></a>7月11日</h2><p>尝试一下直接使用nebula官网的helm chart是否可以配置集群。</p><p>sentinel的流量控制和熔断降级，以及和openFeign的整合已经成功。<br/>seata分布式事务在学还没学完……<br/>3.0.2 启动参数 - 千流知识库 - Sangfor文档管理</p><hr><h2 id="7月12日"><a href="#7月12日" class="headerlink" title="7月12日"></a>7月12日</h2><p>系统的学习一下helm</p><p>Seata-AT模式</p><p><a href="https://www.bilibili.com/video/BV12D4y1Y7Z7/?spm_id_from=333.337.search-card.all.click&vd_source=b16bc6370b4580d541ef490d09f1b6aa">https://www.bilibili.com/video/BV12D4y1Y7Z7/?spm_id_from=333.337.search-card.all.click&amp;vd_source=b16bc6370b4580d541ef490d09f1b6aa</a></p><hr><h2 id="7月13-7月20日"><a href="#7月13-7月20日" class="headerlink" title="7月13-7月20日"></a>7月13-7月20日</h2><p>系统的学习了一下k8s，将项目进行完善（在sso微信扫码登陆的基础上完善了qq扫码登陆的功能，shardingJDBC完善了一主二从的数据库搭建结构）</p><p>编写helm chart将项目进行完善</p>]]></content>
      
      
      <categories>
          
          <category> Sanfor实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> helm </tag>
            
            <tag> K8S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EventLoop、任务调度、Future和Promise</title>
      <link href="/2023/05/09/EventLoop%E3%80%81%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E3%80%81Future%E5%92%8CPromise/"/>
      <url>/2023/05/09/EventLoop%E3%80%81%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E3%80%81Future%E5%92%8CPromise/</url>
      
        <content type="html"><![CDATA[<h2 id="EventLoop事情循环器"><a href="#EventLoop事情循环器" class="headerlink" title="EventLoop事情循环器"></a>EventLoop事情循环器</h2><ol><li>单线程执行器</li><li>处理 Channel 上源源不断的 io 事件：Channel 上通过selector去监听accept（建立连接）、read（读）、write（可写）等事件，通过EventLoop去处理这些事件</li></ol><p>我们上面使用的就是EventLoopGroup，包含很多个EventLoop，我们每创建一个连接，就需要绑定到一个EventLoop上，之后EventLoop就会开始监听这个连接（只要连接不关闭，一直都是这个EventLoop负责此Channel），而一个EventLoop可以同时监听很多个Channel，实际上就是我们之前学习的Selector罢了。</p><p>当然，EventLoop并不只是用于网络操作的，我们前面所说的EventLoop其实都是NioEventLoop，它是专用于网络通信的，除了网络通信之外，我们也可以使用普通的EventLoop来处理一些其他的事件。</p><p>这样会卡住：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(), workerGroup = <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);  <span class="comment">//线程数先限制一下</span></span><br><span class="line">    <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">    bootstrap</span><br><span class="line">            .group(bossGroup, workerGroup)   <span class="comment">//指定事件循环组</span></span><br><span class="line">            .channel(NioServerSocketChannel.class)   <span class="comment">//指定为NIO的ServerSocketChannel</span></span><br><span class="line">            .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;   <span class="comment">//注意，这里的SocketChannel不是我们NIO里面的，是Netty的</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel channel)</span> &#123;</span><br><span class="line">                    channel.pipeline()</span><br><span class="line">                            .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                                    System.out.println(<span class="string">&quot;接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                                    Thread.sleep(<span class="number">10000</span>);   <span class="comment">//这里我们直接卡10秒假装在处理任务</span></span><br><span class="line">                                    ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以创建一个普通的EventLoop来处理专门读写之外的任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(), workerGroup = <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);  <span class="comment">//线程数先限制一下</span></span><br><span class="line">    <span class="type">EventLoopGroup</span> <span class="variable">handlerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoopGroup</span>();  <span class="comment">//使用DefaultEventLoop来处理其他任务</span></span><br><span class="line">    <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">    bootstrap</span><br><span class="line">            .group(bossGroup, workerGroup)</span><br><span class="line">            .channel(NioServerSocketChannel.class)</span><br><span class="line">            .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel channel)</span> &#123;</span><br><span class="line">                    channel.pipeline()</span><br><span class="line">                            .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                                      System.out.println(<span class="string">&quot;接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                                    handlerGroup.submit(() -&gt; &#123;   </span><br><span class="line">                                <span class="comment">//由于继承自ScheduledExecutorService，我们直接提交任务就行了，是不是感觉贼方便</span></span><br><span class="line">                                        <span class="keyword">try</span> &#123;</span><br><span class="line">                                            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">                                    &#125;);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以创建一条流水线：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(), workerGroup = <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);  <span class="comment">//线程数先限制一下</span></span><br><span class="line">    <span class="type">EventLoopGroup</span> <span class="variable">handlerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoopGroup</span>();  <span class="comment">//使用DefaultEventLoop来处理其他任务</span></span><br><span class="line">    <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">    bootstrap</span><br><span class="line">            .group(bossGroup, workerGroup)</span><br><span class="line">            .channel(NioServerSocketChannel.class)</span><br><span class="line">            .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel channel)</span> &#123;</span><br><span class="line">                    channel.pipeline()</span><br><span class="line">                            .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                                    System.out.println(<span class="string">&quot;接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                                    ctx.fireChannelRead(msg);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;).addLast(handlerGroup, <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;  <span class="comment">//在添加时，可以直接指定使用哪个EventLoopGroup</span></span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                    <span class="keyword">try</span> &#123;</span><br><span class="line">                                        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Future和Promise"><a href="#Future和Promise" class="headerlink" title="Future和Promise"></a>Future和Promise</h2><p>我们接着来看ChannelFuture，前面我们提到，Netty中Channel的相关操作都是异步进行的，并不是在当前线程同步执行，我们不能立即得到执行结果，如果需要得到结果，那么我们就必须要利用到Future。</p><p>我们先来看看ChannelFutuer接口怎么定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChannelFuture</span> <span class="keyword">extends</span> <span class="title class_">Future</span>&lt;Void&gt; &#123;</span><br><span class="line">    Channel <span class="title function_">channel</span><span class="params">()</span>;    <span class="comment">//我们可以直接获取此任务的Channel</span></span><br><span class="line">    ChannelFuture <span class="title function_">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> Void&gt;&gt; var1)</span>;  <span class="comment">//当任务完成时，会直接执行GenericFutureListener的任务，注意执行的位置也是在EventLoop中</span></span><br><span class="line">    ChannelFuture <span class="title function_">addListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> Void&gt;&gt;... var1)</span>;</span><br><span class="line">    ChannelFuture <span class="title function_">removeListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> Void&gt;&gt; var1)</span>;</span><br><span class="line">    ChannelFuture <span class="title function_">removeListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> Void&gt;&gt;... var1)</span>;</span><br><span class="line">    ChannelFuture <span class="title function_">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;   <span class="comment">//在当前线程同步等待异步任务完成，任务失败会抛出异常</span></span><br><span class="line">    ChannelFuture <span class="title function_">syncUninterruptibly</span><span class="params">()</span>;   <span class="comment">//同上，但是无法响应中断</span></span><br><span class="line">    ChannelFuture <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;  <span class="comment">//同上，但是任务中断不会抛出异常，需要手动判断</span></span><br><span class="line">    ChannelFuture <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;  </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isVoid</span><span class="params">()</span>;   <span class="comment">//返回类型是否为void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是两种解决办法</span></span><br><span class="line">future.sync();  </span><br><span class="line"> <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">        <span class="comment">//直接添加监听器，当任务完成时自动执行，但是注意执行也是异步的，不是在当前线程</span></span><br><span class="line">    future.addListener(f -&gt; System.out.println(<span class="string">&quot;我是服务端启动完成之后要做的事情！&quot;</span>));</span><br></pre></td></tr></table></figure><p>Promise接口，它支持手动设定成功和失败的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此接口也是继承自Netty中的Future接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Promise</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">setSuccess</span><span class="params">(V var1)</span>;    <span class="comment">//手动设定成功</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">trySuccess</span><span class="params">(V var1)</span>;</span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">setFailure</span><span class="params">(Throwable var1)</span>;  <span class="comment">//手动设定失败</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryFailure</span><span class="params">(Throwable var1)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">setUncancellable</span><span class="params">()</span>;</span><br><span class="line">        <span class="comment">//这些就和之前的Future是一样的了</span></span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> V&gt;&gt; var1)</span>;</span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">addListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> V&gt;&gt;... var1)</span>;</span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">removeListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> V&gt;&gt; var1)</span>;</span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">removeListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="built_in">super</span> V&gt;&gt;... var1)</span>;</span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    Promise&lt;V&gt; <span class="title function_">syncUninterruptibly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程基本功 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netty编码器、解码器、HTTP通信</title>
      <link href="/2023/05/08/netty%E7%BC%96%E7%A0%81%E5%99%A8%E3%80%81%E8%A7%A3%E7%A0%81%E5%99%A8%E3%80%81HTTP%E9%80%9A%E4%BF%A1/"/>
      <url>/2023/05/08/netty%E7%BC%96%E7%A0%81%E5%99%A8%E3%80%81%E8%A7%A3%E7%A0%81%E5%99%A8%E3%80%81HTTP%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="Netty编码器、解码器"><a href="#Netty编码器、解码器" class="headerlink" title="Netty编码器、解码器"></a>Netty编码器、解码器</h2><p>在网络传输的过程中，数据都是以字节流的方式进行传递。客户端在向服务端发送数据的时候，将业务中其他类型数据转化为字节，叫编码。服务端接收到数据为字节流，将字节流转化为原来的格式，叫解码。统称codec。</p><p>编解码器分为两部分-编码器和解码器，编码器负责出站，解码器负责入站。</p><p>在前面的学习中，我们的数据发送和接收都是需要以ByteBuf形式传输，但是这样是不是有点太不方便了，咱们能不能参考一下JavaWeb那种搞个Filter，在我们开始处理数据之前，过过滤一次，并在过滤的途中将数据转换成我们想要的类型，也可以将发出的数据进行转换，这就要用到编码解码器了。</p><p>我们先来看看最简的，字符串，如果我们要直接在客户端或是服务端处理字符串，可以直接添加一个字符串解码器到我们的流水线中：</p><p> 使用了编码器解码器的客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.wsy.encoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">        bootstrap</span><br><span class="line">                .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        channel.pipeline()</span><br><span class="line">                                .addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>())  <span class="comment">//解码器安排</span></span><br><span class="line">                                .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                        System.out.println(<span class="string">&quot;&gt;&gt; 接收到客户端发送的数据：&quot;</span> + msg);  <span class="comment">//直接接收字符串</span></span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;)</span><br><span class="line">                                .addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());  <span class="comment">//编码器安排</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).channel();</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in))&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;&lt;&lt; 请输入要发送给服务端的内容：&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                <span class="keyword">if</span>(text.isEmpty()) <span class="keyword">continue</span>;</span><br><span class="line">                channel.writeAndFlush(text);  <span class="comment">//直接发送字符串就行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用了编码器解码器的服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.wsy.encoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyEncoder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(), workerGroup = <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);  <span class="comment">//线程数先限制一下</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">handlerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoopGroup</span>();  <span class="comment">//使用DefaultEventLoop来处理其他任务</span></span><br><span class="line">        <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">        bootstrap</span><br><span class="line">                .group(bossGroup, workerGroup)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel channel)</span> &#123;</span><br><span class="line">                        channel.pipeline()</span><br><span class="line">                                <span class="comment">//解码器本质上也算是一种ChannelInboundHandlerAdapter，用于处理入站请求</span></span><br><span class="line">                                .addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>())</span><br><span class="line">                                .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                        System.out.println(<span class="string">&quot;收到客户端的数据：&quot;</span>+msg);</span><br><span class="line">                                        ctx.channel().writeAndFlush(<span class="string">&quot;可以，不跟你多BB&quot;</span>);  <span class="comment">//直接发字符串回去</span></span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;)</span><br><span class="line">                                .addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());  <span class="comment">//使用内置的StringEncoder可以直接将出站的字符串数据编码成ByteBuf</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line"><span class="comment">//        future.sync();   //让当前线程同步等待任务完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;服务端启动状态：&quot;</span>+future.isDone());</span><br><span class="line">        System.out.println(<span class="string">&quot;我是服务端启动完成之后要做的事情！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>之前传递的都是这个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unpooled.wrappedBuffer(<span class="string">&quot;已收到！&quot;</span>.getBytes())</span><br></pre></td></tr></table></figure><p>我们在一开始提到的粘包&#x2F;拆包问题，也可以使用一个解码器解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">FixedLengthFrameDecoder</span>(<span class="number">10</span>))  </span><br><span class="line">        <span class="comment">//第一种解决方案，使用定长数据包，每个数据包都要是指定长度</span></span><br><span class="line">              ...</span><br></pre></td></tr></table></figure><p>特定的分隔符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">DelimiterBasedFrameDecoder</span>(<span class="number">1024</span>, Unpooled.wrappedBuffer(<span class="string">&quot;---&quot;</span>.getBytes())))</span><br><span class="line">        <span class="comment">//第二种，就是指定一个特定的分隔符，比如我们这里以感叹号为分隔符</span></span><br><span class="line">              <span class="comment">//在收到分隔符之前的所有数据，都作为同一个数据包的内容</span></span><br></pre></td></tr></table></figure><p>添加固定的长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">channel.pipeline()</span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(<span class="number">1024</span>, <span class="number">0</span>, <span class="number">4</span>))</span><br><span class="line">        <span class="comment">//第三种方案，就是在头部添加长度信息，来确定当前发送的数据包具体长度是多少</span></span><br><span class="line">        <span class="comment">//offset是从哪里开始，length是长度信息占多少字节，这里是从0开始读4个字节表示数据包长度</span></span><br><span class="line">        .addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>())</span><br></pre></td></tr></table></figure><h2 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.wsy.http;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyEncoder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(), workerGroup = <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);  <span class="comment">//线程数先限制一下</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">handlerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoopGroup</span>();  <span class="comment">//使用DefaultEventLoop来处理其他任务</span></span><br><span class="line">        <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">        bootstrap</span><br><span class="line">                .group(bossGroup, workerGroup)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel channel)</span> &#123;</span><br><span class="line">                        channel.pipeline()</span><br><span class="line">                                .addLast(<span class="keyword">new</span> <span class="title class_">HttpRequestDecoder</span>())   <span class="comment">//Http请求解码器</span></span><br><span class="line">                                .addLast(<span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(Integer.MAX_VALUE))  <span class="comment">//搞一个聚合器，将内容聚合为一个FullHttpRequest，参数是最大内容长度</span></span><br><span class="line">                                .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                        <span class="type">FullHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> (FullHttpRequest) msg;</span><br><span class="line">                                        System.out.println(<span class="string">&quot;浏览器请求路径：&quot;</span>+request.uri());  <span class="comment">//直接获取请求相关信息</span></span><br><span class="line">                                        <span class="type">FullHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);</span><br><span class="line">                                        response.content().writeCharSequence(<span class="string">&quot;Hello World!&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">                                        ctx.channel().writeAndFlush(response);</span><br><span class="line">                                        ctx.channel().close();</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;)</span><br><span class="line">                                .addLast(<span class="keyword">new</span> <span class="title class_">HttpResponseEncoder</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line"><span class="comment">//        future.sync();   //让当前线程同步等待任务完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;服务端启动状态：&quot;</span>+future.isDone());</span><br><span class="line">        System.out.println(<span class="string">&quot;我是服务端启动完成之后要做的事情！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://www.bilibili.com/video/BV1ar4y1J7mC?p=29&vd_source=b16bc6370b4580d541ef490d09f1b6aa">Netty：启动流程源码解析_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程基本功 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netty工作模型、Channel剖析</title>
      <link href="/2023/05/08/netty%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%9E%8B%E3%80%81Channel%E5%89%96%E6%9E%90/"/>
      <url>/2023/05/08/netty%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%9E%8B%E3%80%81Channel%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="Netty工作模型"><a href="#Netty工作模型" class="headerlink" title="Netty工作模型"></a>Netty工作模型</h2><p>Netty为我们提供的更高级的缓冲区类，我们接着来看看Netty是如何工作的，上一章我们介绍了Reactor模式，而Netty正是以主从Reactor多线程模型为基础，构建出了一套高效的工作模型。</p><img src="/2023/05/08/netty%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%9E%8B%E3%80%81Channel%E5%89%96%E6%9E%90/image-20230808123236679.png" class="" title="image-20230808123236679"><ul><li>Netty 抽象出两组线程池BossGroup和WorkerGroup，BossGroup专门负责接受客户端的连接, WorkerGroup专门负读写，就像我们前面说的主从Reactor一样。</li><li>无论是BossGroup还是WorkerGroup，都是使用EventLoop（事件循环，很多系统都采用了事件循环机制，比如前端框架Node.js，事件循环顾名思义，就是一个循环，不断地进行事件通知）来进行事件监听的，整个Netty也是使用事件驱动来运作的，比如当客户端已经准备好读写、连接建立时，都会进行事件通知，说白了就像我们之前写NIO多路复用那样，只不过这里换成EventLoop了而已，它已经帮助我们封装好了一些常用操作，而且我们可以自己添加一些额外的任务，如果有多个EventLoop，会存放在EventLoopGroup中，EventLoopGroup就是BossGroup和WorkerGroup的具体实现。</li><li>在BossGroup之后，会正常将SocketChannel绑定到WorkerGroup中的其中一个EventLoop上，进行后续的读写操作监听。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//这里我们使用NioEventLoopGroup实现类即可，创建BossGroup和WorkerGroup</span></span><br><span class="line">    <span class="comment">//当然还有EpollEventLoopGroup，但是仅支持Linux，这是Netty基于Linux底层Epoll单独编写的一套本地实现，没有使用NIO那套</span></span><br><span class="line">    <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(), workerGroup = <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建服务端启动引导类</span></span><br><span class="line">    <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">    <span class="comment">//可链式，就很棒</span></span><br><span class="line">    bootstrap</span><br><span class="line">            .group(bossGroup, workerGroup)   <span class="comment">//指定事件循环组</span></span><br><span class="line">            .channel(NioServerSocketChannel.class)   <span class="comment">//指定为NIO的ServerSocketChannel</span></span><br><span class="line">            .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;   </span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel channel)</span> &#123;</span><br><span class="line">                    <span class="comment">//获取流水线，当我们需要处理客户端的数据时，实际上是像流水线一样在处理，这个流水线上可以有很多Handler</span></span><br><span class="line">                    channel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;   <span class="comment">//添加一个Handler，这里使用ChannelInboundHandlerAdapter</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;  <span class="comment">//ctx是上下文，msg是收到的消息，默认以ByteBuf形式（也可以是其他形式，后面再说）</span></span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;   <span class="comment">//类型转换一下</span></span><br><span class="line">                            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &gt;&gt; 接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                            <span class="comment">//通过上下文可以直接发送数据回去，注意要writeAndFlush才能让客户端立即收到</span></span><br><span class="line">                            ctx.writeAndFlush(Unpooled.wrappedBuffer(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="comment">//最后绑定端口，启动</span></span><br><span class="line">    bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Alt+7查看所有的方法，Crtl+H是查看类的继承关系</p><h3 id="Channel详解"><a href="#Channel详解" class="headerlink" title="Channel详解"></a>Channel详解</h3><p>在学习NIO时，我们就已经接触到Channel了，我们可以通过通道来进行数据的传输，并且通道支持双向传输。</p><p>而在Netty中，也有对应的Channel类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Channel</span> <span class="keyword">extends</span> <span class="title class_">AttributeMap</span>, ChannelOutboundInvoker, Comparable&lt;Channel&gt; &#123;</span><br><span class="line">    ChannelId <span class="title function_">id</span><span class="params">()</span>;   <span class="comment">//通道ID</span></span><br><span class="line">    EventLoop <span class="title function_">eventLoop</span><span class="params">()</span>;   <span class="comment">//获取此通道所属的EventLoop，因为一个Channel在它的生命周期内只能注册到一个EventLoop中</span></span><br><span class="line">    Channel <span class="title function_">parent</span><span class="params">()</span>;   <span class="comment">//Channel是具有层级关系的，这里是返回父Channel</span></span><br><span class="line">    ChannelConfig <span class="title function_">config</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isOpen</span><span class="params">()</span>;   <span class="comment">//通道当前的相关状态</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isRegistered</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isActive</span><span class="params">()</span>;</span><br><span class="line">    ChannelMetadata <span class="title function_">metadata</span><span class="params">()</span>;   <span class="comment">//通道相关信息</span></span><br><span class="line">    SocketAddress <span class="title function_">localAddress</span><span class="params">()</span>; </span><br><span class="line">    SocketAddress <span class="title function_">remoteAddress</span><span class="params">()</span>;</span><br><span class="line">    ChannelFuture <span class="title function_">closeFuture</span><span class="params">()</span>;  <span class="comment">//关闭通道，但是会用到ChannelFuture，后面说</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isWritable</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">bytesBeforeUnwritable</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">bytesBeforeWritable</span><span class="params">()</span>;</span><br><span class="line">    Unsafe <span class="title function_">unsafe</span><span class="params">()</span>;</span><br><span class="line">    ChannelPipeline <span class="title function_">pipeline</span><span class="params">()</span>;   <span class="comment">//流水线，之后也会说</span></span><br><span class="line">    ByteBufAllocator <span class="title function_">alloc</span><span class="params">()</span>;   <span class="comment">//可以直接从Channel拿到ByteBufAllocator的实例，来分配ByteBuf</span></span><br><span class="line">    Channel <span class="title function_">read</span><span class="params">()</span>;</span><br><span class="line">    Channel <span class="title function_">flush</span><span class="params">()</span>;   <span class="comment">//刷新，基操</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，Netty中的Channel相比NIO功能就多得多了。Netty中的Channel主要特点如下：</p><ul><li>所有的IO操作都是异步的，并不是在当前线程同步运行，方法调用之后就直接返回了，那怎么获取操作的结果呢？还记得我们在前面JUC篇教程中学习的Future吗，没错，这里的ChannelFuture也是干这事的。</li></ul><p>我们可以来看一下Channel接口的父接口ChannelOutboundInvoker接口，这里面定义了大量的I&#x2F;O操作</p><p>我们了解了Netty底层的Channel之后，我们接着来看ChannelHandler，既然现在有了通道，那么怎么进行操作呢？我们可以将需要处理的事情放在ChannelHandler中，ChannelHandler充当了所有入站和出站数据的应用程序逻辑的容器，实际上就是我们之前Reactor模式中的Handler，全靠它来处理读写操作。</p><p>不过这里不仅仅是一个简单的ChannelHandler在进行处理，而是一整套流水线，我们之后会介绍ChannelPipeline。</p><p>比如我们上面就是使用了ChannelInboundHandlerAdapter抽象类，它是ChannelInboundHandler接口的实现，用于处理入站数据，可以看到我们实际上就是通过重写对应的方法来进行处理，这些方法会在合适的时间被调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChannelInboundHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelHandler</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">channelRegistered</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">channelUnregistered</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext var1, Object var2)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext var1, Object var2)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext var1)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext var1, Throwable var2)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是ChannelInboundHandlerAdapter这个类调用的，我们新建立一个Test类来继承</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.wsy.nettyChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestChannelHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelRegistered&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelUnregistered&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelActive&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelInactive&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &gt;&gt; 接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">//这次我们就直接使用ctx.alloc()来生成缓冲区</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">back</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">        back.writeCharSequence(<span class="string">&quot;已收到！&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">        ctx.writeAndFlush(back);</span><br><span class="line">        System.out.println(<span class="string">&quot;channelRead&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelReadComplete&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;userEventTriggered&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;channelWritabilityChanged&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;exceptionCaught&quot;</span>+cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>那么再次进入handler中的方法就是我们自定义的这个。</p><p>handler流水线：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.wsy.nettyChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(), workerGroup = <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">        bootstrap</span><br><span class="line">                .group(bossGroup, workerGroup)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                <span class="comment">//ChannelInitializer是一个特殊的ChannelHandler，它本身不处理任何出站/入站事件，它的目的仅仅是完成Channel的初始化</span></span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;   <span class="comment">//注意，这里的SocketChannel不是我们NIO里面的，是Netty的</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel channel)</span> &#123;</span><br><span class="line">                        channel.pipeline()   <span class="comment">//直接获取pipeline，然后添加两个Handler，注意顺序</span></span><br><span class="line">                                .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;   <span class="comment">//第一个用于处理消息接收</span></span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                                        System.out.println(<span class="string">&quot;接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;我是异常&quot;</span>);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;)</span><br><span class="line">                                .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;   <span class="comment">//第二个用于处理异常</span></span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                        System.out.println(<span class="string">&quot;我是异常处理：&quot;</span>+cause);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果将一个消息在两个Handler中进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.wsy.nettyChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyTest03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(), workerGroup = <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">        bootstrap</span><br><span class="line">                .group(bossGroup, workerGroup)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                <span class="comment">//ChannelInitializer是一个特殊的ChannelHandler，它本身不处理任何出站/入站事件，它的目的仅仅是完成Channel的初始化</span></span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel channel)</span> &#123;</span><br><span class="line">                        channel.pipeline()   <span class="comment">//直接获取pipeline，然后添加两个Handler</span></span><br><span class="line">                                .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                                        System.out.println(<span class="string">&quot;1接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                                        ctx.fireChannelRead(msg);   <span class="comment">//通过ChannelHandlerContext</span></span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;)</span><br><span class="line">                                .addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                                        System.out.println(<span class="string">&quot;2接收到客户端发送的数据：&quot;</span>+buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        bootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>出站操作在流水线上是反着来的，整个流水线操作大概流程如下:</p><img src="/2023/05/08/netty%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%9E%8B%E3%80%81Channel%E5%89%96%E6%9E%90/image-20230808151348223.png" class="" title="image-20230808151348223">]]></content>
      
      
      <categories>
          
          <category> 编程基本功 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netty基础入门篇</title>
      <link href="/2023/04/30/netty%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87/"/>
      <url>/2023/04/30/netty%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="再次剖析NIO"><a href="#再次剖析NIO" class="headerlink" title="再次剖析NIO"></a>再次剖析NIO</h2><p>netty为什么快呢？这是因为netty底层使用了JAVA的NIO技术，并在其基础上进行了性能的优化，虽然netty不是单纯的JAVA nio，但是netty的底层还是基于的是nio技术。</p><p>nio是JDK1.4中引入的，用于区别于传统的IO，所以nio也可以称之为new io。</p><p>nio的三大核心是Selector,channel和Buffer，本文我们将会深入探究NIO和netty之间的关系。</p><p>Java NIO则是非阻塞的，每一次数据读写调用都会立即返回，并将目前可读（或可写）的内容写入缓冲区或者从缓冲区中输出，即使当前没有可用数据，调用仍然会立即返回并且不对缓冲区做任何操作</p><img src="/2023/04/30/netty%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87/image-20230806204012728.png" class="" title="image-20230806204012728"><h2 id="NIO框架存在的问题"><a href="#NIO框架存在的问题" class="headerlink" title="NIO框架存在的问题"></a>NIO框架存在的问题</h2><p>但是之前我们在使用NIO框架的时候，还是发现了一些问题，我们先来盘点一下。</p><h3 id="客户端关闭导致服务端空轮询"><a href="#客户端关闭导致服务端空轮询" class="headerlink" title="客户端关闭导致服务端空轮询"></a>客户端关闭导致服务端空轮询</h3><p>当我们的客户端主动与服务端断开连接时，会导致READ事件一直被触发，也就是说<code>selector.select()</code>会直接通过，并且是可读的状态，但是我们发现实际上读到是数据是一个空的（上面的图中在空轮询两次后抛出异常了，也有可能是无限的循环下去）所以这里我们得稍微处理一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable()) &#123;</span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">    <span class="comment">//这里我们需要判断一下，如果read操作得到的结果是-1，那么说明服务端已经断开连接了</span></span><br><span class="line">    <span class="keyword">if</span>(channel.read(buffer) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端已经断开连接了：&quot;</span>+channel.getRemoteAddress());</span><br><span class="line">        channel.close();   <span class="comment">//直接关闭此通道</span></span><br><span class="line">        <span class="keyword">continue</span>;   <span class="comment">//继续进行选择</span></span><br><span class="line">    &#125;</span><br><span class="line">    buffer.flip();</span><br><span class="line">    System.out.println(<span class="string">&quot;接收到客户端数据：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), <span class="number">0</span>, buffer.remaining()));</span><br><span class="line">    channel.write(ByteBuffer.wrap(<span class="string">&quot;已收到！&quot;</span>.getBytes()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，除了这种情况可能会导致空轮询之外，实际上还有一种可能，这种情况是NIO框架本身的BUG：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();  <span class="comment">//由于底层epoll机制的问题，导致select方法可能会一直返回0，造成无限循环的情况。</span></span><br><span class="line">    System.out.println(<span class="string">&quot;监听到 &quot;</span>+count+<span class="string">&quot; 个事件&quot;</span>);</span><br><span class="line">    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is an issue with poll (and epoll) on Linux. If a file descriptor for a connected socket is polled with a request event mask of 0, and if the connection is abruptly terminated (RST) then the poll wakes up with the POLLHUP (and maybe POLLERR) bit set in the returned event set. The implication of this behaviour is that Selector will wakeup and as the interest set for the SocketChannel is 0 it means there aren&#x27;t any selected events and the select method returns 0.</span><br></pre></td></tr></table></figure><p>这个问题本质是与操作系统有关的，所以JDK一直都认为是操作系统的问题，不应该由自己来处理，所以这个问题在当时的好几个JDK版本都是存在的，这是一个很严重的空转问题，无限制地进行空转操作会导致CPU资源被疯狂消耗。</p><p>不过，这个问题，却被Netty框架巧妙解决了，我们后面再说。</p><h3 id="粘包-拆包问题"><a href="#粘包-拆包问题" class="headerlink" title="粘包&#x2F;拆包问题"></a>粘包&#x2F;拆包问题</h3><p>除了上面的问题之外，我们接着来看下一个问题。</p><p>我们在<code>计算机网络</code>这门课程中学习过，操作系统通过TCP协议发送数据的时候，也会先将数据存放在缓冲区中，而至于什么时候真正地发出这些数据，是由TCP协议来决定的，这是我们无法控制的事情。</p><p>也就是说，比如现在我们要发送两个数据包（P1&#x2F;P2），理想情况下，这两个包应该是依次到达服务端，并由服务端正确读取两次数据出来，但是由于上面的机制，可能会出现下面的情况：</p><ol><li>可能P1和P2被合在一起发送给了服务端（粘包现象）</li><li>可能P1和P2的前半部分合在一起发送给了服务端（拆包现象）</li><li>可能P1的前半部分就被单独作为一个部分发给了服务端，后面的和P2一起发给服务端（也是拆包现象）</li></ol><p>当然，对于这种问题，也有一些比较常见的解决方案：</p><ol><li>消息定长，发送方和接收方规定固定大小的消息长度，例如每个数据包大小固定为200字节，如果不够，空位补空格，只有接收了200个字节之后，作为一个完整的数据包进行处理。</li><li>在每个包的末尾使用固定的分隔符，比如每个数据包末尾都是<code>\r\n</code>，这样就一定需要读取到这样的分隔符才能将前面所有的数据作为一个完整的数据包进行处理。</li><li>将消息分为头部和本体，在头部中保存有当前整个数据包的长度，只有在读到足够长度之后才算是读到了一个完整的数据包。</li></ol><h2 id="Netty的ByteBuf"><a href="#Netty的ByteBuf" class="headerlink" title="Netty的ByteBuf"></a>Netty的ByteBuf</h2><ul><li>写操作完成后无需进行<code>flip()</code>翻转。</li><li>具有比ByteBuffer更快的响应速度。</li><li>动态扩容。</li></ul><p>两个指针不需要flip</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractByteBuf</span> <span class="keyword">extends</span> <span class="title class_">ByteBuf</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> readerIndex;   <span class="comment">//index被分为了读和写，是两个指针在同时工作</span></span><br><span class="line">    <span class="type">int</span> writerIndex;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> markedReaderIndex;    <span class="comment">//mark操作也分两种</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> markedWriterIndex;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxCapacity;    <span class="comment">//最大容量，没错，这玩意能动态扩容</span></span><br></pre></td></tr></table></figure><p>可以看到，读操作和写操作分别由两个指针在进行维护，每写入一次，<code>writerIndex</code>向后移动一位，每读取一次，也是<code>readerIndex</code>向后移动一位，当然<code>readerIndex</code>不能大于<code>writerIndex</code>，这样就不会像NIO中的ByteBuffer那样还需要进行翻转了。</p><p>我们继续来看看它的另一个特性，动态扩容，比如我们申请一个容量为10的缓冲区：</p><p>通过结果我们发现，在写入一个超出当前容量的数据时，会进行动态扩容，扩容会从64开始，之后每次触发扩容都会x2，当然如果我们不希望它扩容，可以指定最大容量</p><p>我们接着来看一下缓冲区的三种实现模式：堆缓冲区模式、直接缓冲区模式、复合缓冲区模式。</p><p>堆缓冲区（数组实现）和直接缓冲区（堆外内存实现）不用多说，复合缓冲区模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个复合缓冲区</span></span><br><span class="line"><span class="type">CompositeByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.compositeBuffer();</span><br><span class="line">buf.addComponent(Unpooled.copiedBuffer(<span class="string">&quot;abc&quot;</span>.getBytes()));</span><br><span class="line">buf.addComponent(Unpooled.copiedBuffer(<span class="string">&quot;def&quot;</span>.getBytes()));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buf.capacity(); i++) &#123;</span><br><span class="line">    System.out.println((<span class="type">char</span>) buf.getByte(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="零拷贝简介"><a href="#零拷贝简介" class="headerlink" title="零拷贝简介"></a>零拷贝简介</h3><p>零拷贝是一种I&#x2F;O操作优化技术，可以快速高效地将数据从文件系统移动到网络接口，而不需要将其从内核空间复制到用户空间，首先第一个问题，什么是内核空间，什么又是用户空间呢？</p><p>其实早期操作系统是不区分内核空间和用户空间的，但是应用程序能访问任意内存空间，程序很容易不稳定，常常把系统搞崩溃，比如清除操作系统的内存数据。实际上让应用程序随便访问内存真的太危险了，于是就按照CPU 指令的重要程度对指令进行了分级，指令分为四个级别：Ring0 ~ Ring3，Linux 下只使用了 Ring0 和 Ring3 两个运行级别，进程运行在 Ring3 级别时运行在用户态，指令只访问用户空间，而运行在 Ring0 级别时被称为运行在内核态，可以访问任意内存空间。</p><p>实现零拷贝我们这里演示三种方案：</p><ol><li><p>使用虚拟内存</p><p>现在的操作系统基本都是支持虚拟内存的，我们可以让内核空间和用户空间的虚拟地址指向同一个物理地址，这样就相当于是直接共用了这一块区域，也就谈不上拷贝操作了：</p></li></ol><p>​<img src="/2023/04/30/netty%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87/image-20230807232717171.png" class="" title="image-20230807232717171"></p><ol start="2"><li>使用mmap&#x2F;write内存映射</li></ol><p>实际上这种方式就是将内核空间中的缓存直接映射到用户空间缓存，比如我们之前在学习NIO中使用的MappedByteBuffer，就是直接作为映射存在，当我们需要将数据发送到Socket缓冲区时，直接在内核空间中进行操作就行了</p><img src="/2023/04/30/netty%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87/image-20230807232819424.png" class="" title="image-20230807232819424"><ol start="3"><li>使用sendfile方式</li></ol><p>在Linux2.1开始，引入了sendfile方式来简化操作，我们可以直接告诉内核要把哪个文件数据拷贝拷贝到Socket上，直接在内核空间中一步到位：</p><img src="/2023/04/30/netty%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87/image-20230807232838805.png" class="" title="image-20230807232838805">]]></content>
      
      
      <categories>
          
          <category> 编程基本功 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
            <tag> nio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写简单的Spring</title>
      <link href="/2023/02/23/%E6%89%8B%E5%86%99%E7%AE%80%E5%8D%95%E7%9A%84Spring/"/>
      <url>/2023/02/23/%E6%89%8B%E5%86%99%E7%AE%80%E5%8D%95%E7%9A%84Spring/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 编程基本功 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目部署-jvm调优</title>
      <link href="/2023/02/01/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2-jvm%E8%B0%83%E4%BC%98/"/>
      <url>/2023/02/01/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2-jvm%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<p>部署上线前准备</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><blockquote><p>开发完成后，到了上线环节，需要检查mysql的索引是否设置合理，如果后续数据量多了在设置索引，那么用时会比较长，需要进行停机维护，造成不好的用户体验</p></blockquote><p><strong>合理设置索引，可以有效的提高查询性能</strong></p><p>索引的设计原则：</p><ol><li>每个表都必须有<code>自增主键</code><ol><li>有顺序，磁盘顺序读写 速度快</li><li>插入数据的时候，会插入到最后（B+Tree结构），减少了数据移动</li><li>减少页分裂（B+Tree结构）</li></ol></li><li>常做为<code>查询条件</code>的字段，<code>排序</code>，<code>分组</code>的字段建立索引<ol><li>提高查询效率</li></ol></li><li>索引字段的选择尽量不使用 <code>字段长度较长</code>的</li><li>数据量小的表 不建立索引</li><li>限制索引的数量 不是越多越好 （通常建议在6个以内）</li><li>写比多，并且写频繁的表不建议加索引</li><li>不要在<code>区分度低</code>的字段建立索引<ol><li>比如性别，只有 男 女 未知 三个值，索引完全起不到优化作用</li></ol></li><li>联合索引的创建要符合<code>最左原则</code><ol><li>遇到范围查询 索引失效</li><li>比如：a &#x3D; 1 and b &#x3D; 2 and c &gt; 3 and d &#x3D; 4，如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li><li>比如: a &#x3D; 1 and b &gt; 3 and c &lt; 4 , 我们可以对(a,b) 或者（a,c）建索引，都可以，如何选择，可以看 b和c谁的区分度高</li></ol></li></ol><h2 id="mysql数据页"><a href="#mysql数据页" class="headerlink" title="mysql数据页"></a>mysql数据页</h2><blockquote><p>InnoDB从磁盘中读取数据的最小单位是数据页。而你想得到的id &#x3D; xxx的数据，就是这个数据页众多行中的一行。</p></blockquote><img src="/2023/02/01/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2-jvm%E8%B0%83%E4%BC%98/1496926-20201126113029931-1621355504.png" class="" title="img"><blockquote><p>在InnoDB存储引擎中，数据页是InnoDB磁盘管理的最小的数据单位，<code>数据页的默认大小为16KB</code>。</p></blockquote><p>在MySQL5.6中：你可以通过参数<code>innodb_page_size</code>设置每个数据页的大小为4KB、8KB、16KB。一旦设置完成后，所有表中的数据页大小都将是你设置的值且不可变。不论你将<code>innodb_page_size</code>设置成多大，一个区（extent）1MB的事实都不会改变。</p><p>在MySQL5.7.6中：允许你将<code>innodb_page_size</code>  设置成 32KB、64KB大小。对于32KB大小的数据页来说区的大小被调整成2MB。对于64KB大小的数据页来说，区的大小被调整成4MB。</p><h2 id="数据区"><a href="#数据区" class="headerlink" title="数据区"></a>数据区</h2><blockquote><p>在MySQL的设定中，同一个表空间内的一组连续的数据页为一个extent（区），默认区的大小为1MB，页的大小为16KB。16*64&#x3D;1024，也就是说一个区里面会有64个连续的数据页。连续的256个数据区为一组数据区。</p></blockquote><img src="/2023/02/01/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2-jvm%E8%B0%83%E4%BC%98/1496926-20201126113030834-1060222235.jpg" class="" title="img"><h2 id="B-TREE和B-TREE"><a href="#B-TREE和B-TREE" class="headerlink" title="B-TREE和B+TREE"></a>B-TREE和B+TREE</h2><ol><li><p>B-Tree(读B树,中间是连接符，不是减号)</p><img src="/2023/02/01/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2-jvm%E8%B0%83%E4%BC%98/20160202204827368" class="" title="B-Tree"><blockquote><p>以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35</p></blockquote><p>模拟查找关键字29的过程：</p><ol><li>根据根节点找到磁盘块1，读入内存。【磁盘I&#x2F;O操作第1次】</li><li>比较关键字29在区间（17,35），找到磁盘块1的指针P2。</li><li>根据P2指针找到磁盘块3，读入内存。【磁盘I&#x2F;O操作第2次】</li><li>比较关键字29在区间（26,30），找到磁盘块3的指针P2。</li><li>根据P2指针找到磁盘块8，读入内存。【磁盘I&#x2F;O操作第3次】</li><li>在磁盘块8中的关键字列表中找到关键字29。</li></ol><p><strong>分析上面过程，发现需要3次磁盘I&#x2F;O操作，和3次内存查找操作。</strong></p></li><li><p>B+Tree</p><blockquote><p>B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。</p></blockquote><p><strong>B+Tree相对于B-Tree有几点不同：</strong></p><ol><li>非叶子节点只存储键值信息。</li><li>所有叶子节点之间都有一个链指针。</li><li>数据记录都存放在叶子节点中。</li></ol><img src="/2023/02/01/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2-jvm%E8%B0%83%E4%BC%98/20160202205105560" class="" title="B+Tree"></li><li><p>由于非叶子节点不存储数据，所以可以存储大量的键，树的深度会减少，代表会进行较少的磁盘IO</p></li><li><p>叶子节点使用链表，能够很好的支持范围查询</p></li><li><p>充分利用空间局部性原理，适合磁盘存储</p><ol><li>磁盘IO是一个比较耗时的操作，而操作系统在设计时则定义一个空间局部性原则，局部性原理是指CPU访问存储器时，<strong>无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中</strong>。</li><li>操作系统的文件系统中，数据也是按照page划分的，一般为4k或8k。<strong>当计算机访问一个地址数据时，不仅会加载当前数据所在的数据页，还会将当前数据页相邻的数据页一同加载到内存</strong>。而这个过程实际上只发生了1次磁盘IO，这个理论对于索引的数据结构设计非常有帮助。</li></ol></li></ol><h2 id="数据页分裂问题"><a href="#数据页分裂问题" class="headerlink" title="数据页分裂问题"></a>数据页分裂问题</h2><blockquote><p>假设你现在已经有两个数据页了。并且你正在往第二个数据页中写数据。</p></blockquote><p><strong>假设你自定义了主键索引，而且你自定义的这个主键索引并不一定是自增的</strong></p><p>会出现如下情况：</p><img src="/2023/02/01/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2-jvm%E8%B0%83%E4%BC%98/1496926-20201126113031695-1349347128.png" class="" title="img"><blockquote><p>随着你将数据写入。就导致<code>后一个数据页中的所有行并不一定比前一个数据页中的行的id大</code>。</p></blockquote><p><strong>这时就会触发页分裂的逻辑</strong></p><p>页分裂的目的就是保证：<code>后一个数据页中的所有行主键值比前一个数据页中主键值大。</code></p><img src="/2023/02/01/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2-jvm%E8%B0%83%E4%BC%98/1496926-20201126113032271-1519023118.png" class="" title="img"><blockquote><p>如果使用主键索引，就会减少页分裂</p></blockquote><h1 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h1><blockquote><p>上线之前，需要预估系统的访问量，设置合理的JVM参数</p></blockquote><h2 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h2><blockquote><p>首先我们需要明白，JVM是在内存当中的，我们程序运行的过程当中，会持续的在内存中占用空间，有些对象使用完成之后，就不会在被使用了，那么应该被回收掉，释放内存空间，保证程序的运行。</p></blockquote><img src="/2023/02/01/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2-jvm%E8%B0%83%E4%BC%98/1312707-20200313093242807-162444051.png" class="" title="img"><ol><li><p>年轻代（新生代）</p><blockquote><p>新生代主要用来存放新生的对象。一般占据堆空间的1&#x2F;3。在新生代中，保存着大量的刚刚创建的对象，但是大部分的对象都是朝生夕死，所以在新生代中会频繁的进行<code>MinorGC</code>，进行垃圾回收。新生代又细分为三个区：<code>Eden区</code>、<code>SurvivorFrom</code>、<code>ServivorTo</code>区，三个区的默认比例为：8：1：1。</p></blockquote><ol><li><p><strong>Eden区</strong></p><blockquote><p>Java<code>新创建的对象</code>绝大部分会分配在Eden区（如果对象太大，则直接分配到老年代）。当Eden区内存不够的时候，就会触发<code>MinorGC</code>（新生代采用的是<code>复制算法</code>），对新生代进行一次垃圾回收。</p></blockquote></li><li><p><strong>SurvivorFrom区和To区</strong></p><blockquote><p>在GC开始的时候，对象只会存在于Eden区和名为<code>From的Survivor区</code>，To区是空的，一次MinorGc过后，<code>Eden区和SurvivorFrom区存活的对象会移动到SurvivorTo区中</code>，然后会<code>清空Eden区和SurvivorFrom区</code>，并对存活的对象的<code>年龄+1</code>，如果对象的年龄达到<code>15</code>，则直接分配到<code>老年代</code>。MinorGC完成后，SurvivorFrom区和SurvivorTo区的功能进行互换。下一次MinorGC时，会把SurvivorTo区和Eden区存活的对象放入SurvivorFrom区中，并计算对象存活的年龄。</p></blockquote></li></ol></li><li><p>老年代</p><blockquote><p>​老年代主要存放应用中生命周期长的内存对象。老年代比较稳定，<code>不会频繁的进行MajorGC</code>。而在<code>MaiorGC之前才会先进行一次MinorGC</code>，使得新生的对象进入老年代而导致空间不够才会触发。当无法找到足够大的连续空间分配给新创建的较大对象也会提前触发一次MajorGC进行垃圾回收腾出空间。</p><p>　　在老年代中，MajorGC采用了<code>标记—清除算法</code>：首先扫描一次所有老年代里的对象，标记出存活的对象，然后回收没有标记的对象。<code>MajorGC的耗时比较长</code>。因为要扫描再回收。<code>MajorGC会产生内存碎片</code>，当老年代也没有内存分配给新来的对象的时候，就会抛出<code>OOM（Out of Memory）</code>异常。</p></blockquote></li><li><p>永久代</p><blockquote><p>永久代指的是永久保存区域。</p><p>主要存放<code>Class和Meta（元数据）</code>的信息。</p><p>Classic在被加载的时候被放入永久区域，它和存放的实例的区域不同，在Java8中，永久代已经被移除，取而代之的是一个称之为“元数据区”（<code>元空间</code>）的区域。</p><p>元空间和永久代类似，都是对JVM中规范中方法的实现。不过元空间与永久代之间最大的区别在于：<code>元空间并不在虚拟机中，而是使用本地内存</code>。因此，默认情况下，元空间的大小仅受本地内存的限制。类的元数据放入native memory，字符串池和类的静态变量放入java堆中。这样可以加载多少类的元数据就不再由MaxPermSize控制，而由系统的实际可用空间来控制。</p><p>采用元空间而不用永久代的原因：</p><ul><li>为了解决永久代的OOM问题，元数据和class对象存放在永久代中，容易出现性能问题和内存溢出。</li><li>类及方法的信息等比较难确定其大小，因此对于永久代大小指定比较困难，大小容易出现永久代溢出，太大容易导致老年代溢出（堆内存不变，此消彼长）。</li><li>永久代会为GC带来不必要的复杂度，并且回收效率偏低。</li></ul></blockquote></li></ol><h2 id="FullGC"><a href="#FullGC" class="headerlink" title="FullGC"></a>FullGC</h2><p>MinorGC: 年轻代回收</p><p>Major GC：老年代回收</p><p>FullGC：年轻代，老年代，永久代都回收 </p><p>触发FullGC的条件：</p><ol><li>System.gc()</li><li>老年代空间不足</li><li>永久代空间不足</li><li>gc担保失败，进行MinorGC之前会检查老年代是否有足够的连续空间大于平均历次晋升到老年代大小，如果小于 则进行FullGC</li></ol><p><strong>调优的目的是尽量少的发生fullGC，FullGC会发生STW（世界停顿），影响系统性能</strong></p><h2 id="如何确定参数"><a href="#如何确定参数" class="headerlink" title="如何确定参数"></a>如何确定参数</h2><blockquote><p>JVM最优的参数，最好是在应用上线前就确定好，我们首先预估单机应用需要能承载的最大量级，然后进行压测，根据日志来进行调优</p></blockquote><h3 id="项目部署到虚拟机"><a href="#项目部署到虚拟机" class="headerlink" title="项目部署到虚拟机"></a>项目部署到虚拟机</h3><blockquote><p>我们克隆一个虚拟机，将其中的部署软件都清空，部署springboot程序上去</p></blockquote><p>做一个新的配置文件，application-prod.properties，将其中的数据库，redis，等连接修改一下</p><ol><li><p>打包</p><p>在api的模块依赖加入maven打包插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>如果选择连本机数据库，记得开启允许所有ip访问</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> mysql.user <span class="keyword">set</span> host <span class="operator">=</span> <span class="string">&#x27;%&#x27;</span> <span class="keyword">where</span> <span class="keyword">user</span> <span class="operator">=</span><span class="string">&#x27;root&#x27;</span>;</span><br><span class="line">flush privilege;</span><br></pre></td></tr></table></figure></li><li><p>在虚拟机上创建目录，并将sso，web，sso-provider这些jar包上传</p></li><li><p>创建启动脚本 并 chmod +x sso-api.sh</p><p>sso-api.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这里可替换为你自己的执行程序，其他代码无需更改</span></span><br><span class="line">APP_NAME=sso-api.jar</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用说明，用来提示输入参数</span></span><br><span class="line">usage() &#123;</span><br><span class="line">    echo &quot;Usage: sh demo.sh [start|stop|restart|status]&quot;</span><br><span class="line">    exit 1</span><br><span class="line">&#125;       </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">检查程序是否在运行</span></span><br><span class="line">is_exist() &#123; </span><br><span class="line">     pid=`ps -ef | grep $APP_NAME | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27; `</span><br><span class="line">     echo &quot;pid==$&#123;pid&#125;&quot;</span><br><span class="line">     #如果不存在返回1，存在返回0</span><br><span class="line">     if [ -z &quot;$&#123;pid&#125;&quot; ]; then</span><br><span class="line">     echo &#x27;不存在，没有启动,准备启动&#x27;</span><br><span class="line">             return 1</span><br><span class="line">        else</span><br><span class="line">             return 0</span><br><span class="line">        fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动方法</span></span><br><span class="line">start() &#123;</span><br><span class="line">    echo &quot;*********check is_exist in first*****&quot;</span><br><span class="line">    is_exist</span><br><span class="line">    if [ $? -eq &quot;0&quot; ]; then</span><br><span class="line">       echo &quot;$&#123;APP_NAME&#125; is already running. pid=$&#123;pid&#125; .&quot;</span><br><span class="line">       kill $pid</span><br><span class="line">       sleep 5s</span><br><span class="line">       kill -9 $pid</span><br><span class="line">       echo &quot;kill pid &quot; $pid</span><br><span class="line">    else</span><br><span class="line">       echo &quot;$&#123;APP_NAME&#125; 开始启动.... .&quot;  </span><br><span class="line">       nohup java -jar -Xmx512m -Xms512m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=sso.dump  -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:sso-api.gc $APP_NAME --spring.profiles.active=prod &gt; sso.log 2&gt;&amp;1 &amp;</span><br><span class="line">       echo &quot;启动完成&quot;</span><br><span class="line">                 </span><br><span class="line">       fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">停止方法</span></span><br><span class="line">  stop() &#123;</span><br><span class="line">      is_exist</span><br><span class="line">      if [ $? -eq &quot;0&quot; ]; then</span><br><span class="line">           kill -9 $pid</span><br><span class="line">      else</span><br><span class="line">           echo &quot;$&#123;APP_NAME&#125; is not running&quot;</span><br><span class="line">      fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输出运行状态</span></span><br><span class="line">status() &#123;</span><br><span class="line">    is_exist</span><br><span class="line">    if [ $? -eq &quot;0&quot; ]; then</span><br><span class="line">       echo &quot;$&#123;APP_NAME&#125; is running. Pid is $&#123;pid&#125;&quot;</span><br><span class="line">    else</span><br><span class="line">       echo &quot;$&#123;APP_NAME&#125; is not running.&quot;</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启</span></span><br><span class="line">restart() &#123;</span><br><span class="line">   stop</span><br><span class="line">   start</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">根据输入参数，选择执行对应方法，不输入则执行使用说明</span></span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">     &quot;start&quot;)</span><br><span class="line">     start</span><br><span class="line">     ;;</span><br><span class="line">     &quot;stop&quot;)</span><br><span class="line">     stop</span><br><span class="line">     ;;</span><br><span class="line">     &quot;status&quot;)</span><br><span class="line">     status</span><br><span class="line">     ;;</span><br><span class="line">     &quot;restart&quot;)</span><br><span class="line">     restart</span><br><span class="line">     ;;</span><br><span class="line">     *)</span><br><span class="line">     usage</span><br><span class="line">     ;;</span><br><span class="line">esac       </span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>sso-provider.sh:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这里可替换为你自己的执行程序，其他代码无需更改</span></span><br><span class="line">APP_NAME=sso-provider.jar</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用说明，用来提示输入参数</span></span><br><span class="line">usage() &#123;</span><br><span class="line">    echo &quot;Usage: sh demo.sh [start|stop|restart|status]&quot;</span><br><span class="line">    exit 1</span><br><span class="line">&#125;       </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">检查程序是否在运行</span></span><br><span class="line">is_exist() &#123; </span><br><span class="line">     pid=`ps -ef | grep $APP_NAME | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27; `</span><br><span class="line">     echo &quot;pid==$&#123;pid&#125;&quot;</span><br><span class="line">     #如果不存在返回1，存在返回0</span><br><span class="line">     if [ -z &quot;$&#123;pid&#125;&quot; ]; then</span><br><span class="line">     echo &#x27;不存在，没有启动,准备启动&#x27;</span><br><span class="line">             return 1</span><br><span class="line">        else</span><br><span class="line">             return 0</span><br><span class="line">        fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动方法</span></span><br><span class="line">start() &#123;</span><br><span class="line">    echo &quot;*********check is_exist in first*****&quot;</span><br><span class="line">    is_exist</span><br><span class="line">    if [ $? -eq &quot;0&quot; ]; then</span><br><span class="line">       echo &quot;$&#123;APP_NAME&#125; is already running. pid=$&#123;pid&#125; .&quot;</span><br><span class="line">       kill $pid</span><br><span class="line">       sleep 5s</span><br><span class="line">       kill -9 $pid</span><br><span class="line">       echo &quot;kill pid &quot; $pid</span><br><span class="line">    else</span><br><span class="line">       echo &quot;$&#123;APP_NAME&#125; 开始启动 .&quot;  </span><br><span class="line">       nohup java -jar -Xmx512m -Xms512m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=sso-provider.dump  -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:sso-provider.gc $APP_NAME --spring.profiles.active=prod &gt; sso-provider.log 2&gt;&amp;1 &amp;</span><br><span class="line">       echo &quot;启动完成&quot;</span><br><span class="line">                 </span><br><span class="line">       fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">停止方法</span></span><br><span class="line">  stop() &#123;</span><br><span class="line">      is_exist</span><br><span class="line">      if [ $? -eq &quot;0&quot; ]; then</span><br><span class="line">           kill -9 $pid</span><br><span class="line">      else</span><br><span class="line">           echo &quot;$&#123;APP_NAME&#125; is not running&quot;</span><br><span class="line">      fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输出运行状态</span></span><br><span class="line">status() &#123;</span><br><span class="line">    is_exist</span><br><span class="line">    if [ $? -eq &quot;0&quot; ]; then</span><br><span class="line">       echo &quot;$&#123;APP_NAME&#125; is running. Pid is $&#123;pid&#125;&quot;</span><br><span class="line">    else</span><br><span class="line">       echo &quot;$&#123;APP_NAME&#125; is not running.&quot;</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启</span></span><br><span class="line">restart() &#123;</span><br><span class="line">   stop</span><br><span class="line">   start</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">根据输入参数，选择执行对应方法，不输入则执行使用说明</span></span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">     &quot;start&quot;)</span><br><span class="line">     start</span><br><span class="line">     ;;</span><br><span class="line">     &quot;stop&quot;)</span><br><span class="line">     stop</span><br><span class="line">     ;;</span><br><span class="line">     &quot;status&quot;)</span><br><span class="line">     status</span><br><span class="line">     ;;</span><br><span class="line">     &quot;restart&quot;)</span><br><span class="line">     restart</span><br><span class="line">     ;;</span><br><span class="line">     *)</span><br><span class="line">     usage</span><br><span class="line">     ;;</span><br><span class="line">esac       </span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>web-api.sh:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这里可替换为你自己的执行程序，其他代码无需更改</span></span><br><span class="line">APP_NAME=web-api.jar</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用说明，用来提示输入参数</span></span><br><span class="line">usage() &#123;</span><br><span class="line">    echo &quot;Usage: sh demo.sh [start|stop|restart|status]&quot;</span><br><span class="line">    exit 1</span><br><span class="line">&#125;       </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">检查程序是否在运行</span></span><br><span class="line">is_exist() &#123; </span><br><span class="line">     pid=`ps -ef | grep $APP_NAME | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27; `</span><br><span class="line">     echo &quot;pid==$&#123;pid&#125;&quot;</span><br><span class="line">     #如果不存在返回1，存在返回0</span><br><span class="line">     if [ -z &quot;$&#123;pid&#125;&quot; ]; then</span><br><span class="line">     echo &#x27;不存在，没有启动,准备启动&#x27;</span><br><span class="line">             return 1</span><br><span class="line">        else</span><br><span class="line">             return 0</span><br><span class="line">        fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动方法</span></span><br><span class="line">start() &#123;</span><br><span class="line">    echo &quot;*********check is_exist in first*****&quot;</span><br><span class="line">    is_exist</span><br><span class="line">    if [ $? -eq &quot;0&quot; ]; then</span><br><span class="line">       echo &quot;$&#123;APP_NAME&#125; is already running. pid=$&#123;pid&#125; .&quot;</span><br><span class="line">       kill $pid</span><br><span class="line">       sleep 5s</span><br><span class="line">       kill -9 $pid</span><br><span class="line">       echo &quot;kill pid &quot; $pid</span><br><span class="line">    else</span><br><span class="line">       echo &quot;$&#123;APP_NAME&#125; 开始启动 .&quot;  </span><br><span class="line">       nohup java -jar -Xmx512m -Xms512m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=web-api.dump  -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:web-api.gc $APP_NAME --spring.profiles.active=prod &gt; web-api.log 2&gt;&amp;1 &amp;</span><br><span class="line">       echo &quot;启动完成&quot;</span><br><span class="line">                 </span><br><span class="line">       fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">停止方法</span></span><br><span class="line">  stop() &#123;</span><br><span class="line">      is_exist</span><br><span class="line">      if [ $? -eq &quot;0&quot; ]; then</span><br><span class="line">           kill -9 $pid</span><br><span class="line">      else</span><br><span class="line">           echo &quot;$&#123;APP_NAME&#125; is not running&quot;</span><br><span class="line">      fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输出运行状态</span></span><br><span class="line">status() &#123;</span><br><span class="line">    is_exist</span><br><span class="line">    if [ $? -eq &quot;0&quot; ]; then</span><br><span class="line">       echo &quot;$&#123;APP_NAME&#125; is running. Pid is $&#123;pid&#125;&quot;</span><br><span class="line">    else</span><br><span class="line">       echo &quot;$&#123;APP_NAME&#125; is not running.&quot;</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启</span></span><br><span class="line">restart() &#123;</span><br><span class="line">   stop</span><br><span class="line">   start</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">根据输入参数，选择执行对应方法，不输入则执行使用说明</span></span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">     &quot;start&quot;)</span><br><span class="line">     start</span><br><span class="line">     ;;</span><br><span class="line">     &quot;stop&quot;)</span><br><span class="line">     stop</span><br><span class="line">     ;;</span><br><span class="line">     &quot;status&quot;)</span><br><span class="line">     status</span><br><span class="line">     ;;</span><br><span class="line">     &quot;restart&quot;)</span><br><span class="line">     restart</span><br><span class="line">     ;;</span><br><span class="line">     *)</span><br><span class="line">     usage</span><br><span class="line">     ;;</span><br><span class="line">esac       </span><br><span class="line">   </span><br></pre></td></tr></table></figure></li></ol><h3 id="压测"><a href="#压测" class="headerlink" title="压测"></a>压测</h3><blockquote><p>上方我们部署了程序，并将gc信息打印在了日志当中，接下来我们对web应用的查询课程列表接口进行压测，并且查看对应的gc日志</p></blockquote><p>资料中有提供jmeter，我们使用它来进行压测。</p><p>解压，运行jmeter.cmd（windows）</p><img src="/2023/02/01/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2-jvm%E8%B0%83%E4%BC%98/image-20211202222953142.png" class="" title="image-20211202222953142"><p>添加线程组：</p><img src="/2023/02/01/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2-jvm%E8%B0%83%E4%BC%98/image-20211202223016219.png" class="" title="image-20211202223016219"><p>线程数 设置为：500</p><img src="/2023/02/01/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2-jvm%E8%B0%83%E4%BC%98/image-20211202223030363.png" class="" title="image-20211202223030363"><p>设置请求默认值，为所有请求添加一些公共配置</p><img src="/2023/02/01/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2-jvm%E8%B0%83%E4%BC%98/image-20211202223139907.png" class="" title="image-20211202223139907"><img src="/2023/02/01/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2-jvm%E8%B0%83%E4%BC%98/image-20211202223330763.png" class="" title="image-20211202223330763"><p>构造HTTP请求</p><img src="/2023/02/01/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2-jvm%E8%B0%83%E4%BC%98/image-20211202223356251.png" class="" title="image-20211202223356251"><img src="/2023/02/01/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2-jvm%E8%B0%83%E4%BC%98/image-20211202223834207.png" class="" title="image-20211202223834207"><p>添加http请求头：</p><img src="/2023/02/01/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2-jvm%E8%B0%83%E4%BC%98/image-20211202223904218.png" class="" title="image-20211202223904218"><img src="/2023/02/01/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2-jvm%E8%B0%83%E4%BC%98/image-20211202223937781.png" class="" title="image-20211202223937781"><p>添加断言：</p><img src="/2023/02/01/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2-jvm%E8%B0%83%E4%BC%98/image-20211202224050762.png" class="" title="image-20211202224050762"><img src="/2023/02/01/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2-jvm%E8%B0%83%E4%BC%98/image-20211202224210622.png" class="" title="image-20211202224210622"><p>添加查看结果树：</p><img src="/2023/02/01/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2-jvm%E8%B0%83%E4%BC%98/image-20211202225100747.png" class="" title="image-20211202225100747"><p>点击<code>运行</code>，可以看一下请求是否正确。</p><p>添加加Summary Report：</p><img src="/2023/02/01/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2-jvm%E8%B0%83%E4%BC%98/image-20211202225534770.png" class="" title="image-20211202225534770"><p>点击<code>运行</code>可以查看结果。</p><h4 id="执行测试计划"><a href="#执行测试计划" class="headerlink" title="执行测试计划"></a>执行测试计划</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmeter -n -t web测试.jmx -l web_test/result.txt -e -o web_test/report.out</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) 2021-12-02T21:40:40.605+0800: 0.833: [DefNew: 157248K-&gt;2109K(157248K), 2.4087729 secs] 359913K-&gt;221248K(506816K), 2.4089225 secs] [Times: user=0.01 sys=0.00, real=0.02 secs]</span><br></pre></td></tr></table></figure><p><code>GC</code> ：如果前面没有Full修饰，代表这是一次Minor GC </p><p><code>Allocation Failure</code>：本次引起GC的原因是因为在年轻代中没有足够的空间</p><p><code>DefNew</code>: 串行收集器</p><p><code>157248K-&gt;2109K(157248K)</code>：<strong>单位是KB</strong></p><p>分别代表：GC前该内存区域(这里是年轻代)使用容量，GC后该内存区域使用容量，该内存区域总容量。</p><p><code>2.4087729 secs</code>：该内存区域GC耗时，单位是秒</p><p><code>359913K-&gt;221248K(506816K)</code>：三个参数分别为：堆区垃圾回收前的大小，堆区垃圾回收后的大小，堆区总大小。</p><p><code>2.4089225 secs</code>：该内存区域GC耗时，单位是秒</p><p><code>Times: user=0.01 sys=0.00, real=0.02 secs</code>：分别表示用户态耗时，内核态耗时和总耗时</p><p>分析：</p><p>年轻代此次GC减少了：157248-2109&#x3D;155319K</p><p>Heap区总共减少了： 359913-221248&#x3D;138665K</p><p>155319-138665&#x3D;16654K, 代表共有这么16654K从年轻代移动到了老年代</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Full GC (Metadata GC Threshold) 2021-12-02T21:40:45.578+0800: 5.806: [Tenured: 24576K-&gt;30347K(349568K), 0.1040736 secs] 149544K-&gt;30347K(506816K), [Metaspace: 33668K-&gt;33668K(1081344K)], 0.1041350 secs] [Times: user=0.11 sys=0.00, real=0.11 secs</span><br></pre></td></tr></table></figure><p><code>Metadata GC Threshold</code>:Metaspace大小达到了GC阈值</p><p><code>Tenured</code>：老年代</p><p><code>24576K-&gt;30347K(349568K)</code>:GC 前该区域已使用容量 -&gt; GC 后该区域已使用容量 (该区域内存总容量)</p><p><code>149544K-&gt;30347K(506816K)</code>:GC 前Java堆已使用容量 -&gt; GC后Java堆已使用容量 （Java堆总容量）</p><p><code>Metaspace: 33668K-&gt;33668K(1081344K)</code>:元空间 使用内存gc前后的变化</p><blockquote><p>通过日志可以看出，Metaspace区并没有真正释放空间，所以怀疑是Metaspace区不够用了。JDK8中，<code>XX:MaxMetaspaceSize</code>确实是没有上限的，最大容量与机器的内存有关；<strong>但是<code>XX:MetaspaceSize</code>是有一个默认值的：21M</strong>。</p></blockquote><p>解决：设置一个<code>XX:MetaspaceSize</code>的JVM启动参数：<code>-XX:MetaspaceSize=128M</code></p><blockquote><p>同时年轻代gc过于频繁，时间也较长，考虑设置的gc相关参数不合理，我们重新设置一个gc参数</p></blockquote><p><code>-XX:+UseG1GC</code>： 设置G1垃圾回收器</p><p><code>-XX:MetaspaceSize=128M</code></p><p><code>-Xms1024m</code>:最小堆内存</p><p><code>-Xmx1024m</code>：最大堆内存</p><p><code>-Xmn384m</code>:新生代大小</p><p><code>-XX:NewRatio</code>:默认2表示新生代占年老代的1&#x2F;2，占整个堆内存的1&#x2F;3。</p><p><code>-XX:SurvivorRatio</code>:默认8表示一个survivor区占用1&#x2F;8的Eden内存，即1&#x2F;10的新生代内存。</p><p><code>-XX:+PrintAdaptiveSizePolicy</code>：自适应策略 ，用于G1调优</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar -Xmx1024m -Xms1024m -Xmn384m -XX:+UseG1GC -XX:MetaspaceSize=128M -XX:+HeapDumpOnOutOfMemoryError -XX:+PrintAdaptiveSizePolicy -XX:HeapDumpPath=sso.dump  -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:sso-api.gc </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[GC pause (G1 Evacuation Pause) (young), 0.0843619 secs]</span><br><span class="line">   [Parallel Time: 83.7 ms, GC Workers: 1]</span><br><span class="line">      [GC Worker Start (ms):  258031.6]</span><br><span class="line">      [Ext Root Scanning (ms):  4.4]</span><br><span class="line">      [Update RS (ms):  15.9]</span><br><span class="line">         [Processed Buffers:  101]</span><br><span class="line">      [Scan RS (ms):  0.6]</span><br><span class="line">      [Code Root Scanning (ms):  0.0]</span><br><span class="line">      [Object Copy (ms):  62.6]</span><br><span class="line">      [Termination (ms):  0.0]</span><br><span class="line">         [Termination Attempts:  1]</span><br><span class="line">      [GC Worker Other (ms):  0.0]</span><br><span class="line">      [GC Worker Total (ms):  83.6]</span><br><span class="line">      [GC Worker End (ms):  258115.2]</span><br><span class="line">   [Code Root Fixup: 0.0 ms]</span><br><span class="line">   [Code Root Purge: 0.0 ms]</span><br><span class="line">   [Clear CT: 0.1 ms]</span><br><span class="line">   [Other: 0.5 ms]</span><br><span class="line">      [Choose CSet: 0.0 ms]</span><br><span class="line">      [Ref Proc: 0.1 ms]</span><br><span class="line">      [Ref Enq: 0.0 ms]</span><br><span class="line">      [Redirty Cards: 0.0 ms]</span><br><span class="line">      [Humongous Register: 0.0 ms]</span><br><span class="line">      [Humongous Reclaim: 0.0 ms]</span><br><span class="line">      [Free CSet: 0.1 ms]</span><br><span class="line">   [Eden: 355.0M(355.0M)-&gt;0.0B(354.0M) Survivors: 29.0M-&gt;30.0M Heap: 752.5M(1024.0M)-&gt;405.0M(1024.0M)]</span><br><span class="line"> [Times: user=0.05 sys=0.03, real=0.08 secs] </span><br></pre></td></tr></table></figure><p><code>young</code>:年轻代垃圾回收情况</p><p><code>[Parallel Time: 83.7 ms, GC Workers: 1]</code>:标记着并行阶段的汇总信息。总共花费时间以及GC的工作线程数。</p><p><code> [GC Worker Start (ms):  258031.6]</code>:开始时间</p><p><code>Ext Root Scanning (ms):  4.4</code>: 外部根区扫描。外部根是堆外区。JNI引用，JVM系统目录，Classloaders等</p><p><code>Update RS (ms):  15.9</code>:RSet的处理, UpdateRS:更新RSet的时间信息。**-XX:MaxGCPauseMillis**(默认200ms)参数是限制G1的暂停时间，一般RSet更新的时间小于10%的目标暂停时间是比较可取的。</p><p><code>Code Root Scanning (ms):  0.0</code>:代码根的扫描</p><p><code>Object Copy (ms):  62.6</code>：该任务主要是对CSet中存活对象进行转移（复制）。对象拷贝的时间一般占用暂停时间的主要部分。如果拷贝时间和”预测暂停时间“有相差很大，也可以调整年轻代尺寸大小。</p><p><code>Termination (ms):  0.0</code>：终止工作线程。Work线程在工作终止前会检查其他工作线程的任务，如果其他work线程有没完成的任务，会抢活。如果终止时间较长，可能是某个work线程在某项任务执行时间过长。</p><p><code>GC Worker Other (ms):  0.0</code>:花在GC之外的工作线程的时间，比如因为JVM的某个活动，导致GC线程被停掉。这部分消耗的时间不是真正花在GC上，只是作为log的一部分记录。</p><p><code>GC Worker Total (ms):  83.6</code>:并行阶段的GC汇总，包含了GC以及GC Worker Other的总时间</p><p><code>GC 串行活动</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Code Root Fixup: <span class="number">0.0</span> ms]</span><br><span class="line">  [Code Root Purge: <span class="number">0.0</span> ms]</span><br><span class="line">  [Clear CT: <span class="number">0.1</span> ms]</span><br></pre></td></tr></table></figure><p>串行的GC活动。包括代码根的更新和扫描。Clear的时候还要清理RSet相应去除的Card Table信息。G1 GC在扫描Card信息时会有一个标记记录，防止重复扫描同一个Card。</p><p><code>GC Other活动</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">剩余的部分就是其他GC活动了。主要包含:选择CSet、引用处理和排队、卡片重新脏化、回收空闲巨型分区以及在收集之后释放CSet</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Other: <span class="number">0.5</span> ms]</span><br><span class="line">     [Choose CSet: <span class="number">0.0</span> ms]</span><br><span class="line">     [Ref Proc: <span class="number">0.1</span> ms]</span><br><span class="line">     [Ref Enq: <span class="number">0.0</span> ms]</span><br><span class="line">     [Redirty Cards: <span class="number">0.0</span> ms]</span><br><span class="line">     [Humongous Register: <span class="number">0.0</span> ms]</span><br><span class="line">     [Humongous Reclaim: <span class="number">0.0</span> ms]</span><br><span class="line">     [Free CSet: <span class="number">0.1</span> ms]</span><br></pre></td></tr></table></figure><p><code>垃圾收集结果统计</code>: [Eden: 355.0M(355.0M)-&gt;0.0B(354.0M) Survivors: 29.0M-&gt;30.0M Heap: 752.5M(1024.0M)-&gt;405.0M(1024.0M)]</p><p><code>Eden: 355.0M(355.0M)-&gt;0.0B(354.0M)</code>: Eden分区GC前355M,GC后是0,括号里面的分别是GC前后Eden分区的总大小。可以看到在一次GC后，Eden的空间做了调整。G1 GC的暂停时间是可预测的，所以YoungGC之后，会根据pause time的目标重新计算需要的Eden分区数，进行动态调整。</p><p><code>Survivors: 29.0M-&gt;30.0M </code>: Survivors空间的变化，空间增长了，说明有存活对象E区晋升到S区。</p><p><code>Heap: 752.5M(1024.0M)-&gt;405.0M(1024.0M)</code>：整个堆区的GC前后空间数据，G1 GC会动态调整堆区，但这次回收中没有改变堆区的容量。</p><p><code>年轻代调优</code>:</p><p>因为G1 GC是启发式算法，会动态调整年轻代的空间大小。目标也就是为了达到接近预期的暂停时间。年轻代调优中比较重要的就是对暂停时间的处理。一般都是根据MaxGCPauseMillis以及年轻代占比G1NewSizePercent、G1MaxNewSizePercent，结合应用的特点和GC数据进行接近期望pause time的调整。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">26.139</span>: [GC <span class="title function_">pause</span> <span class="params">(G1 Evacuation Pause)</span> (young) <span class="number">26.139</span>: [G1Ergonomics (CSet Construction) start choosing CSet, _pending_cards: <span class="number">3484</span>, predicted base time: <span class="number">5.51</span> ms, remaining time: <span class="number">194.49</span> ms, target pause time: <span class="number">200.00</span> ms]</span><br><span class="line"> <span class="number">26.139</span>: [G1Ergonomics (CSet Construction) add young regions to CSet, eden: <span class="number">54</span> regions, survivors: <span class="number">9</span> regions, predicted young region time: <span class="number">5.98</span> ms]</span><br><span class="line"> <span class="number">26.139</span>: [G1Ergonomics (CSet Construction) finish choosing CSet, eden: <span class="number">54</span> regions, survivors: <span class="number">9</span> regions, old: <span class="number">0</span> regions, predicted pause time: <span class="number">11.49</span> ms, target pause time: <span class="number">200.00</span> ms]</span><br><span class="line">, <span class="number">0.0163685</span> secs]</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>target也即目标是200ms,实际的pause time是16ms。远远小于目标暂停时间。并且再CSet中的分区数是“eden: 54 regions, survivors: 9 regions”，可以适当增加CSet中的年轻代分区,也可以适当缩短暂停时间，让实际值和期望值不断接近。</p></blockquote><h2 id="推荐配置"><a href="#推荐配置" class="headerlink" title="推荐配置"></a>推荐配置</h2><p>JVM推荐配置原则：</p><blockquote><ol><li>应用程序运行时，计算老年代存活对象的占用空间大小X。程序整个堆大小（Xmx和Xms）设置为X的3 ~ 4倍；永久代PermSize和MaxPermSize设置为X的1.2 ~ 1.5倍。年轻代Xmn的设置为X的1 ~ 1.5倍。老年代内存大小设置为X的2 ~ 3倍。</li><li>JDK官方建议年轻代占整个堆大小空间的3&#x2F;8左右。</li><li>完成一次Full GC后，应该释放出70%的堆空间（30%的空间仍然占用）。</li></ol></blockquote><h1 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h1><blockquote><p>部署上线的应用，密码在配置文件中明文，这样是极为不安全的，所以我们需要对密码进行加密处理</p></blockquote><p>我们使用<code>jasypt</code>来对application.properties配置文件中的mysql账号和密码进行加密</p><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ulisesbocchio<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jasypt-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>将字符串进行加密</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mszlu.xt.web.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.jasypt.util.text.BasicTextEncryptor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestEncode</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BasicTextEncryptor</span> <span class="variable">textEncryptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BasicTextEncryptor</span>();</span><br><span class="line">        <span class="comment">//加密所需的salt(盐)</span></span><br><span class="line">        textEncryptor.setPassword(<span class="string">&quot;mszlu&quot;</span>);</span><br><span class="line">        <span class="comment">//要加密的数据（数据库的用户名或密码）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> textEncryptor.encrypt(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> textEncryptor.encrypt(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;username:&#123;&#125;&quot;</span>,username);</span><br><span class="line">        log.info(<span class="string">&quot;password:&#123;&#125;&quot;</span>,password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>替换配置文件中数据库账号密码的部分</p></li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#数据库配置</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/xt?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">ENC(PmgAc8SnQp2AWWI7l2I78w==)</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">ENC(wkYb0BqIvK/hArr5it/lDg==)</span></span><br></pre></td></tr></table></figure><ol start="4"><li>运行jar的时候，外部指定加密盐</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar -Djasypt.encryptor.password=mszlu xx.jar</span><br></pre></td></tr></table></figure><blockquote><p>上线前准备已经做完，可以开始上线了</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 编程基本功 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语法剖析</title>
      <link href="/2023/01/05/go%E8%AF%AD%E6%B3%95%E5%89%96%E6%9E%90/"/>
      <url>/2023/01/05/go%E8%AF%AD%E6%B3%95%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是go程序执行的入口？"><a href="#什么是go程序执行的入口？" class="headerlink" title="什么是go程序执行的入口？"></a>什么是go程序执行的入口？</h2><p>runtime包里面的函数（rt0_windows）</p><p>是程序员的运行编译环境 JVM就是java的runtime</p><p>初始化g0协程栈 是go代码的第一个协程</p><p>go启动新的协程调用的是底层的new proc 创建一个新的协程去执行runtime.main 放入调度器等待调度</p><p>初始化一个M，用来调度主协程</p><p>go的启动像是一个框架 go允许oo编程 <strong>但是缺乏继承结构 go的继承只是组合</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Id         <span class="type">int64</span>             <span class="string">`form:&quot;id&quot; binding:&quot;required&quot;`</span></span><br><span class="line">Name       <span class="type">string</span>            <span class="string">`form:&quot;name&quot;`</span></span><br><span class="line">Address    []<span class="type">string</span>          <span class="string">`form:&quot;address&quot;`</span></span><br><span class="line">AddressMap <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> <span class="string">`form:&quot;addressMap&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">User</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span></span> walk() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;walk&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p := People&#123;&#125;</span><br><span class="line"><span class="comment">// 匿名字段的语法糖</span></span><br><span class="line">p.walk()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>go的接口是隐式的（把接口的全部方法都实现就会接口）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> alive <span class="keyword">interface</span> &#123;</span><br><span class="line">walk()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Id         <span class="type">int64</span>             <span class="string">`form:&quot;id&quot; binding:&quot;required&quot;`</span></span><br><span class="line">Name       <span class="type">string</span>            <span class="string">`form:&quot;name&quot;`</span></span><br><span class="line">Address    []<span class="type">string</span>          <span class="string">`form:&quot;address&quot;`</span></span><br><span class="line">AddressMap <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> <span class="string">`form:&quot;addressMap&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span></span> walk() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;walk&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="go的高并发下的数据结构"><a href="#go的高并发下的数据结构" class="headerlink" title="go的高并发下的数据结构"></a>go的高并发下的数据结构</h2><h3 id="空结构体"><a href="#空结构体" class="headerlink" title="空结构体"></a>空结构体</h3><p>int的大小是跟随系统字长的</p><p>指针的大小也是跟随系统长度的</p><p>空结构体只有地址 没有长度（Zero Peace）为了节约内存 <strong>map channel</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m := map[string]struct&#123;&#125;&#123;&#125;</span><br><span class="line">m[&quot;a&quot;] = struct&#123;&#125;&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串本身是结构体 Data指针指向底层的Byte数组</p><p>遍历字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = string([]rune(s)[:3])</span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>go使用拉链法实现hashmap 每个桶中存储哈希的前八位</p><p>超出8个数据 就会存储到溢出桶里面</p><h3 id="map的扩容"><a href="#map的扩容" class="headerlink" title="map的扩容"></a>map的扩容</h3><p>map的溢出桶太多时会导致严重的性能下降</p><p>runtime.mapassign()可能会触发扩容的情况 装载因子超过6.5</p><p>转载系数或者溢出桶的增加，会触发map的扩容 扩容并不是增加桶数，而是整理</p><h3 id="map的并发问题"><a href="#map的并发问题" class="headerlink" title="map的并发问题"></a>map的并发问题</h3><p>sync.Map使用了两个Map，分离了扩容的问题</p><p>不会引发扩容（查改）的操作使用read map</p><p>可能引发扩容(新增)的操作使用dirty map</p><h3 id="GO隐式接口的特点"><a href="#GO隐式接口的特点" class="headerlink" title="GO隐式接口的特点"></a>GO隐式接口的特点</h3><table><thead><tr><th></th><th>结构体实现接口</th><th>结构体指针实现接口</th></tr></thead><tbody><tr><td>结构体初始化变量</td><td>通过</td><td>不通过</td></tr><tr><td>结构体指针初始化变量</td><td>通过</td><td>通过</td></tr></tbody></table><p>go和java的区别：<strong>隐式接口</strong>，接口体实现接口，会帮着多实现一个结构体指针实现接口的方法</p><p>结构体实现接口，结构体和结构体指针初始化变量都是可以通过的；</p><p>结构体指针实现接口，结构体初始化变量不通过</p><h3 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h3><p>空接口就是runtime.eface的结构体（数据类型 数据本身省略了很多信息）</p><h3 id="nil和空接口-空结构体的区别和联系"><a href="#nil和空接口-空结构体的区别和联系" class="headerlink" title="nil和空接口 空结构体的区别和联系"></a>nil和空接口 空结构体的区别和联系</h3><p>nil 就是变量名 是空 有类型 是6种类型的“零值”</p><p>空结构体的指针不是nil 但是都相同是（zerobase）</p><p>空接口不一定是nil接口 只有两个属性都是nil才是nil接口</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自研高性能网关-技术选型-架构设计</title>
      <link href="/2022/12/20/%E8%87%AA%E7%A0%94%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E5%85%B3-%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2022/12/20/%E8%87%AA%E7%A0%94%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E5%85%B3-%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="自研API网关"><a href="#自研API网关" class="headerlink" title="自研API网关"></a>自研API网关</h1><p>API网关主要的作用有：接口转发、协议转换（http-&gt;dubbo）熔断降级、流量监控。</p><p>API网关的存在使系统增加了一个<strong>必须开发、部署和维护的高可用组件</strong>。如果这个组件没有处理好，那么 API 网关就会变成了应用的性能瓶颈。</p><h2 id="技术栈调研"><a href="#技术栈调研" class="headerlink" title="技术栈调研"></a>技术栈调研</h2><h3 id="细节对比"><a href="#细节对比" class="headerlink" title="细节对比"></a>细节对比</h3><img src="/2022/12/20/%E8%87%AA%E7%A0%94%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E5%85%B3-%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230802213127151.png" class="" title="image-20230802213127151"><table><thead><tr><th>技术栈</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>Nginx+OpenResty</td><td>性能很好</td><td>依赖lua语言进行扩展，加大学习成本</td></tr><tr><td>Kong&#x2F;APISIX</td><td>基于OpenResty，提供负载均衡、动态上游、灰度发布、服务熔断、身份认证、可视化平台等，支持gRPC、Dubbo、http协议转换</td><td></td></tr><tr><td>Netflix Zuul1.0</td><td>案例丰富</td><td>基于阻塞IO、性能差</td></tr><tr><td>SpringCloud GateWay</td><td>异步非阻塞、集成SpringCloud性能好</td><td></td></tr><tr><td>Netfix Zuul1.0</td><td>性能接近SpringCloud GateWay</td><td>Netfix闭源，前景不明</td></tr></tbody></table><h3 id="开源网关的不足之处"><a href="#开源网关的不足之处" class="headerlink" title="开源网关的不足之处"></a>开源网关的不足之处</h3><p>组件的附加功能太多-难以维护</p><p>技术栈不符合团队</p><p>性能参差不齐 Zuul1.0阻塞 APISIXluna语言编写</p><h3 id="自研优势"><a href="#自研优势" class="headerlink" title="自研优势"></a>自研优势</h3><p>因需制宜</p><p>研发需求是可以控制的 开源的需要去社区</p><p>运维成本低，不需要配备专职人员</p><img src="/2022/12/20/%E8%87%AA%E7%A0%94%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E5%85%B3-%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/image-20230802214050097.png" class="" title="image-20230802214050097"><p>技术选型：</p><p>基础框架：SpringMVC SpringBoot <strong>原生java</strong></p><p>网络通信框架：原生nio Mina <strong>Netty</strong></p><p>注册中心: Zookeeper(注重数据一致性 不注重可用性) Euraka（SpringCloud） Etcd（通用 没有明显的优势） <strong>Nacos</strong></p><p>配置中心：SpringCloud Apollo <strong>Nacos</strong></p><p>关键点：</p><p>异步化设计：</p><p>​1.请求转发异步化</p><p>​2.请求响应异步化（双异步）</p><p>​3.插件过滤异步化（单异步）</p><p>充分使用缓存：</p><p>​用尽缓存：尽量使用内存</p><p>​提供吞吐量：本地缓冲、Disruptor、MPMC</p><p>设置合适的工作线程</p><p>本项目在进行过程中，发现了一些其他的问题所以目前将本项目搁置，优先完成go-redis的项目。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 网关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题日记记第一阶段</title>
      <link href="/2022/11/29/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/"/>
      <url>/2022/11/29/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/</url>
      
        <content type="html"><![CDATA[<p>记录我刷题的笔记，从2022年11月29日开始，到2023年5月12日，第一阶段。</p><table><thead><tr><th>日期</th><th>hpy</th><th>我</th><th>差值</th></tr></thead><tbody><tr><td>2022年11月29日</td><td>591</td><td>348</td><td>243</td></tr><tr><td>2022年12月11日</td><td>618</td><td>388</td><td>230</td></tr><tr><td>2022年12月26日</td><td>639</td><td>430</td><td>209</td></tr><tr><td>2023年1月6日</td><td>652</td><td>453</td><td>199</td></tr><tr><td>2023年1月10日</td><td>666</td><td>475</td><td>191</td></tr><tr><td>2023年1月16日</td><td>677</td><td>510</td><td>167</td></tr><tr><td>2023年1月17日</td><td>678</td><td>518</td><td>160</td></tr><tr><td>2023年1月22日</td><td>693</td><td>535</td><td>158</td></tr><tr><td>2023年1月25日</td><td>700</td><td>550</td><td>150</td></tr><tr><td>2023年1月29日</td><td>707</td><td>563</td><td>144</td></tr><tr><td>2023年1月30日</td><td>708</td><td>568</td><td>140</td></tr><tr><td>2023年1月31日</td><td>709</td><td>571</td><td>138</td></tr><tr><td>2023年2月2日</td><td>715</td><td>580</td><td>135</td></tr><tr><td>2023年2月16日</td><td>750</td><td>622</td><td>128</td></tr><tr><td>2023年3月5日</td><td>774</td><td>646</td><td>128</td></tr><tr><td>2023年3月12日</td><td>779</td><td>656</td><td>123</td></tr><tr><td>2023年4月6日</td><td>812</td><td>680</td><td>132</td></tr><tr><td>2023年4月15日</td><td>817</td><td>696</td><td>121</td></tr><tr><td>2023年5月12日</td><td>835</td><td>769</td><td>66</td></tr><tr><td>2023年5月28日</td><td>842</td><td>812</td><td>30</td></tr><tr><td>2023年7月4日</td><td></td><td>872</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="每日一题"><a href="#每日一题" class="headerlink" title="每日一题"></a>每日一题</h3><p>2022年11月21日</p><p>\808. 分汤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, <span class="type">int</span>[]&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;()&#123;&#123;</span><br><span class="line">        put(<span class="number">1</span>,  <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">100</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        put(<span class="number">2</span>,  <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">75</span>, <span class="number">25</span>&#125;);</span><br><span class="line">        put(<span class="number">3</span>,  <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">50</span>, <span class="number">50</span>&#125;);</span><br><span class="line">        put(<span class="number">4</span>,  <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">25</span>, <span class="number">75</span>&#125;);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">soupServings</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &gt;= <span class="number">4451</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> dp[][] = <span class="keyword">new</span> <span class="title class_">double</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0.5</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++)&#123;</span><br><span class="line">                    <span class="type">int</span>[] choice = map.get(i);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Math.max(j - choice[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Math.max(k - choice[<span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">                    dp[j][k] += <span class="number">0.25</span> * dp[a][b];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>\878. 第 N 个神奇数字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nthMagicalNumber</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">long</span>)<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = (<span class="type">long</span>)Math.min(a,b)*n;</span><br><span class="line">        <span class="comment">// System.out.println(right);</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">lc</span> <span class="operator">=</span> lcm(a,b);</span><br><span class="line">        <span class="comment">// System.out.println(lc);</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid / a + mid / b - mid / lc &gt;= n) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(left%MOD);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求最小公倍数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">lcm</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a / gcd(a,b) * b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 辗转相除法 求a b最大公因数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b &gt; <span class="number">0</span> ? gcd(b,a % b):a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>\795. 区间子数组个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSubarrayBoundedMax</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] l = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">10</span>], r = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">10</span>];</span><br><span class="line">        Arrays.fill(l, -<span class="number">1</span>); Arrays.fill(r, n);</span><br><span class="line">        Deque&lt;Integer&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            <span class="keyword">while</span> (!d.isEmpty() &amp;&amp; nums[d.peekLast()] &lt; nums[i]) r[d.pollLast()] = i;</span><br><span class="line">            d.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        d.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!d.isEmpty() &amp;&amp; nums[d.peekLast()] &lt;= nums[i]) l[d.pollLast()] = i;</span><br><span class="line">            d.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; a || nums[i] &gt; b) <span class="keyword">continue</span>;</span><br><span class="line">            ans += (i - l[i]) * (r[i] - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：宫水三叶</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/solutions/1988320/by-ac_oier-gmpt/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>6.Z字形变换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">convert</span><span class="params">(String s, <span class="type">int</span> numRows)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (numRows&lt;<span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        List&lt;StringBuilder&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;numRows;i++) &#123;</span><br><span class="line">            <span class="comment">// 这样写 才对 这个是要学习的</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;s.length();j++) &#123;</span><br><span class="line">            res.get(i).append(s.charAt(j));</span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">0</span>||i==numRows-<span class="number">1</span>) flag = -flag;</span><br><span class="line">            i+=flag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;res.size();j++) sb.append(res.get(j).toString());</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最大波动的字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestVariance</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>  s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> i=<span class="string">&#x27;a&#x27;</span>;i&lt;=<span class="string">&#x27;z&#x27;</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> j=<span class="string">&#x27;a&#x27;</span>;j&lt;=<span class="string">&#x27;z&#x27;</span>;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i==j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">diffWithJ</span> <span class="operator">=</span> -n;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++) &#123;</span><br><span class="line">                    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(k);</span><br><span class="line">                    <span class="keyword">if</span> (c==i) &#123;</span><br><span class="line">                        diff++;</span><br><span class="line">                        diffWithJ++;</span><br><span class="line">                    &#125;   <span class="keyword">else</span> <span class="keyword">if</span> (c==j) &#123;</span><br><span class="line">                        diffWithJ = --diff;</span><br><span class="line">                        diff = Math.max(<span class="number">0</span>,diff);</span><br><span class="line">                    &#125;</span><br><span class="line">                    res = Math.max(res,diffWithJ);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>O(n)代表最差的情况是n次常数项的操作</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>\71. 简化路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">simplifyPath</span><span class="params">(String path)</span> &#123;</span><br><span class="line">        LinkedList&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> path.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;n&amp;&amp;path.charAt(i)==<span class="string">&#x27;/&#x27;</span>) i++;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;n&amp;&amp;path.charAt(j)!=<span class="string">&#x27;/&#x27;</span>) j++;</span><br><span class="line">            <span class="comment">// System.out.println(path+&quot; &quot;+i+&quot; &quot;+j);</span></span><br><span class="line">            <span class="keyword">if</span> (i==n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> path.substring(i,j);</span><br><span class="line">            <span class="comment">// System.out.println(str);</span></span><br><span class="line">            <span class="keyword">if</span> (str.equals(<span class="string">&quot;..&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!stack.isEmpty()) stack.removeLast();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!str.equals(<span class="string">&quot;.&quot;</span>)) &#123;</span><br><span class="line">                stack.add(str);</span><br><span class="line">            &#125;</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;/&quot;</span>+stack.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.length()==<span class="number">0</span>?<span class="string">&quot;/&quot;</span>:sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p>面试题 01.05. 一次编辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">oneEditAway</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length(), m = b.length();</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(n - m) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 这里写的是真的精彩</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt; m) <span class="keyword">return</span> oneEditAway(b, a);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 几种情况都概括了</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m &amp;&amp; cnt &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> a.charAt(i), c2 = b.charAt(j);</span><br><span class="line">            <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">                i++; j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (n == m) &#123;</span><br><span class="line">                    i++; j++; cnt++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    j++; cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>\1574. 删除最短的子数组使剩余数组有序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLengthOfShortestSubarray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left + <span class="number">1</span> &lt; n &amp;&amp; arr[left] &lt;= arr[left+<span class="number">1</span>]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// [0...left]有序</span></span><br><span class="line">        <span class="keyword">if</span> (left == n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// [right...n-1]有序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &gt; <span class="number">0</span> &amp;&amp; arr[right - <span class="number">1</span>] &lt;= arr[right]) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 完全删除一边[left+1, n-1], 或者[0...right - 1]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Math.min(n - left - <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左边和右边各保留一部分</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = right;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (i &lt;= left &amp;&amp; j &lt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">                <span class="comment">// [0...i] 和 [j...n-1] 有序, 删除 [i+1...j-1]</span></span><br><span class="line">                result = Math.min(result, j - i - <span class="number">1</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 小的+1</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>int 无符号整型有32位</p><p>1.<strong>a^b</strong>表示a和b异或，可以理解为无进位相加，</p><p>满足以下的三个定律 交换律 结合律 还有本身异或等于0 这三个定律</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">   <span class="comment">// 如果 a 和 b相等的话 int a = 0;b = b;</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> a^b;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a^b;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> a^b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2272 但是在数组进行交换的时候 ，如果i和j的下标一样的话 就会出现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        swap(arr,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        Arrays.stream(arr).forEach(System.out::println);</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 最后的交换的会成为0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> i,<span class="type">int</span> j)</span> &#123;</span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">        arr[j] = arr[i] ^ arr[j];</span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>2.**b&amp;(~b+1)**表示的是取出最右边的二进制为1的数 **b&amp;-b **   <strong>b&amp;-b&#x3D;b判断是不是二的幂</strong></p><p>面试题 05.01. 插入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insertBits</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> M, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="comment">//left in (,j+1];middle in [i,j];right in [i-1,0];</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> N&gt;&gt;j&gt;&gt;<span class="number">1</span>; <span class="comment">//把最左边的部分调整好了，即抛弃了替换部分和低位部分</span></span><br><span class="line">        left = left&lt;&lt;j&lt;&lt;<span class="number">1</span>;  <span class="comment">//因此最后要进行或运算，所以把他再移到原来的高位上。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> M&lt;&lt;i;  <span class="comment">//替换N的j&lt;-----i位，那么只需要将M左移i位即可</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> N&amp;((<span class="number">1</span>&lt;&lt;i)-<span class="number">1</span>);<span class="comment">//只需要N的低位，将高位置零,(1&lt;&lt;2)-1 = (11)2</span></span><br><span class="line">        <span class="keyword">return</span> left | middle | right;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>最低位的0变成1是nums|(nums+1)</strong></p><p><strong>最低位的1变成0是nums&amp;(nums-1)</strong></p><p><strong>Integer.bitCount()是计算位数的</strong></p><p><strong>num&amp;-num是lowbit</strong></p><p>题目：给定两个有符号32位整数，返回比较大的数字（不允许使用判断）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">flip</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n^<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// n是非负数返回1</span></span><br><span class="line">    <span class="comment">// n是负数返回0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sigh</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> flip((n&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a-b;</span><br><span class="line">        <span class="comment">// a 大 scA=1 else scB = 1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">scA</span> <span class="operator">=</span>sign(c);</span><br><span class="line">        <span class="type">int</span> <span class="variable">scB</span> <span class="operator">=</span> flip(scA);</span><br><span class="line">        <span class="keyword">return</span> a*scA+b*scB;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 可能会发生溢出的情况 所以还需要 优化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax2</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a-b;</span><br><span class="line">        <span class="comment">// a和b符号相同 a-b 就不会溢出</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sa</span> <span class="operator">=</span> sign(a);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sb</span> <span class="operator">=</span> sign(b);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sc</span> <span class="operator">=</span> sign(c);</span><br><span class="line">        <span class="type">int</span> <span class="variable">difSab</span> <span class="operator">=</span> sa^sb;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sameSab</span> <span class="operator">=</span> flip(difSab);</span><br><span class="line">        <span class="type">int</span> <span class="variable">returnA</span> <span class="operator">=</span> difSab*sa + sameSab*sc;</span><br><span class="line">        <span class="type">int</span> <span class="variable">returnB</span> <span class="operator">=</span> flip(returnA);</span><br><span class="line">        <span class="keyword">return</span> a*returnA + b*returnB</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>5.判断32位整型数是否二进制和四进制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二进制</span></span><br><span class="line">n&amp;(n-<span class="number">1</span>)==<span class="number">0</span><span class="comment">//打散之后 判断某位是不是只有1 是的话就是二进制</span></span><br><span class="line"><span class="comment">// 四进制</span></span><br><span class="line">偶数位是<span class="number">1</span></span><br><span class="line">(n&amp;(n-<span class="number">1</span>)==<span class="number">0</span>)&amp;&amp;(n&amp;<span class="number">0x55555555</span>)!=<span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><p>O（n^2）</p><p>选择排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">selection_sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.lenghth;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max_index</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j]&gt;max) &#123;</span><br><span class="line">                max = arr[j];</span><br><span class="line">                max_index = j;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr,i,max_index);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>冒泡排序bubble_sort</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bubble_sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=n-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入排序insertion_sort 插入排序是不稳定的 一直保证前i个是有序的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertion_sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>&amp;&amp;arr[j]&gt;arr[j+<span class="number">1</span>];j--) &#123;</span><br><span class="line">swap(arr,i,j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>O(n*logn)</p><p>排序的信息没有浪费所以成了 （n*logN）</p><p>归并排序-merge_sort-&gt;拓展（小和 逆序对）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge_sort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left==right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 这样比除2要快一些 以后都用这个</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right-left)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        merge_sort(arr,left,mid);</span><br><span class="line">        merge_sort(arr,mid+<span class="number">1</span>,right);</span><br><span class="line">        merge(arr,left,mid,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left==right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span>[] helper = <span class="keyword">new</span> <span class="title class_">int</span>[right-left+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> mid+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1&lt;=mid&amp;&amp;p2&lt;=right) &#123;</span><br><span class="line">            helper[i++] = arr[p1]&lt;arr[p2]?arr[p1++]:arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1&lt;=mid) &#123;</span><br><span class="line">            helper[i++] = arr[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2&lt;=right) &#123;</span><br><span class="line">            helper[i++] = arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;helper.length;i++) &#123;</span><br><span class="line">            arr[left+i] = helper[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>快速排序</p><p>O(n^2)最坏的情况</p><p>1.0</p><p>总拿最后一个数字做划分 然后再进行递归</p><p>2.0</p><p>一次搞定一批数 （划分点打到中点 是最好的情况）</p><p>快排3.0</p><p>随机打乱 每种情况占比1&#x2F;N 最后的算法复杂度求数学期望是O(N*logN)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left&lt;right) &#123;</span><br><span class="line">            <span class="comment">// 介绍:Math.random()是令系统随机选取大于等于 0.0 且小于 1.0 </span></span><br><span class="line">            <span class="comment">// 这样可以让时间复杂度的期望成为O(N*logN)</span></span><br><span class="line">            swap(arr,left+(<span class="type">int</span>)Math.random()*(right-left+<span class="number">1</span>),right);</span><br><span class="line">            <span class="type">int</span>[] p = patition(arr,left,right);</span><br><span class="line">            quick_sort(arr,left,p[<span class="number">0</span>]-<span class="number">1</span>);</span><br><span class="line">            quick_sort(arr,p[<span class="number">1</span>]+<span class="number">1</span>,right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 三色荷兰国旗问题 patition是分开的意思 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] patition(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">less</span> <span class="operator">=</span> left - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">more</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;more) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[left]&lt;arr[right]) &#123;</span><br><span class="line">                <span class="comment">// 这个数遇到了 在left之前的less 可能和target相等也可能小于 所以是可以直接去走的</span></span><br><span class="line">                swap(arr,++less,left++);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[left]&gt;arr[right]) &#123;</span><br><span class="line">                <span class="comment">// 这个数没有遇到过 所以说不会left++</span></span><br><span class="line">                swap(arr,--more,left);</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr,more,right);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;less+<span class="number">1</span>,more&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> i,<span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i==j) <span class="keyword">return</span>;</span><br><span class="line">        arr[i] = arr[i]^arr[j];</span><br><span class="line">        arr[j] = arr[i]^arr[j];</span><br><span class="line">        arr[i] = arr[i]^arr[j];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>堆排序heap_sort</strong></p><p>时间复杂度O(n*logn) 空间复杂度O(1);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heap_sort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr==<span class="literal">null</span>||arr.length&lt;<span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++) heapInsert(arr,i);</span><br><span class="line">        <span class="type">int</span> <span class="variable">heapSize</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        swap(arr,<span class="number">0</span>,--heapSize);</span><br><span class="line">        <span class="keyword">while</span> (heapSize&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            heapify(arr,<span class="number">0</span>,heapSize);</span><br><span class="line">            swap(arr,<span class="number">0</span>,--heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapInsert</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[index]&gt;arr[(index-<span class="number">1</span>)/<span class="number">2</span>]) &#123;</span><br><span class="line">            swap(arr,index,(index-<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">            index = (index-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> index,<span class="type">int</span> heapSize)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span>*index+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;heapSize) &#123;</span><br><span class="line">            <span class="comment">// 两个孩子中谁的数值大 谁赋值给largest</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> left+<span class="number">1</span>&lt;heapSize&amp;&amp;arr[left+<span class="number">1</span>]&gt;arr[left]?left+<span class="number">1</span>:left;</span><br><span class="line">            largest = arr[largest] &gt; arr[index] ? largest : index;</span><br><span class="line">            <span class="keyword">if</span> (largest==index) <span class="keyword">break</span>;</span><br><span class="line">            swap(arr,largest,index);</span><br><span class="line">            index = largest;</span><br><span class="line">            left = <span class="number">2</span>* index + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>基数排序</strong>-桶排序</p><p>桶可以是队列可以是栈 桶是容器  </p><h4 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h4><p>返回负数的时候，第一个参数排在前面</p><p>返回正数的时候，第二个参数排在前面</p><p>返回0的时候，无所谓</p><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>技巧：快慢指针和哈希表</p><p>两个链表找公共节点 一起走统计个数 然后去掉差（快的先走差值） 在一起走</p><p>找环的节点入口-》先快指针再快指针归位，一起走指针到达的就是入口；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快指针这么写更好</span></span><br><span class="line"><span class="keyword">while</span> (fast.next!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>反转链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：老汤</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/UHnkqh/solutions/941827/jian-dan-yi-dong-javac-pythonjs-dong-hua-gy6w/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>二分查找不一定要保持有序，局部最小值也是可以使用二分的。</p><p>解题思路：二分查找low_bound 【时间复杂度O(lgn),n是数组长度】</p><p><strong>峰值和mid的下一个比较</strong></p><p><strong>最小值和最后一个元素比较</strong></p><p>- 核心要素<br>    - 注意区间开闭，三种都可以<br>    - 循环结束条件：当前区间内没有元素<br>    - 下一次二分查找区间：不能再查找(区间不包含)mid，防止死循环<br>    - 返回值：大于等于target的第一个下标（注意循环不变量）</p><p>- 有序数组中二分查找的四种类型（下面的转换仅适用于数组中都是整数）<br>    \1. 第一个大于等于x的下标： low_bound(x)<br>    \2. 第一个大于x的下标：可以转换为<code>第一个大于等于 x+1 的下标</code> ，low_bound(x+1)<br>    \3. 最后一个一个小于x的下标：可以转换为<code>第一个大于等于 x 的下标</code> 的<code>左边位置</code>, low_bound(x) - 1;<br>    \4. 最后一个小于等于x的下标：可以转换为<code>第一个大于等于 x+1 的下标</code> 的 <code>左边位置</code>, low_bound(x+1) - 1;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">lowerBound</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> target)</span> &#123;</span><br><span class="line">      <span class="comment">// 主要看的是不变的量 不变的量就是区间外面的量</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length;</span><br><span class="line">      <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right-mid)/<span class="number">2</span>;</span><br><span class="line">          <span class="comment">// 这里的小于就是保证 left左边的数都比他要小</span></span><br><span class="line">          <span class="keyword">if</span> (arr[mid] &lt; left) &#123;</span><br><span class="line">              left = mid + <span class="number">1</span>;</span><br><span class="line">              <span class="comment">// 保证right右边的数都比他要大</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              right = mid;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> left;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>递归求数组的最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left==right) <span class="keyword">return</span> arr[left];</span><br><span class="line">        <span class="comment">// 这样比除2要快一些 以后都用这个</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right-left)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> dfs(arr,left,mid);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> dfs(arr,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftMax,rightMax);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>必须利用第三次到达节点做强整合的，递归套路是最优解</p><p>没有必要第三次到达节点的，Morris遍历是优解</p><p>二叉树的迭代遍历和递归遍历</p><p>前序遍历-》压栈先右后左</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrderUnRecur</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Node&gt;();</span><br><span class="line">    stack.add(head);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">poll</span> <span class="operator">=</span> stack.poll();</span><br><span class="line">        System,out.print(poll.value+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (head.right!=<span class="literal">null</span>) stack.push(head.right);</span><br><span class="line">        <span class="keyword">if</span> (head.left!=<span class="literal">null</span>) stack.push(head.left);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历-》一路左子树-》然后左子树为空-》右子树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断的条件写的特别有意思</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrderUnRecur</span><span class="params">(Node head)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (head!=<span class="literal">null</span>) &#123;</span><br><span class="line">        Stack&lt;Node&gt; srack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Node&gt;();</span><br><span class="line">        <span class="keyword">while</span> (stack!=<span class="literal">null</span>||head!=<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head!=<span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(head);</span><br><span class="line">                head = head.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                head = stack.pop();</span><br><span class="line">                System.out.println(head.value+<span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="comment">// 一到右边就开始往左</span></span><br><span class="line">                <span class="comment">// 一层一层左边的</span></span><br><span class="line">                head = head.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历-》压栈先左后右 使用一个栈倒序就可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrderUnRecur</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;Node&gt; s1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;Node&gt; s2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    s1.push(head);</span><br><span class="line">    <span class="keyword">while</span> (!s1.isEmpty()) &#123;</span><br><span class="line">        head = s1.pop();</span><br><span class="line">        s2.push(head);</span><br><span class="line">        <span class="keyword">if</span> (head.left!=<span class="literal">null</span>) s1.push(head.left);</span><br><span class="line">        <span class="keyword">if</span> (head.right!=<span class="literal">null</span>) s1.push(head.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!s2.isEmpty()) &#123;</span><br><span class="line">        Sout(s2.pop().value+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>层序遍历</p><p>层序遍历 统计每层的个数</p><p>Morris遍历-》O(N)时间复杂度 O(1)空间复杂度</p><p>Morris遍历 有的节点会被遍历两次 有的节点会被遍历一次 打印遍历的第一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">morris</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">mostRight</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="literal">null</span>) &#123;</span><br><span class="line">            mostRight = cur.left;</span><br><span class="line">            <span class="comment">// 没有左子树也是直接往右走</span></span><br><span class="line">            <span class="keyword">if</span> (mostRight!=<span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 1.第一次遍历到空节点 2.第二次遍历到head节点</span></span><br><span class="line">                <span class="keyword">while</span>(mostRight.right!=<span class="literal">null</span>&amp;&amp;mostRight.right!=cur) &#123;</span><br><span class="line">                    mostRight = mostRight.right;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">// mos</span></span><br><span class="line">                <span class="comment">// 如果是第一次遍历到 往左边走</span></span><br><span class="line">                <span class="keyword">if</span> (mostRight.right==<span class="literal">null</span>) &#123;</span><br><span class="line">                    mostRight.right = cur;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mostRight.right = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第二次遍历就走右边</span></span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Morris的前序遍历的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">morris</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">mostRight</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="literal">null</span>) &#123;</span><br><span class="line">            mostRight = cur.left;</span><br><span class="line">            <span class="comment">// 没有左子树也是直接往右走</span></span><br><span class="line">            <span class="keyword">if</span> (mostRight!=<span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 1.第一次遍历到空节点 2.第二次遍历到head节点</span></span><br><span class="line">                <span class="keyword">while</span>(mostRight.right!=<span class="literal">null</span>&amp;&amp;mostRight.right!=cur) &#123;</span><br><span class="line">                    mostRight = mostRight.right;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">// mos</span></span><br><span class="line">                <span class="comment">// 如果是第一次遍历到 往左边走</span></span><br><span class="line">                <span class="keyword">if</span> (mostRight.right==<span class="literal">null</span>) &#123;</span><br><span class="line">                    System.out.println(cur.val);</span><br><span class="line">                    mostRight.right = cur;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mostRight.right = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(cur.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第二次遍历就走右边</span></span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Morris遍历的中序遍历：（只遍历一次的节点 直接打印 遍历两次的节点 第二次打印）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">morris</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">mostRight</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="literal">null</span>) &#123;</span><br><span class="line">            mostRight = cur.left;</span><br><span class="line">            <span class="comment">// 没有左子树也是直接往右走</span></span><br><span class="line">            <span class="keyword">if</span> (mostRight!=<span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 1.第一次遍历到空节点 2.第二次遍历到head节点</span></span><br><span class="line">                <span class="keyword">while</span>(mostRight.right!=<span class="literal">null</span>&amp;&amp;mostRight.right!=cur) &#123;</span><br><span class="line">                    mostRight = mostRight.right;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">// mos</span></span><br><span class="line">                <span class="comment">// 如果是第一次遍历到 往左边走</span></span><br><span class="line">                <span class="keyword">if</span> (mostRight.right==<span class="literal">null</span>) &#123;</span><br><span class="line">                    mostRight.right = cur;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// System.out.println(cur.val);</span></span><br><span class="line">                    mostRight.right = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 如果没有左树，continue 跳不过去这边的打印 所以在下面直接打印即可</span></span><br><span class="line">            System.out.println(cur.val);</span><br><span class="line">            <span class="comment">// 第二次遍历就走右边</span></span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>morris遍历的后序遍历-》(第二次回到节点 逆序打印左子树的右边界-最后结束的时候逆序打印整棵树的右边界)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">morris</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">mostRight</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="literal">null</span>) &#123;</span><br><span class="line">            mostRight = cur.left;</span><br><span class="line">            <span class="comment">// 没有左子树也是直接往右走</span></span><br><span class="line">            <span class="keyword">if</span> (mostRight!=<span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 1.第一次遍历到空节点 2.第二次遍历到head节点</span></span><br><span class="line">                <span class="keyword">while</span>(mostRight.right!=<span class="literal">null</span>&amp;&amp;mostRight.right!=cur) &#123;</span><br><span class="line">                    mostRight = mostRight.right;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">// mos</span></span><br><span class="line">                <span class="comment">// 如果是第一次遍历到 往左边走</span></span><br><span class="line">                <span class="keyword">if</span> (mostRight.right==<span class="literal">null</span>) &#123;</span><br><span class="line">                    mostRight.right = cur;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// System.out.println(cur.val);</span></span><br><span class="line">                    printReverse(cur.left);</span><br><span class="line">                    mostRight.right = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 最后继续逆序打印整棵树的右边界</span></span><br><span class="line">            printReverse(head);</span><br><span class="line">            <span class="comment">// 第二次遍历就走右边</span></span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>二叉搜索树的中继遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">inorderSuccessor</span><span class="params">(TreeNode root, TreeNode p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">null</span>||root==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.val&lt;=p.val)&#123;<span class="comment">//当前和左边都不可能&gt;p</span></span><br><span class="line">        <span class="keyword">return</span> inorderSuccessor(root.right,p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//root&gt;p</span></span><br><span class="line">    TreeNode res1=inorderSuccessor(root.left,p);</span><br><span class="line">    <span class="keyword">if</span>(res1!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res1;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二叉搜索树的中继遍历2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node parent;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">inorderSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> getLeftMost(node.right);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> node.parent;</span><br><span class="line">            <span class="keyword">while</span>(parent!=<span class="literal">null</span>&amp;&amp;parent.left!=node) &#123;</span><br><span class="line">                node = parent;</span><br><span class="line">                parent = node.parent;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">return</span> parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">getLeftMost</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (node.left!=<span class="literal">null</span>) &#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二叉树的序列化和反序列化：</p><p>树转化为字符串叫序列化，字符串转化为树叫做反序列化。</p><p><strong>完全二叉树的节点个数</strong></p><p>时间复杂度O(lognlogn)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;<span class="comment">//计算某个点的子总数</span></span><br><span class="line">        <span class="keyword">return</span> count(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 主要注意一下是从这里开始的</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> root,rightNode = root;</span><br><span class="line">        <span class="keyword">while</span> (leftNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            left++;</span><br><span class="line">            leftNode = leftNode.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (rightNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            right++;</span><br><span class="line">            rightNode = rightNode.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left==right) <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">2</span>,left) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> count(root.left)+count(root.right)+<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h4><p>向左树要信息和向右树要信息</p><p>题目： 判断树是否是二叉搜索树 中序遍历来判断 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int min = Integer.MAX_VALUE;</span></span><br><span class="line"><span class="comment">// int max = Integer.MIN_VALUE;</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">//左子树的最大值小于中间节点 右子树的最小值大于中间节点 左子树和右子树是二叉搜索树</span></span><br><span class="line">    <span class="keyword">return</span> dfs(root).isBST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Info <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Info</span> <span class="variable">LeftInfo</span> <span class="operator">=</span> dfs(root.left);</span><br><span class="line">    <span class="type">Info</span> <span class="variable">RightInfo</span> <span class="operator">=</span> dfs(root.right);</span><br><span class="line">    <span class="comment">/// 左边最大的</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> root.val;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> root.val;</span><br><span class="line">    <span class="keyword">if</span> (LeftInfo!=<span class="literal">null</span>) &#123;</span><br><span class="line">        max = Math.max(max,LeftInfo.max);</span><br><span class="line">        min = Math.min(min,LeftInfo.min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (RightInfo!=<span class="literal">null</span>) &#123;</span><br><span class="line">        max = Math.max(max,RightInfo.max);</span><br><span class="line">        min = Math.min(min,RightInfo.min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isBST</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (LeftInfo!=<span class="literal">null</span>&amp;&amp;(!LeftInfo.isBST||LeftInfo.max&gt;=root.val)) &#123;</span><br><span class="line">        isBST = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (RightInfo!=<span class="literal">null</span>&amp;&amp;(!RightInfo.isBST||root.val&gt;=RightInfo.min)) &#123;</span><br><span class="line">        isBST = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// System.out.println(&quot;max==&quot;+max+&quot;min==&quot;+min+&quot;isBst==&quot;+isBST);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(max,min,isBST);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    <span class="type">int</span> min;</span><br><span class="line">    <span class="type">boolean</span> isBST;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Info</span><span class="params">(<span class="type">int</span> max,<span class="type">int</span> min,<span class="type">boolean</span> isBST)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.max = max;</span><br><span class="line">        <span class="built_in">this</span>.min = min;</span><br><span class="line">        <span class="built_in">this</span>.isBST = isBST;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>平衡树  左子树平衡 右子树平衡 并且高度差不为1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> dfs(root).isBalance;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> Info <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(<span class="number">0</span>,<span class="literal">true</span>);</span><br><span class="line">       <span class="type">Info</span> <span class="variable">leftInfo</span> <span class="operator">=</span> dfs(root.left);</span><br><span class="line">       <span class="type">Info</span> <span class="variable">RightInfo</span> <span class="operator">=</span> dfs(root.right);</span><br><span class="line">       <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> Math.max(leftInfo.height,RightInfo.height)+<span class="number">1</span>;</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">isBalance</span> <span class="operator">=</span> leftInfo.isBalance&amp;&amp;RightInfo.isBalance&amp;&amp;Math.abs(leftInfo.height-RightInfo.height)&lt;<span class="number">2</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(height,isBalance);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">       <span class="type">int</span> height;</span><br><span class="line">       <span class="type">boolean</span> isBalance;</span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">Info</span><span class="params">(<span class="type">int</span> height,<span class="type">boolean</span> isBalance)</span> &#123;</span><br><span class="line">           <span class="built_in">this</span>.height = height;</span><br><span class="line">           <span class="built_in">this</span>.isBalance = isBalance;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>完全树：遇到左节点为存在右节点不存在的情况下其他的节点都应该是叶子节点</p><h4 id="dfs-记忆化搜索-dp动态规划"><a href="#dfs-记忆化搜索-dp动态规划" class="headerlink" title="dfs-&gt;记忆化搜索-&gt;dp动态规划"></a>dfs-&gt;记忆化搜索-&gt;dp动态规划</h4><p>例题</p><h4 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h4><p>比较字典序：给一个字符串数组 返回最小的字典序 比较（a+b）和（b+a）的字典序 不是去比较a和b的字典序</p><p>会议安排：结束时间先结束的优先安排</p><p>贪心策略最常用的就是 堆和排序 哈夫曼编码问题</p><p>花费项目-》大小根堆</p><p>大根堆：每一棵树最大的值都是头节点的数值，</p><p>小根堆：每一棵树最小的值都是根节点的数值</p><p><strong>自顶向下</strong>：直接<code>return 函数调用自身下一级实现</code>，比如 <code>return Fibonacci(n-1) + Fibonacci(n-2);</code><br><strong>自底向上</strong>：先递归到最小单位(<strong>叶子节点</strong>)，再从最小单位往上抛结果，传递结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 两种遍历方向，计算最大深度</span></span><br><span class="line"><span class="comment"> * 自顶向下</span></span><br><span class="line"><span class="comment"> * 自底向上</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">_11_10_Top_Down</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自顶向下</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> answer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">maximum_depth</span><span class="params">(TreeNode root, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            answer = Math.max(answer, depth);</span><br><span class="line">        &#125;</span><br><span class="line">        maximum_depth(root.left, depth + <span class="number">1</span>);</span><br><span class="line">        maximum_depth(root.right, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自底向上</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximum_depth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//感受一下这里是将最底层的结果往上抛</span></span><br><span class="line">        <span class="comment">//，因为这里的递归边界条件是叶子节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left_depth</span> <span class="operator">=</span> maximum_depth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right_depth</span> <span class="operator">=</span> maximum_depth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left_depth, right_depth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * LettCode中的题：</span></span><br><span class="line"><span class="comment"> * 235. 二叉搜索树的最近公共祖先</span></span><br><span class="line"><span class="comment"> * 236. 二叉树的最近公共祖先</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//搜索二叉树直接可以分为比大小，定位</span></span><br><span class="line">    <span class="comment">//分为都在左子树、都在右子树、两边(root)</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor235</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(p.val&lt;root.val &amp;&amp; q.val&lt;root.val)&#123;</span><br><span class="line">        <span class="comment">//这里就是自顶向下</span></span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor235(root.left,p,q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p.val&gt;root.val &amp;&amp; q.val&gt;root.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor235(root.right,p,q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归自底向上，讨论子树中是否含有某个节点</span></span><br><span class="line">    <span class="comment">// 如果分别在左右子树，则返回跟节点</span></span><br><span class="line">    <span class="comment">// 如果在同一个子树继续往下递归</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span> ||root==p || root==q)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//着也是自底向上的思想</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">            <span class="keyword">if</span>(left==<span class="literal">null</span> &amp;&amp; right==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(left==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(right==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>今天又忘记了 求最大公因数应该是<strong>gcd(b,a % b):a</strong>，有一点要注意的是**(long)Math.min(a,b)<em>n</em>*;</p><p>复习了一下二分法 ，求左侧边界。</p><p><a href="https://www.bilibili.com/video/BV1AP41137w7/?vd_source=b16bc6370b4580d541ef490d09f1b6aa">二分查找又死循环了？一个视频讲透二分本质！【基础算法精讲 04】循环不变量 在排序数组中查找元素的第一个和最后一个位置 | 力扣 LeetCode 高频面试题_哔哩哔哩_bilibili</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">left_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length; <span class="comment">// 注意</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 注意</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid; <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>求右侧边界：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">right_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>：首先，while 循环的终止条件是 <code>left == right</code>，所以 <code>left</code> 和 <code>right</code> 是一样的，你非要体现右侧的特点，返回 <code>right - 1</code> 好了。</p><p>至于为什么要减一，这是搜索右侧边界的一个特殊点，关键在锁定右边界时的这个条件判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增大 left，锁定右侧边界</span></span><br><span class="line"><span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 这样想: mid = left - 1</span></span><br></pre></td></tr></table></figure><p>\809. 情感丰富的文字</p><p>双指针 不要想得很复杂 直接带进去开始比较</p><p>return i&#x3D;&#x3D;str1.length()&amp;&amp;j&#x3D;&#x3D;str2.length()?1:0; 是证明遍历完成最好的写法 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">expressiveWords</span><span class="params">(String s, String[] words)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;words.length;i++) &#123;</span><br><span class="line">            res+=fun(s,words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">fun</span><span class="params">(String str1,String str2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;str1.length()&amp;&amp;j&lt;str2.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str1.charAt(i)!=str2.charAt(j)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch1</span> <span class="operator">=</span> str1.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum1</span> <span class="operator">=</span> <span class="number">0</span>, sum2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;str1.length()&amp;&amp;str1.charAt(i)==ch1) &#123;</span><br><span class="line">                ++sum1;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch2</span> <span class="operator">=</span> str2.charAt(j);</span><br><span class="line">            <span class="keyword">while</span> (j&lt;str2.length()&amp;&amp;str2.charAt(j)==ch2) &#123;</span><br><span class="line">                ++sum2;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum1&lt;sum2) &#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span> (sum1&gt;sum2&amp;&amp;sum1&lt;<span class="number">3</span>) &#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i==str1.length()&amp;&amp;j==str2.length()?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>\6248. 统计中位数为 K 的子数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubarrays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>, n = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (nums[pos] != k) ++pos;</span><br><span class="line">        <span class="type">var</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="comment">// cnt里面放的是出现的次数</span></span><br><span class="line">        cnt.put(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// i=pos 的时候 c 是 0，直接记到 cnt 中，这样下面不是大于就是小于</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> pos + <span class="number">1</span>, c = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            c += nums[i] &gt; k ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">            cnt.put(c, cnt.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> cnt.get(<span class="number">0</span>) + cnt.getOrDefault(<span class="number">1</span>, <span class="number">0</span>); </span><br><span class="line">        <span class="comment">// i=pos 的时候 c 是 0，直接加到答案中，这样下面不是大于就是小于</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> pos - <span class="number">1</span>, c = <span class="number">0</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            c += nums[i] &lt; k ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">            ans += cnt.getOrDefault(c, <span class="number">0</span>) + cnt.getOrDefault(c + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>\1796. 字符串中第二大的数字</p><p>set排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">secondHighest</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(c)) &#123;</span><br><span class="line">               set.add(c-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 复习一下java8的collect(Collectors.toList())</span></span><br><span class="line">        <span class="type">int</span>[] arr = set.stream().sorted(Comparator.naturalOrder()).mapToInt(Integer::valueOf).toArray();</span><br><span class="line">        <span class="keyword">return</span> arr.length&lt;<span class="number">2</span>?-<span class="number">1</span>:arr[arr.length-<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>一致性哈希</p><p>虚拟节点 顺时针 环 数据迁移</p><p><a href="https://mp.weixin.qq.com/s/zL-n7zq0Zyhf-l_GQil2dg">https://mp.weixin.qq.com/s/zL-n7zq0Zyhf-l_GQil2dg</a></p><p>布隆过滤器</p><p>位图：</p><p>布隆过滤器不可remove 允许一定的错误律</p><p>m 是位数 k 是哈希函数的个数 如果面试官可以扩大到32G之后还可以重新进行校订</p><p>算出来的是bit int是4个byte 32个bit 所以 可以表示很多 如果开四个int 最后可以表示很多数字</p><h4 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h4><h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p>常数级别的字符串匹配</p><p>两个字符串S1和S2 对于S2先搞到一个getIndexOf()统计最大的前缀相同的字符长度 next[0] &#x3D; -1 next[1] &#x3D; 0 这个数组表示的是之前的不包括当前字符的前缀后缀相同的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> haystack.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> needle.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] next = getIndex(needle);</span><br><span class="line">        <span class="comment">// Arrays.stream(next).forEach(System.out::println);</span></span><br><span class="line">        <span class="keyword">while</span> (i&lt;n&amp;&amp;j&lt;m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (haystack.charAt(i)==needle.charAt(j)) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (next[j]==-<span class="number">1</span>) i++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(i+&quot;---&quot;+j);</span></span><br><span class="line">         <span class="keyword">return</span> j==m?i-j:-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回前缀数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] getIndex(String m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m.length()==<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[m.length()];</span><br><span class="line">        <span class="type">char</span>[] chars = m.toCharArray();</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 指向的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// i-1比较的是</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;m.length();) &#123;</span><br><span class="line">            <span class="keyword">if</span>(chars[i-<span class="number">1</span>]==chars[cnt]) next[i++] = ++cnt;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cnt&gt;<span class="number">0</span>) cnt = next[cnt];</span><br><span class="line">            <span class="keyword">else</span> next[i++] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h4><p>用栈来储存元素index index可以储存的元素要更多一点</p><p><strong>下一个最大的元素 栈底到栈顶是从大到小的 遇到比当前的元素小的直接添加进来就可以 遇到比当前元素大的 进行比较移除栈当中的元素 而要移除的元素下面压得就是左边比他大的的元素</strong></p><p><strong>下一个最小的元素 栈底到栈顶是从小到大的 遇到比他大的就添加进来 遇到比他小的就移除栈当中的元素 移除的元素下面压得就是比他小的元素</strong></p><p><a href="https://blog.csdn.net/Borslav/article/details/125469491">(82条消息) 算法与数据结构——单调栈（Java）（b站左程云课程笔记总结）-CSDN博客</a></p><h4 id="图（后续再补充）"><a href="#图（后续再补充）" class="headerlink" title="图（后续再补充）"></a>图（后续再补充）</h4><p>邻接表用的多 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">    <span class="comment">// 建图，有向边代表「被依赖」关系</span></span><br><span class="line">    List&lt;Integer&gt;[] graph = buildGraph(numCourses, prerequisites);</span><br><span class="line">    <span class="comment">// 构建入度数组</span></span><br><span class="line">    <span class="type">int</span>[] indegree = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] edge : prerequisites) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edge[<span class="number">1</span>], to = edge[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 节点 to 的入度加一</span></span><br><span class="line">        indegree[to]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据入度初始化队列中的节点</span></span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 节点 i 没有入度，即没有依赖的节点</span></span><br><span class="line">            <span class="comment">// 可以作为拓扑排序的起点，加入队列</span></span><br><span class="line">            q.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录遍历的节点个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 开始执行 BFS 循环</span></span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 弹出节点 cur，并将它指向的节点的入度减一</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> next : graph[cur]) &#123;</span><br><span class="line">            indegree[next]--;</span><br><span class="line">            <span class="keyword">if</span> (indegree[next] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果入度变为 0，说明 next 依赖的节点都已被遍历</span></span><br><span class="line">                q.offer(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有节点都被遍历过，说明不成环</span></span><br><span class="line">    <span class="keyword">return</span> count == numCourses;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 建图函数</span></span><br><span class="line">List&lt;Integer&gt;[] buildGraph(<span class="type">int</span> n, <span class="type">int</span>[][] edges) &#123;</span><br><span class="line">    <span class="comment">// 见前文</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录后序遍历结果</span></span><br><span class="line">List&lt;Integer&gt; postorder = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 记录是否存在环</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">hasCycle</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">boolean</span>[] visited, onPath;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">    List&lt;Integer&gt;[] graph = buildGraph(numCourses, prerequisites);</span><br><span class="line">    visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[numCourses];</span><br><span class="line">    onPath = <span class="keyword">new</span> <span class="title class_">boolean</span>[numCourses];</span><br><span class="line">    <span class="comment">// 遍历图</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        traverse(graph, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有环图无法进行拓扑排序</span></span><br><span class="line">    <span class="keyword">if</span> (hasCycle) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 逆后序遍历结果即为拓扑排序结果</span></span><br><span class="line">    Collections.reverse(postorder);</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        res[i] = postorder.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图遍历函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(List&lt;Integer&gt;[] graph, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (onPath[s]) &#123;</span><br><span class="line">        <span class="comment">// 发现环</span></span><br><span class="line">        hasCycle = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (visited[s] || hasCycle) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序遍历位置</span></span><br><span class="line">    onPath[s] = <span class="literal">true</span>;</span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t : graph[s]) &#123;</span><br><span class="line">        traverse(graph, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后序遍历位置</span></span><br><span class="line">    postorder.add(s);</span><br><span class="line">    onPath[s] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 建图函数</span></span><br><span class="line">List&lt;Integer&gt;[] buildGraph(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">    <span class="comment">// 图中共有 numCourses 个节点</span></span><br><span class="line">    List&lt;Integer&gt;[] graph = <span class="keyword">new</span> <span class="title class_">LinkedList</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        graph[i] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] edge : prerequisites) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edge[<span class="number">1</span>], to = edge[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 添加一条从 from 指向 to 的有向边</span></span><br><span class="line">        <span class="comment">// 边的方向是「被依赖」关系，即修完课程 from 才能修课程 to</span></span><br><span class="line">        graph[from].add(to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="大数据问题"><a href="#大数据问题" class="headerlink" title="大数据问题"></a>大数据问题</h4><p>给3KB的空间只找到一个没出现过的数</p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="预处理技巧"><a href="#预处理技巧" class="headerlink" title="预处理技巧"></a>预处理技巧</h3><p><strong>求2^31次方之上可能会在计算机的时候超时并且越界 所以提前进行预处理</strong></p><p>\1498. 满足条件的子序列数目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSubseq</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">// 预处理2的n次方</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] pow2arr = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        pow2arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            pow2arr[i] = (pow2arr[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// System.out.println(nums.length);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; target - nums[i]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> binarySearch(nums,target - nums[i]);</span><br><span class="line">            res = (res+pow2arr[left-i-<span class="number">1</span>])%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]&lt;=target) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二维前缀和</strong></p><p>\1292. 元素和小于等于阈值的正方形的最大边长</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSideLength</span><span class="params">(<span class="type">int</span>[][] mat, <span class="type">int</span> threshold)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> mat.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> mat[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] pre = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">                pre[i][j] = mat[i-<span class="number">1</span>][j-<span class="number">1</span>] + pre[i-<span class="number">1</span>][j] + pre[i][j-<span class="number">1</span>] - pre[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        out : <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>;k&lt;=Math.min(m,n);k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i&lt;k||j&lt;k) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> pre[i][j] - pre[i-k][j] - pre[i][j-k] + pre[i-k][j-k];</span><br><span class="line">                    <span class="keyword">if</span> (tmp&lt;=threshold) &#123;ans = k; <span class="keyword">continue</span> out;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图论搜索专题"><a href="#图论搜索专题" class="headerlink" title="图论搜索专题"></a>图论搜索专题</h3><h4 id="图的构造结构"><a href="#图的构造结构" class="headerlink" title="图的构造结构"></a>图的构造结构</h4><p>\127. 单词接龙</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><p><a href="https://www.bilibili.com/video/BV1Vb4y1k7AA/?spm_id_from=333.337.search-card.all.click&vd_source=b16bc6370b4580d541ef490d09f1b6aa">【数据结构】07拓扑排序_哔哩哔哩_bilibili</a></p><p>1.找到没有入度的点</p><p>2.任选其中一点写入排序队列</p><p>\2192. 有向无环图中一个节点的所有祖先</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">getAncestors</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 自动排序</span></span><br><span class="line">        List&lt;Set&lt;Integer&gt;&gt; sets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// Map&lt;Integer,List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();</span></span><br><span class="line">        Map&lt;Integer,List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] in = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> edge:edges) &#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">from</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">            <span class="type">var</span> <span class="variable">to</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">            in[to]++;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(from)) map.put(from,<span class="keyword">new</span> <span class="title class_">ArrayList</span>());</span><br><span class="line">            map.get(from).add(to);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (in[i]==<span class="number">0</span>) &#123;</span><br><span class="line">                queue.add(i);</span><br><span class="line">                <span class="comment">// 小细节</span></span><br><span class="line">                in[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>());</span><br><span class="line">            sets.add(<span class="keyword">new</span> <span class="title class_">TreeSet</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(poll)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i:map.get(poll)) &#123;</span><br><span class="line">                    in[i]--;</span><br><span class="line">                    sets.get(i).add(poll);</span><br><span class="line">                    sets.get(i).addAll(sets.get(poll));</span><br><span class="line">                    <span class="keyword">if</span> (in[i]==<span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 细节</span></span><br><span class="line">                        queue.add(i);</span><br><span class="line">                        in[i]--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            ans.get(i).addAll(sets.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><h4 id="状态机DP"><a href="#状态机DP" class="headerlink" title="状态机DP"></a>状态机DP</h4><p> \1186. 删除一次得到子数组最大和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumSum</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 0代表不删除</span></span><br><span class="line">        <span class="comment">// 1代表删除</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// max = </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>] + arr[i],arr[i]);</span><br><span class="line">                dp[i][<span class="number">1</span>] = dp[i-<span class="number">1</span>][<span class="number">1</span>] + arr[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>] + arr[i],arr[i]); </span><br><span class="line">                dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>] + arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max,Math.max(dp[i][<span class="number">0</span>],dp[i][<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>\1143. 最长公共子序列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        text1 = <span class="string">&quot; &quot;</span> + text1;</span><br><span class="line">        text2 = <span class="string">&quot; &quot;</span> + text2;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> text1.length(),n = text2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1.charAt(i)==text2.charAt(j)) dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><h4 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">quickMul</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>, cur = x;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// n 不为偶数</span></span><br><span class="line">        <span class="keyword">if</span>((n &amp; <span class="number">1</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">            res = (res * cur) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = (cur * cur) % MOD;</span><br><span class="line">        n /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二分进阶"><a href="#二分进阶" class="headerlink" title="二分进阶"></a>二分进阶</h4><p><strong>最大化最小值 和 最小化最大值</strong></p><h2 id="刷题积累"><a href="#刷题积累" class="headerlink" title="刷题积累"></a>刷题积累</h2><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1000的数据量可以O(n^2)</p><p>100000的数据量可以是O(n*log(n))</p><h3 id="分治算法-分而治之"><a href="#分治算法-分而治之" class="headerlink" title="分治算法 :分而治之"></a>分治算法 :分而治之</h3><p>\241. 为运算表达式设计优先级</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; <span class="title function_">diffWaysToCompute</span><span class="params">(String input)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; input.length(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> input.charAt(i);</span><br><span class="line">        <span class="comment">// 扫描算式 input 中的运算符</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;*&#x27;</span> || c == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">/****** 分 ******/</span></span><br><span class="line">            <span class="comment">// 以运算符为中心，分割成两个字符串，分别递归计算</span></span><br><span class="line">            List&lt;Integer&gt; </span><br><span class="line">                left = diffWaysToCompute(input.substring(<span class="number">0</span>, i));</span><br><span class="line">            List&lt;Integer&gt; </span><br><span class="line">                right = diffWaysToCompute(input.substring(i + <span class="number">1</span>));</span><br><span class="line">            <span class="comment">/****** 治 ******/</span></span><br><span class="line">            <span class="comment">// 通过子问题的结果，合成原问题的结果</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> a : left)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> b : right)</span><br><span class="line">                    <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">                        res.add(a + b);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                        res.add(a - b);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                        res.add(a * b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="comment">// 如果 res 为空，说明算式是一个数字，没有运算符</span></span><br><span class="line">    <span class="keyword">if</span> (res.isEmpty()) &#123;</span><br><span class="line">        res.add(Integer.parseInt(input));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剑指 Offer 51. 数组中的逆序对</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//利用归并排序解答，在合并的时候，当左边的大于右边，就计算逆序数。</span></span><br><span class="line">    <span class="comment">//计算公式； mid-left+1</span></span><br><span class="line">    <span class="comment">//定义一个全局的计数器变量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reversePairs</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">        mergeSort(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="comment">//当只有一个节点的时候，直接返回，退出递归</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//左拆分</span></span><br><span class="line">        mergeSort(nums,left,mid);</span><br><span class="line">        <span class="comment">//右拆分</span></span><br><span class="line">        mergeSort(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="comment">//合并</span></span><br><span class="line">        merge(nums,left,mid,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="comment">//定义一个临时数组</span></span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[right-left+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//定义一个指针，指向第一个数组的第一个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="comment">//定义一个指针，指向第二个数组的第一个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//定义一个指针，指向临时数组的第一个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当两个数组都有元素的时候，遍历比较每个元素大小</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right)&#123;</span><br><span class="line">            <span class="comment">//比较两个数组的元素，取较小的元素加入到，临时数组中</span></span><br><span class="line">            <span class="comment">//并将两个指针指向下一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= nums[j])&#123;</span><br><span class="line">                temp[t++] = nums[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//当左边数组的大与右边数组的元素时，就对当前元素以及后面的元素的个数进行统计，</span></span><br><span class="line">                <span class="comment">//此时这个数就是，逆序数</span></span><br><span class="line">                <span class="comment">//定义一个计数器，记下每次合并中存在的逆序数。</span></span><br><span class="line">                count += mid-i+<span class="number">1</span>;</span><br><span class="line">                temp[t++] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当左边的数组没有遍历完成后，直接将剩余元素加入到临时数组中</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid)&#123;</span><br><span class="line">            temp[t++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当右边的数组没有遍历完成后，直接将剩余元素加入到临时数组中</span></span><br><span class="line">        <span class="keyword">while</span>(j &lt;= right)&#123;</span><br><span class="line">            temp[t++] =nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将新数组中的元素，覆盖nums旧数组中的元素。</span></span><br><span class="line">        <span class="comment">//此时数组的元素已经是有序的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span><span class="number">0</span>; k&lt; temp.length;k++)&#123;</span><br><span class="line">            nums[left+k] = temp[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表-1"><a href="#链表-1" class="headerlink" title="链表"></a>链表</h3><p>\725. 分隔链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode[] splitListToParts(ListNode head, <span class="type">int</span> k) &#123;</span><br><span class="line">        ListNode[] nodes = <span class="keyword">new</span> <span class="title class_">ListNode</span>[k];</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="literal">null</span>) <span class="keyword">return</span> nodes;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (tmp!=<span class="literal">null</span>) &#123;</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">            ++num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cs</span> <span class="operator">=</span> num/k,ys=num%k;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;k&amp;&amp;cur!=<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> cs + (i&lt;ys?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">            nodes[i] = cur;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;size;j++) &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = <span class="literal">null</span>;</span><br><span class="line">            cur = next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slidingWindow</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; window;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="type">char</span> c = s[right];</span><br><span class="line">        <span class="comment">// 增大窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">        <span class="comment">// 注意在最终的解法代码中不要 print</span></span><br><span class="line">        <span class="comment">// 因为 IO 操作很耗时，可能导致超时</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;window: [%d, %d)\n&quot;</span>, left, right);</span><br><span class="line">        <span class="comment">/********************/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="type">char</span> d = s[left];</span><br><span class="line">            <span class="comment">// 缩小窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&#x2F;76.最小覆盖子串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Character,Integer&gt; need = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;Character,Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : t.toCharArray()) &#123;</span><br><span class="line">            need.put(c,need.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>,len=Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cns</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (right&lt;s.length()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span> (need.containsKey(c)) &#123;</span><br><span class="line">                tmp.put(c,tmp.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (need.get(c)&gt;=tmp.get(c)) &#123;</span><br><span class="line">                    cns++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println(cns);</span></span><br><span class="line">            <span class="comment">// System.out.println(&quot;left&quot;+left+&quot;--&quot;+&quot;right&quot;+right);</span></span><br><span class="line">            <span class="keyword">while</span> (cns==t.length()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (right-left&lt;len-start) &#123;</span><br><span class="line">                    start = left;</span><br><span class="line">                    len = right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">if</span> (need.containsKey(d)) &#123;</span><br><span class="line">                    <span class="comment">// 注意判断字符串相等的时候 这里是equals</span></span><br><span class="line">                    <span class="keyword">if</span> (need.get(d).equals(tmp.get(d)))&#123;cns--;&#125;</span><br><span class="line">                    tmp.put(d,tmp.get(d)-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.print(start+&quot;-&quot;+len);</span></span><br><span class="line">        <span class="keyword">return</span> len-start==Integer.MAX_VALUE?<span class="string">&quot;&quot;</span>:s.substring(start,len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（灵神模板）</p><p>周赛失利就是忘掉 tmp这个周转元素了</p><p> <strong>把right 先丢到下面写吧</strong> </p><h3 id="前缀和-和-差分技巧"><a href="#前缀和-和-差分技巧" class="headerlink" title="前缀和 和 差分技巧"></a>前缀和 和 差分技巧</h3><p><strong>前缀和</strong> 多次离线query 快速求一个区间的元素 和快速 求[i,j]的元素和 prefix[j] - prefix[i-1] i!&#x3D;0</p><p><strong>差分</strong> 多次离线query 操作一个数组加数或者减数 让[i,j]区间＋1 diff[i]++;diff[j+1]–; </p><p>class PrefixSum {<br>    &#x2F;&#x2F; 前缀和数组<br>    private int[] prefix;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 输入一个数组，构造前缀和 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrefixSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    prefix = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 计算 nums 的累加和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prefix.length; i++) &#123;</span><br><span class="line">        prefix[i] = prefix[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查询闭区间 [i, j] 的累加和 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> prefix[j + <span class="number">1</span>] - prefix[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 差分数组工具类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Difference</span> &#123;</span><br><span class="line">    <span class="comment">// 差分数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] diff;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输入一个初始数组，区间操作将在这个数组上进行 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Difference</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> nums.length &gt; <span class="number">0</span>;</span><br><span class="line">    diff = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    <span class="comment">// 根据初始数组构造差分数组</span></span><br><span class="line">    diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 给闭区间 [i, j] 增加 val（可以是负数）*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    diff[i] += val;</span><br><span class="line">    <span class="keyword">if</span> (j + <span class="number">1</span> &lt; diff.length) &#123;</span><br><span class="line">        diff[j + <span class="number">1</span>] -= val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回结果数组 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] result() &#123;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[diff.length];</span><br><span class="line">    <span class="comment">// 根据差分数组构造结果数组</span></span><br><span class="line">    res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; diff.length; i++) &#123;</span><br><span class="line">        res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1094 拼车 差分 再 前缀和 就会得到 原数组 （差分要注意越界）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] corpFlightBookings(<span class="type">int</span>[][] bookings, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;bookings.length;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> bookings[i][<span class="number">0</span>]-<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> bookings[i][<span class="number">1</span>]-<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">seat</span> <span class="operator">=</span> bookings[i][<span class="number">2</span>];</span><br><span class="line">            ans[first] += seat;</span><br><span class="line">            <span class="keyword">if</span> (last+<span class="number">1</span>&lt;n) &#123;</span><br><span class="line">                ans[last+<span class="number">1</span>]-= seat;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;ans.length;i++) &#123;</span><br><span class="line">            sum+=ans[i];</span><br><span class="line">            ans[i] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>桶排序</p><h3 id="位运算-1"><a href="#位运算-1" class="headerlink" title="位运算"></a>位运算</h3><p>\1356. 根据数字二进制下 1 的数目排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortByBits(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">        <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            map[i] = Integer.bitCount(arr[i]) * <span class="number">10000000</span> + arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(map);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; map.length; i++) &#123;</span><br><span class="line">            map[i] = map[i] % <span class="number">10000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// a&amp;(a-1)完成功能:去掉a右边1 例:a=110，则： a&amp;(a-1) = 100</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (a != <span class="number">0</span>) &#123;</span><br><span class="line">            a &amp;= a-<span class="number">1</span>;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二种解决办法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortByBits(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : arr) &#123;</span><br><span class="line">            list.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] bit = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10001</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">            bit[i] = bit[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer x, Integer y)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (bit[x] != bit[y]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> bit[x] - bit[y];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> x - y;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; ++i) &#123;</span><br><span class="line">            arr[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="滑动窗口-1"><a href="#滑动窗口-1" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalFruit</span><span class="params">(<span class="type">int</span>[] fruits)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = <span class="number">0</span> ,ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> fruits.length;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (right = <span class="number">0</span>;right &lt; length;right++) &#123;</span><br><span class="line">            map.put(fruits[right],map.getOrDefault(fruits[right],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (map.size()&gt;<span class="number">2</span>) &#123;</span><br><span class="line">                map.put(fruits[left],map.get(fruits[left])-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (map.get(fruits[left])==<span class="number">0</span>) &#123;</span><br><span class="line">                    map.remove(fruits[left]);</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(right-left+<span class="number">1</span>,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><p>\208. 实现 Trie (前缀树)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> isEnd;</span><br><span class="line">        TrieNode[] next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> &#123;</span><br><span class="line">            isEnd = <span class="literal">false</span>;</span><br><span class="line">            next = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.next[c-<span class="string">&#x27;a&#x27;</span>]==<span class="literal">null</span>) &#123;</span><br><span class="line">                node.next[c-<span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            node = node.next[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span> (node==<span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.isEnd;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : prefix.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.next[c-<span class="string">&#x27;a&#x27;</span>]==<span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h3><h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><p>剑指 Offer II 057. 值和下标之差都在给定的范围内</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) &#123;</span><br><span class="line">        int n = nums.length;</span><br><span class="line"></span><br><span class="line">        //桶的大小为t+1，允许最大元素和最小元素之差为t</span><br><span class="line">        long w = (long) t + 1;</span><br><span class="line"></span><br><span class="line">        //因为一个桶有两个元素就会返回true，因此一个桶只有一个元素，可以用哈希表的一条key-value表示桶</span><br><span class="line">        Map&lt;Long, Long&gt; map = new HashMap&lt;Long, Long&gt;();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            long id = getID(nums[i], w);</span><br><span class="line"></span><br><span class="line">            //桶里已有元素x，nums[i]和x同属一个桶，值符合范围</span><br><span class="line">            //只保留下标 i 之前的 k 个元素，因此下标也符合范围</span><br><span class="line">            //桶有两个元素就会返回，因此一个桶只有一个元素</span><br><span class="line">            if (map.containsKey(id)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //前一个桶有一个元素，并且值的范围符合要求</span><br><span class="line">            if (map.containsKey(id - 1) &amp;&amp; Math.abs(nums[i] - map.get(id - 1)) &lt; w) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //后一个桶有一个元素，并且值的范围符合要求</span><br><span class="line">            if (map.containsKey(id + 1) &amp;&amp; Math.abs(nums[i] - map.get(id + 1)) &lt; w) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //没有和nums[i]匹配的元素，把nums[i]加入自己的桶里</span><br><span class="line">            map.put(id, (long) nums[i]);</span><br><span class="line"></span><br><span class="line">            //下标范围[i-k+1, i]，从nums[i-k]所在桶移除元素</span><br><span class="line">            if (i &gt;= k) &#123;</span><br><span class="line">                map.remove(getID(nums[i - k], w));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long getID(long x, long w) &#123;</span><br><span class="line">        //非负数区间，如[0, t] 会被归到 id=0</span><br><span class="line">        //其余的区间，如[(n-1)t+1, nt+1]，每t+1个元素会被归到 id = n-1</span><br><span class="line">        if (x &gt;= 0) &#123;</span><br><span class="line">            return x / w;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //负数区间，如[-t, -1] 会被归到 id=-1</span><br><span class="line">        //其余的区间，如[-(n+1)t-1, -nt-1]，每t+1个元素会被归到 id = -(n+1)</span><br><span class="line">        return (x + 1) / w - 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>\931. 下降路径最小和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">minFallingPathSum</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="comment">// 备忘录里的值初始化为 66666</span></span><br><span class="line">    memo = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        Arrays.fill(memo[i], <span class="number">66666</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 终点可能在 matrix[n-1] 的任意一列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        res = Math.min(res, dp(matrix, n - <span class="number">1</span>, j));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 备忘录</span></span><br><span class="line"><span class="type">int</span>[][] memo;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="comment">// 1、索引合法性检查</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> ||</span><br><span class="line">        i &gt;= matrix.length ||</span><br><span class="line">        j &gt;= matrix[<span class="number">0</span>].length) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">99999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、base case</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> matrix[<span class="number">0</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3、查找备忘录，防止重复计算</span></span><br><span class="line">    <span class="keyword">if</span> (memo[i][j] != <span class="number">66666</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进行状态转移</span></span><br><span class="line">    memo[i][j] = matrix[i][j] + min(</span><br><span class="line">            dp(matrix, i - <span class="number">1</span>, j), </span><br><span class="line">            dp(matrix, i - <span class="number">1</span>, j - <span class="number">1</span>),</span><br><span class="line">            dp(matrix, i - <span class="number">1</span>, j + <span class="number">1</span>)</span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">return</span> memo[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Math.min(a, Math.min(b, c));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>\813. 最大平均值和的分组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">largestSumOfAverages</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// dp[i][j] 将i个元素分为j个组的最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">double</span> [][] dp = <span class="keyword">new</span> <span class="title class_">double</span>[n+<span class="number">10</span>][k+<span class="number">10</span>];</span><br><span class="line">        <span class="type">double</span> [] sum = <span class="keyword">new</span> <span class="title class_">double</span>[n+<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum[i] = sum[i-<span class="number">1</span>] + nums[i-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=Math.min(i,k);j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j==<span class="number">1</span>) &#123;dp[i][<span class="number">1</span>] = sum[i]/i;&#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">2</span>;m&lt;=i;m++) &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j],dp[m-<span class="number">1</span>][j-<span class="number">1</span>]+(sum[i]-sum[m-<span class="number">1</span>])/(i-m+<span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="路径问题"><a href="#路径问题" class="headerlink" title="路径问题"></a>路径问题</h4><p>\64. 最小路径和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>) dp[i][j] = grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i==<span class="number">0</span>) dp[i][j] = dp[i][j-<span class="number">1</span>] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j==<span class="number">0</span>) dp[i][j] = dp[i-<span class="number">1</span>][j] + grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>])+grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>\120. 三角形最小路径和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> triangle.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> triangle.get(m-<span class="number">1</span>).size();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i],<span class="number">100001</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;i+<span class="number">1</span>;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j-<span class="number">1</span>&lt;<span class="number">0</span>) dp[i][j] = dp[i-<span class="number">1</span>][j] + triangle.get(i).get(j);</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-<span class="number">1</span>]) + triangle.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            min = Math.min(min,dp[m-<span class="number">1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间压缩</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> triangle.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> triangle.get(m-<span class="number">1</span>).size();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i],<span class="number">100001</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;i+<span class="number">1</span>;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j-<span class="number">1</span>&lt;<span class="number">0</span>) dp[i&amp;<span class="number">1</span>][j] = dp[(i-<span class="number">1</span>)&amp;<span class="number">1</span>][j] + triangle.get(i).get(j);</span><br><span class="line">                <span class="keyword">else</span> dp[i&amp;<span class="number">1</span>][j] = Math.min(dp[(i-<span class="number">1</span>)&amp;<span class="number">1</span>][j],dp[(i-<span class="number">1</span>)&amp;<span class="number">1</span>][j-<span class="number">1</span>]) + triangle.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            min = Math.min(min,dp[(m-<span class="number">1</span>)&amp;<span class="number">1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有序表"><a href="#有序表" class="headerlink" title="有序表"></a>有序表</h3><p>红黑树 SB树(叔侄Size) AVL树（平衡） 跳表（概率）</p><p>左旋 右旋 LL，RR（一次）LR，RL(两次 按着字母顺序 )</p><p>[(68条消息) 有序表TreeMap&#x2F;TreeSet底层实现：AVL树、傻逼树SBT、红黑树RBT、跳表SkipMap失衡类型_冰露可乐的博客-CSDN博客](<a href="https://blog.csdn.net/weixin_46838716/article/details/125019440?ops_request_misc=%7B%22request_id%22:%22167367213716800215071854%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=167367213716800215071854&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-125019440-null-null.142%5Ev71%5Ewechat_v2,201%5Ev4%5Eadd_ask&utm_term=%E7%BA%A2%E9%BB%91%E6%A0%91">https://blog.csdn.net/weixin_46838716/article/details/125019440?ops_request_misc=%7B%22request%5Fid%22%3A%22167367213716800215071854%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=167367213716800215071854&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-125019440-null-null.142^v71^wechat_v2,201^v4^add_ask&amp;utm_term=红黑树</a> SB树(叔侄Size) AVL树（平衡） 跳表)</p><p><a href="https://www.bilibili.com/video/BV13g41157hK/?p=19&vd_source=b16bc6370b4580d541ef490d09f1b6aa">17.基础提升 暴力递归（下）等_哔哩哔哩_bilibili</a></p><p>习题1 剑指 Offer II 058. 日程表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCalendar</span> &#123;</span><br><span class="line">    TreeMap&lt;Integer,Integer&gt; tmap;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCalendar</span><span class="params">()</span> &#123;</span><br><span class="line">        tmap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">book</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        Map.Entry&lt;Integer,Integer&gt; floorEntry = tmap.floorEntry(start);</span><br><span class="line">        Map.Entry&lt;Integer,Integer&gt; ceilingEntry = tmap.ceilingEntry(start);</span><br><span class="line">        <span class="keyword">if</span> (floorEntry!=<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (floorEntry.getValue()&gt;start) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ceilingEntry!=<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ceilingEntry.getKey() &lt; end) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tmap.put(start,end);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyCalendar object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyCalendar obj = new MyCalendar();</span></span><br><span class="line"><span class="comment"> * boolean param_1 = obj.book(start,end);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>\1146. 快照数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SnapshotArray</span> &#123;</span><br><span class="line">    List&lt;TreeMap&lt;Integer,Integer&gt;&gt; res;</span><br><span class="line">    <span class="type">int</span> snap;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SnapshotArray</span><span class="params">(<span class="type">int</span> length)</span> &#123;</span><br><span class="line">        snap = <span class="number">0</span>;</span><br><span class="line">        res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++) &#123;</span><br><span class="line">            <span class="comment">// 次数 + val</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        res.get(index).put(snap,val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">snap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> snap++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> snap_id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res.get(index).floorKey(snap_id)==<span class="literal">null</span>?<span class="number">0</span>:res.get(index).get(res.get(index).floorKey(snap_id));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your SnapshotArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * SnapshotArray obj = new SnapshotArray(length);</span></span><br><span class="line"><span class="comment"> * obj.set(index,val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.snap();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.get(index,snap_id);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="差分-二维-一维"><a href="#差分-二维-一维" class="headerlink" title="差分-二维-一维"></a>差分-二维-一维</h3><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h4 id="lamada表达式"><a href="#lamada表达式" class="headerlink" title="lamada表达式"></a>lamada表达式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;<span class="type">int</span>[]&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span>[] b)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[<span class="number">2</span>]==b[<span class="number">2</span>]) <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> a[<span class="number">2</span>] - b[<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>简化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;<span class="type">int</span>[]&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">1</span>] != b[<span class="number">1</span>]) <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">2</span>] - b[<span class="number">2</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h4><p>boxed 将基本类型转为包装类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">cntInt</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(val &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            val = val &amp; (val - <span class="number">1</span>);</span><br><span class="line">            count ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortByBits(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">        <span class="comment">// boxed用法</span></span><br><span class="line">      <span class="keyword">return</span> Arrays.stream(arr).boxed()</span><br><span class="line">            .sorted(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">cnt1</span> <span class="operator">=</span> cntInt(o1);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">cnt2</span> <span class="operator">=</span> cntInt(o2);</span><br><span class="line">                    <span class="comment">// 写的不错 Integer.compare(a,b)</span></span><br><span class="line">                    <span class="keyword">return</span> (cnt1 == cnt2) ? Integer.compare(o1, o2) : Integer.compare(cnt1, cnt2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            .mapToInt(Integer::valueOf)</span><br><span class="line">            .toArray();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy(srcArr,startIndex,baseArr,startIndex,length);</span><br></pre></td></tr></table></figure><h4 id="gcd"><a href="#gcd" class="headerlink" title="gcd"></a>gcd</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">gcd</span> <span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b==<span class="number">0</span>?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a % b == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> gcd(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>自己和自己的最大公因数就是自己本身</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarrayGCD</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>,n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">gcd</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i;j&lt;n;j++) &#123;</span><br><span class="line">                gcd = gcd(gcd,nums[j]);</span><br><span class="line">                <span class="keyword">if</span> (gcd==k) res++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (gcd==<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b==<span class="number">0</span>?a:gcd(b,a%b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Arrays-sort"><a href="#Arrays-sort" class="headerlink" title="Arrays.sort()"></a>Arrays.sort()</h4><p>1.对数组进行分类的时候，没有办法去降序排列</p><p>对于Integer 等非基本类型可以使用下面的接口来进行降序排列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(arr,Collections.reverseOrder());</span><br></pre></td></tr></table></figure><p>2.一个数组根据另一个数组排序的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(qid, (i, j) -&gt; queries[i][<span class="number">2</span>] - queries[j][<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><h4 id="队列和栈"><a href="#队列和栈" class="headerlink" title="队列和栈"></a>队列和栈</h4><p>官方推荐使用Deque<E> stack &#x3D; new ArrayDeque&lt;&gt;();来实现栈</p><p>推荐使用Queue<Integer> queue &#x3D; new LinkedList&lt;&gt;();来实现队列</p><p>推荐使用Queue<Integer> queue &#x3D; new PriorityQueue&lt;&gt;();来实现优先队列</p><p>推荐使用Deque<Integer> deque &#x3D; new LinkedList&lt;&gt;();来实现双端队列</p><p>技巧使用Last模拟的是栈，使用First和Last搭配模拟的是队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认为小顶堆</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(k, (a,b)-&gt;a-b);</span><br><span class="line"> </span><br><span class="line">PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(k, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer a, Integer b)</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> a - b;</span><br><span class="line">           &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//大顶堆</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(k, (a,b)-&gt;b-a);</span><br><span class="line"> </span><br><span class="line">PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(k, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer a, Integer b)</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> b - a;</span><br><span class="line">           &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><h4 id="向上取整和向下取整"><a href="#向上取整和向下取整" class="headerlink" title="向上取整和向下取整"></a>向上取整和向下取整</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x + y - 1) / y</span><br></pre></td></tr></table></figure><h4 id="将连续多个字符二进制转化为十进制的方法"><a href="#将连续多个字符二进制转化为十进制的方法" class="headerlink" title="将连续多个字符二进制转化为十进制的方法"></a>将连续多个字符二进制转化为十进制的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = x&lt;&lt;<span class="number">1</span> | (s[r] &amp; <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="将n进制转化为十进制"><a href="#将n进制转化为十进制" class="headerlink" title="将n进制转化为十进制"></a>将n进制转化为十进制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">parseInt</span><span class="params">(String s,<span class="type">int</span> radix)</span></span><br><span class="line">Integer.parseInt(num,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h4 id="十进制转化为二进制"><a href="#十进制转化为二进制" class="headerlink" title="十进制转化为二进制"></a>十进制转化为二进制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer.toBinarySearch(num);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程基本功 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理模式再剖析</title>
      <link href="/2022/11/15/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%86%8D%E5%89%96%E6%9E%90/"/>
      <url>/2022/11/15/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%86%8D%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="代理模式再剖析"><a href="#代理模式再剖析" class="headerlink" title="代理模式再剖析"></a>代理模式再剖析</h1><p>代理模式是一种设计模式，提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</p><p><strong>静态代理：</strong> 在编译时就已经实现，编译完成后代理类是一个实际的class文件</p><p><strong>动态代理：</strong> 在运行时动态生成的，即编译完成后没有实际的class文件，而是<strong>在运行时动态生成类字节码，并加载到JVM中</strong></p><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>1.通过实现InvocationHandler接口来自定义自己的InvocationHandler；</p><p>2.通过<code>Proxy.getProxyClass</code>获得动态代理类；</p><p>3.通过反射机制获得代理类的构造方法，方法签名为<code>getConstructor(InvocationHandler.class)</code>；</p><p>4.通过构造函数获得代理对象并将自定义的<code>InvocationHandler</code>实例对象传为参数传入；</p><p>5.通过代理对象调用目标方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IHello</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloImpl</span> <span class="keyword">implements</span> <span class="title class_">IHello</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 目标对象 */</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInvocationHandler</span><span class="params">(Object target)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------插入前置通知代码-------------&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行相应的目标方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">rs</span> <span class="operator">=</span> method.invoke(target,args);</span><br><span class="line">        System.out.println(<span class="string">&quot;------插入后置处理代码-------------&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> rs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">// 1、生成$Proxy0的class文件</span></span><br><span class="line"><span class="comment">//        System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</span></span><br><span class="line">        <span class="comment">// 2、获取动态代理类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">proxyClazz</span> <span class="operator">=</span> Proxy.getProxyClass(IHello.class.getClassLoader(),IHello.class);</span><br><span class="line">        <span class="comment">// 3、获得代理类的构造函数，并传入参数类型InvocationHandler.class</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> proxyClazz.getConstructor(InvocationHandler.class);</span><br><span class="line">        <span class="comment">// 4、通过构造函数来创建动态代理对象，将自定义的InvocationHandler实例传入</span></span><br><span class="line">        <span class="type">IHello</span> <span class="variable">iHello1</span> <span class="operator">=</span> (IHello) constructor.newInstance(<span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>(<span class="keyword">new</span> <span class="title class_">HelloImpl</span>()));</span><br><span class="line">        <span class="comment">// 5、通过代理对象调用目标方法</span></span><br><span class="line">        iHello1.sayHello();</span><br><span class="line">        <span class="comment">// ==========================第二种=============================</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Proxy类中还有个将2~4步骤封装好的简便方法来创建动态代理对象，</span></span><br><span class="line"><span class="comment">         *其方法签名为：newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] instance, InvocationHandler h)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">IHello</span>  <span class="variable">iHello2</span> <span class="operator">=</span> (IHello) Proxy.newProxyInstance(IHello.class.getClassLoader(), <span class="comment">// 加载接口的类加载器</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;IHello.class&#125;, <span class="comment">// 一组接口</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>(<span class="keyword">new</span> <span class="title class_">HelloImpl</span>())); <span class="comment">// 自定义的InvocationHandler</span></span><br><span class="line">        iHello2.sayHello();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>JDK静态代理是通过直接编码创建的，而<code>JDK</code>动态代理是利用反射机制在运行时创建代理类的。</p><p>其实在动态代理中，核心是<code>InvocationHandler</code>。每一个代理的实例都会有一个关联的调用处理程序(InvocationHandler)。对待代理实例进行调用时，将对方法的调用进行编码并指派到它的调用处理器(InvocationHandler)的<code>invoke</code>方法</p><p>对代理对象实例方法的调用都是通过InvocationHandler中的invoke方法来完成的，而<strong>invoke方法会根据传入的代理对象、方法名称以及参数</strong>决定调用代理的哪个方法，参考上面的传入InvocationHandler的入参。</p><h2 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h2><p>CGLIB包的底层是通过使用一个小而快的字节码处理框架<code>ASM</code>，来转换字节码并生成新的类</p><p><strong>CGLIB代理实现如下：</strong></p><ol><li>首先实现一个MethodInterceptor，方法调用会被转发到该类的intercept()方法。</li><li>然后在需要使用的时候，通过CGLIB动态代理获取代理对象。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HelloService</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloService构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法不能被子类覆盖,Cglib是无法代理final修饰的方法的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> String <span class="title function_">sayOthers</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloService:sayOthers&gt;&gt;&quot;</span>+name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloService:sayHello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义MethodInterceptor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sub：cglib生成的代理对象</span></span><br><span class="line"><span class="comment">     * method：被代理对象方法</span></span><br><span class="line"><span class="comment">     * objects：方法入参</span></span><br><span class="line"><span class="comment">     * methodProxy: 代理方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object sub, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;======插入前置通知======&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> methodProxy.invokeSuper(sub, objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;======插入后者通知======&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CGLIbProxy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过CGLIB动态代理获取代理对象的过程</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">// 设置enhancer对象的父类</span></span><br><span class="line">        enhancer.setSuperclass(HelloService.class);</span><br><span class="line">        <span class="comment">// 设置enhancer的回调对象</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MyMethodInterceptor</span>());</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        HelloService proxy= (HelloService)enhancer.create();</span><br><span class="line">        <span class="comment">// 通过代理对象调用目标方法</span></span><br><span class="line">        proxy.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>JDK代理要求被代理的类必须实现接口，有很强的局限性。</p><p>而CGLIB动态代理则没有此类强制性要求。简单的说，<code>CGLIB</code>会让生成的代理类继承被代理类，并在代理类中对代理方法进行强化处理(前置处理、后置处理等)。</p><p><strong>总结一下CGLIB在进行代理的时候都进行了哪些工作</strong></p><ul><li>生成的代理类继承被代理类。在这里我们需要注意一点：如果委托类被final修饰，那么它不可被继承，即不可被代理；同样，如果委托类中存在final修饰的方法，那么该方法也不可被代理</li><li>代理类会为委托方法生成两个方法，一个是与委托方法签名相同的方法，它在方法中会通过<code>super</code>调用委托方法；另一个是代理类独有的方法</li><li>当执行代理对象的方法时，会首先判断一下是否存在实现了<code>MethodInterceptor</code>接口的<code>CGLIB$CALLBACK_0</code>;，如果存在，则将调用<code>MethodInterceptor</code>中的<code>intercept</code>方法</li></ul><p>在<code>intercept</code>方法中，我们除了会调用委托方法，还会进行一些增强操作。在Spring AOP中，典型的应用场景就是在某些敏感方法执行前后进行操作日志记录</p><p>在CGLIB中，方法的调用并不是通过反射来完成的，而是直接对方法进行调用：通过<strong>FastClass机制</strong>对Class对象进行特别的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test10</span> &#123;</span><br><span class="line">  <span class="comment">//这里，tt可以看作目标对象，fc可以看作是代理对象；首先根据代理对象的getIndex方法获取目标方法的索引，</span></span><br><span class="line">  <span class="comment">//然后再调用代理对象的invoke方法就可以直接调用目标类的方法，避免了反射</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">tt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="type">Test2</span> <span class="variable">fc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test2</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> fc.getIndex(<span class="string">&quot;f()V&quot;</span>);</span><br><span class="line">        fc.invoke(index, tt, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;f method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">g</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;g method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(<span class="type">int</span> index, Object o, Object[] ol)</span>&#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span> (Test) o;</span><br><span class="line">        <span class="keyword">switch</span>(index)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            t.f();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            t.g();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个方法对Test类中的方法建立索引</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(String signature)</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(signature.hashCode())&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3078479</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3108270</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上例中，Test2是Test的Fastclass，在Test2中有两个方法getIndex和invoke。</p><p>在getIndex方法中对Test的每个方法建立索引，并根据入参（方法名+方法的描述符）来返回相应的索引。</p><p>Invoke根据指定的索引，以ol为入参调用对象O的方法。这样就避免了反射调用，提高了效率</p><table><thead><tr><th><strong>代理方式</strong></th><th><strong>实现</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td>JDK动态代理</td><td>代理类与委托类实现同一接口，主要是通过代理类实现InvocationHandler并重写<code>invoke</code>方法来进行动态代理的，在invoke方法中将对方法进行增强处理</td><td>不需要硬编码接口，代码复用率高</td><td>只能够代理实现了接口的委托类</td><td>底层使用反射机制进行方法的调用</td></tr><tr><td>CGLIB动态代理</td><td>代理类将委托类作为自己的父类并为其中的非final委托方法创建两个方法，一个是与委托方法签名相同的方法，它在方法中会通过<code>super</code>调用委托方法；另一个是代理类独有的方法。在代理方法中，它会判断是否存在实现了<code>MethodInterceptor</code>接口的对象，若存在则将调用intercept方法对委托方法进行代理</td><td>可以在运行时对类或者是接口进行增强操作，且委托类无需实现接口</td><td>不能对<code>final</code>类以及final方法进行代理</td><td>底层将方法全部存入一个数组中，通过数组索引直接进行方法调用</td></tr></tbody></table><p><strong>CGlib比JDK快？</strong></p><ul><li>使用CGLiB实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类， 在jdk6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的方法进行代理， 因为CGLib原理是动态生成被代理类的子类。</li><li>在jdk6、jdk7、jdk8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLIB代理效率。只有当进行大量调用的时候，jdk6和jdk7比CGLIB代理效率低一点，但是到jdk8的时候，jdk代理效率高于CGLIB代理，总之，每一次jdk版本升级，jdk代理效率都得到提升，而CGLIB代理消息确有点跟不上步伐。</li></ul><p><strong>Spring如何选择用JDK还是CGLIB？</strong></p><ul><li>当Bean实现接口时，Spring就会用JDK的动态代理。</li><li>当Bean没有实现接口时，Spring使用CGlib实现。</li><li>可以强制使用CGlib</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程基本功 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式再剖析</title>
      <link href="/2022/11/14/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%86%8D%E5%89%96%E6%9E%90/"/>
      <url>/2022/11/14/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%86%8D%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式常见的有三种简单工厂模式、工厂方法模式、抽象工厂模式</p><h2 id="（一）简单工厂模式"><a href="#（一）简单工厂模式" class="headerlink" title="（一）简单工厂模式"></a>（一）简单工厂模式</h2><p>简单工厂模式又称静态工厂方法模式。它存在的目的很简单：定义一个用于创建对象的接口。 <strong>组成结构：</strong> **1) 工厂类角色(Creator)**：这是本模式的核心，含有一定的商业逻辑和判断逻辑。在java中它往往由一个具体类实现。 **2) 抽象产品角色(Product)**：它一般是具体产品继承的父类或者实现的接口。在java中由接口或者抽象类来实现。 **3) 具体产品角色(ConcreteProduct)**：工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Figure</span>()&#123;<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateArea</span><span class="params">()</span>;<span class="comment">//计算面积&#125;</span></span><br></pre></td></tr></table></figure><p>具体产品角色 – 正方形、圆形：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">implements</span> <span class="title class_">Figure</span>&#123;<span class="comment">//正方形</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Square</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Square</span><span class="params">(<span class="type">double</span> length)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.length = length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> length;</span><br><span class="line">    <span class="comment">// getters/setters ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateArea</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.getLength() * <span class="built_in">this</span>.getLength();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Figure</span>&#123;<span class="comment">//圆形</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> radius)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line">    <span class="comment">// getters/setters ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculateArea</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.getRadius() * <span class="built_in">this</span>.getRadius() * Math.PI;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>工厂类角色-图形工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FigureFactory</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Figure <span class="title function_">createFigure</span><span class="params">(String typeName, <span class="type">double</span> figureArgs)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;Circle&quot;</span>.equalsIgnoreCase(typeName))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(figureArgs);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;Square&quot;</span>.equalsIgnoreCase(typeName))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Square</span>(figureArgs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []args)</span>&#123;</span><br><span class="line">    <span class="type">Figure</span> <span class="variable">figure</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(...)&#123;<span class="comment">//界面逻辑需要圆形</span></span><br><span class="line">    figure = FigureFactory.createFigure(<span class="string">&quot;Circle&quot;</span>, <span class="number">2.0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(...)&#123;<span class="comment">//界面逻辑需要正方形</span></span><br><span class="line">    figure = FigureFactory.createFigure(<span class="string">&quot;Square&quot;</span>, <span class="number">2.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;面积为：&quot;</span>+figure.calculateArea());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="（二）工厂方法模式"><a href="#（二）工厂方法模式" class="headerlink" title="（二）工厂方法模式"></a>（二）工厂方法模式</h2><p>新增一个产品必须新增一个对应的工厂类</p><p><strong>工厂方法模式去掉了简单工厂模式中工厂方法的静态属性</strong>，使得它可以被子类继承。这样在简单工厂模式里集中在工厂方法上的压力可以由工厂方法模式里不同的工厂子类来分担。</p><p><strong>组成结构：</strong> **1) 抽象工厂角色(Creator)**： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在 java 中它由抽象类或者接口来实现。 **2) 具体工厂角色(ConcreteCreator1,2)**：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。 **3) 抽象产品角色(Product)**：它是具体产品继承的父类或者是实现的接口。在 java 中一般有抽象类或者接口来实现。 **4) 具体产品角色(ConcreteProduct1,2)**：具体工厂角色所创建的对象就是此角色的实例。在 java 中由具体的类来实现。</p><img src="/2022/11/14/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%86%8D%E5%89%96%E6%9E%90/image-20230815151952347.png" class="" title="image-20230815151952347"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图形工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FigureFactory</span>&#123;</span><br><span class="line"><span class="keyword">public</span> Figure <span class="title function_">createFigure</span><span class="params">(<span class="type">double</span> figureArgs)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//圆形工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircleFactory</span> <span class="keyword">implements</span> <span class="title class_">FigureFactory</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Figure <span class="title function_">createFigure</span><span class="params">(<span class="type">double</span> figureArgs)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(figureArgs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正方形工厂 与 圆形工厂类似，此处省略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []args)</span>&#123;</span><br><span class="line">    <span class="type">FigureFactory</span> <span class="variable">figureFactory</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(...)&#123;<span class="comment">//界面逻辑需要圆形</span></span><br><span class="line">    figureFactory = <span class="keyword">new</span> <span class="title class_">CircleFactory</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(...)&#123;<span class="comment">//界面逻辑需要正方形</span></span><br><span class="line">    figureFactory = <span class="keyword">new</span> <span class="title class_">SqureFactory</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Figure</span> <span class="variable">figure</span> <span class="operator">=</span> figureFactory.createFigure(<span class="number">2.0</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;面积为：&quot;</span>+figure.calculateArea());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结合项目：</p><p>在网关项目当中创建会话Session的时候和SessionFactory的时候用到了工厂模式，以下是他们的接口和工厂，没有用到的时候确实不理解</p><p>GatewaySession：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GatewaySession</span> &#123;</span><br><span class="line"></span><br><span class="line">    Object <span class="title function_">get</span><span class="params">(String uri, Object parameter)</span>;</span><br><span class="line"></span><br><span class="line">    IGenericReference <span class="title function_">getMapper</span><span class="params">(String uri)</span>;</span><br><span class="line"></span><br><span class="line">    Configuration <span class="title function_">getConfiguration</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultGatewaySession</span> <span class="keyword">implements</span> <span class="title class_">GatewaySession</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Configuration configuration;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DefaultGatewaySession</span><span class="params">(Configuration configuration)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.configuration = configuration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String uri, Object parameter)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 以下这部分内容，后续拆到执行器中处理 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置信息</span></span><br><span class="line">        <span class="type">HttpStatement</span> <span class="variable">httpStatement</span> <span class="operator">=</span> configuration.getHttpStatement(uri);</span><br><span class="line">        <span class="type">String</span> <span class="variable">application</span> <span class="operator">=</span> httpStatement.getApplication();</span><br><span class="line">        <span class="type">String</span> <span class="variable">interfaceName</span> <span class="operator">=</span> httpStatement.getInterfaceName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取基础服务（创建成本较高，内存存放获取）</span></span><br><span class="line">        <span class="type">ApplicationConfig</span> <span class="variable">applicationConfig</span> <span class="operator">=</span> configuration.getApplicationConfig(application);</span><br><span class="line">        <span class="type">RegistryConfig</span> <span class="variable">registryConfig</span> <span class="operator">=</span> configuration.getRegistryConfig(application);</span><br><span class="line">        ReferenceConfig&lt;GenericService&gt; reference = configuration.getReferenceConfig(interfaceName);</span><br><span class="line">        <span class="comment">// 构建Dubbo服务</span></span><br><span class="line">        <span class="type">DubboBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> DubboBootstrap.getInstance();</span><br><span class="line">        bootstrap.application(applicationConfig).registry(registryConfig).reference(reference).start();</span><br><span class="line">        <span class="comment">// 获取泛化调用服务</span></span><br><span class="line">        <span class="type">ReferenceConfigCache</span> <span class="variable">cache</span> <span class="operator">=</span> ReferenceConfigCache.getCache();</span><br><span class="line">        <span class="type">GenericService</span> <span class="variable">genericService</span> <span class="operator">=</span> cache.get(reference);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> genericService.$invoke(httpStatement.getMethodName(), <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;java.lang.String&quot;</span>&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;小傅哥&quot;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IGenericReference <span class="title function_">getMapper</span><span class="params">(String uri)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> configuration.getMapper(uri, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Configuration <span class="title function_">getConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> configuration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GatewaySessionFactory：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GatewaySessionFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    GatewaySession <span class="title function_">openSession</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DefaultGateWaySessionFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultGatewaySessionFactory</span> <span class="keyword">implements</span> <span class="title class_">GatewaySessionFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Configuration configuration;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DefaultGatewaySessionFactory</span><span class="params">(Configuration configuration)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.configuration = configuration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> GatewaySession <span class="title function_">openSession</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultGatewaySession</span>(configuration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><p>抽象工厂模式就是产品线更加复杂，但是又会回到当初的简单工厂的局面，违反开闭原则</p><img src="/2022/11/14/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%86%8D%E5%89%96%E6%9E%90/image-20230815153800992.png" class="" title="image-20230815153800992">]]></content>
      
      
      <categories>
          
          <category> 编程基本功 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM冲击</title>
      <link href="/2022/08/27/JVM%E5%86%B2%E5%87%BB/"/>
      <url>/2022/08/27/JVM%E5%86%B2%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<p>JVM（如HotSpot虚拟机），实际上采用的是<code>基于栈的指令集架构</code>，它并没有依赖于寄存器，而是更多的利用操作栈来完成，这样不仅设计和实现起来更简单，并且也能够更加方便地实现跨平台，不太依赖于硬件的支持。</p><p>JVM运行字节码时，所有的操作基本都是围绕两种数据结构，一种是堆栈（本质是栈结构），还有一种是队列，如果JVM执行某条指令时，该指令需要对数据进行操作，那么被操作的数据在指令执行前，必须要压到堆栈上，JVM会自动将栈顶数据作为操作数。如果堆栈上的数据需要暂时保存起来时，那么它就会被存储到局部变量队列上。</p><img src="/2022/08/27/JVM%E5%86%B2%E5%87%BB/image-20230827174234285.png" class="" title="image-20230827174234285"><img src="/2022/08/27/JVM%E5%86%B2%E5%87%BB/image-20230827174255150.png" class="" title="image-20230827174255150"><p><strong>线程私有的：</strong></p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><p><strong>线程共享的：</strong></p><ul><li>堆</li><li>方法区</li><li>直接内存 (非运行时数据区的一部分)</li></ul><p>Java 虚拟机规范对于运行时数据区域的规定是相当宽松的。以堆为例：堆可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展 。虚拟机实现者可以使用任何垃圾回收算法管理堆，甚至完全不进行垃圾收集也是可以的。</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title=" 程序计数器"></a><a href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"></a> 程序计数器</h3><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</p><p>另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>从上面的介绍中我们知道了程序计数器主要有两个作用：</p><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ul><p>⚠️ 注意：程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死</p><h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3><p>与程序计数器一样，Java 虚拟机栈（后文简称栈）也是线程私有的，它的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡。</p><p>栈绝对算的上是 JVM 运行时数据区域的一个核心，除了一些 Native 方法调用是通过本地方法栈实现的(后面会提到)，其他所有的 Java 方法调用都是通过栈来实现的（也需要和其他运行时数据区域比如程序计数器配合）。</p><p>方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。</p><p>栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。和数据结构上的栈类似，两者都是先进后出的数据结构，只支持出栈和入栈两种操作。</p><img src="/2022/08/27/JVM%E5%86%B2%E5%87%BB/image-20230827174509956.png" class="" title="image-20230827174509956"><p>栈空间虽然不是无限的，但一般正常调用的情况下是不会出现问题的。不过，如果函数调用陷入无限循环的话，就会导致栈中被压入太多栈帧而占用太多空间，导致栈空间过深。那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code> 错误。</p><p>Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说， **栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。</p><p><strong><code>StackOverFlowError</code>：</strong> 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code> 错误。</p><p><strong><code>OutOfMemoryError</code>：</strong> 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p><p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p><p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种错误。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p><p>Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。</p><p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p><ol><li>新生代内存(Young Generation)</li><li>老生代(Old Generation)</li><li>永久代(Permanent Generation)</li></ol><p>下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。</p><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置</p><img src="/2022/08/27/JVM%E5%86%B2%E5%87%BB/image-20230827174911405.png" class="" title="image-20230827174911405"><p>JDK1.7之前</p><p><strong>方法区和永久代以及元空间是什么关系呢？</strong> 方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作是方法区，也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。</p><p><strong>为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</strong></p><p>1、整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</p><blockquote><p>当元空间溢出时会得到如下错误：<code>java.lang.OutOfMemoryError: MetaSpace</code></p></blockquote><p>你可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p><p>2、元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</p><p>3、在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了</p><p><strong>方法区常用参数有哪些？</strong></p><p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize=N //方法区 (永久代) 初始大小</span><br><span class="line">-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p><p>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是本地内存。下面是一些常用参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）</span><br><span class="line">-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小</span><br></pre></td></tr></table></figure><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 <strong>常量池表(Constant Pool Table)</strong> 。</p><p>字面量是源代码中的固定值的表示法，即通过字面我们就能知道其值的含义。字面量包括整数、浮点数和字符串字面量。常见的符号引用包括类符号引用、字段符号引用、方法符号引用、接口方法符号。</p><p>《深入理解 Java 虚拟机》7.34 节第三版对符号引用和直接引用的解释如下：</p><p>常量池表会在类加载后存放到方法区的运行时常量池中。</p><p>运行时常量池的功能类似于传统编程语言的符号表，尽管它包含了比典型符号表更广泛的数据。</p><p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 错误</p><h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”ab“</span></span><br><span class="line"><span class="comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">System.out.println(aa==bb);<span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> <strong>为什么要将字符串常量池移动到堆中？</strong></p><p>主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。</p><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 <code>OutOfMemoryError</code> 错误出现。</p><p>JDK1.4 中新加入的 <strong>NIO（Non-Blocking I&#x2F;O，也被称为 New I&#x2F;O）</strong>，引入了一种基于**通道（Channel）**与**缓存区（Buffer）**的 I&#x2F;O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为**避免了在 Java 堆和 Native 堆之间来回复制数据**。</p><p>直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p><p>类似的概念还有 <strong>堆外内存</strong> 。在一些文章中将直接内存等价于堆外内存，个人觉得不是特别准确。</p><p>堆外内存就是把内存对象分配在堆（新生代+老年代+永久代）以外的内存，这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响。</p><p>Step1:类加载检查</p><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><p>Step2:分配内存</p><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p><p><strong>内存分配的两种方式</strong> （补充内容，需要掌握）：</p><ul><li>指针碰撞： <ul><li>适用场合：堆内存规整（即没有内存碎片）的情况下。</li><li>原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li><li>使用该分配方式的 GC 收集器：Serial, ParNew</li></ul></li><li>空闲列表： <ul><li>适用场合：堆内存不规整的情况下。</li><li>原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li><li>使用该分配方式的 GC 收集器：CMS</li></ul></li></ul><p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的。</p><p><strong>内存分配并发问题（补充内容，需要掌握）</strong></p><p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p><ul><li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li><li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li></ul><p> Step3:初始化零值</p><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><p>Step4:设置对象头</p><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><p>Step5:执行 init 方法</p><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 编程基本功 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ火箭冲击</title>
      <link href="/2022/08/23/RocketMQ%E7%81%AB%E7%AE%AD%E5%86%B2%E5%87%BB/"/>
      <url>/2022/08/23/RocketMQ%E7%81%AB%E7%AE%AD%E5%86%B2%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<p>如何保证消息的可靠投递？</p><p>生产者的可靠投递 集群的持久化 消费者的消费确认</p><p>难点在于生产者这边，如何去保证消息的发送和数据的入库实现一致性</p><p>比如A给B转账100块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void transfer(Long uid,Long tUid,int amount) &#123;</span><br><span class="line">userAccountMapper.addAmount(sUid,-amount);</span><br><span class="line">userAccountMapper.addAmount(tUid,ammout);</span><br><span class="line">mqProducer.send(&quot;topic&quot;,new AccountChangeMsg(sUid,tUid,amount));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一如果需要发送两条mq呢？</p><p>第二条mq是在事务里面的，如果事务还没有执行成功，消费者就收到了消息，这时候回查查不到转账记录的。</p><p>解决办法：</p><p>1.消息入库，事务在提交之后 才发送消息，每条消息都不会直接发送都是直接存到数据库当中，将消息ID存入ThreadLocal当中</p><p>消息和其他的都是入库的，已经能严格保证数据库的事务了</p><p>2.消息之后的投递怎么做到的，需要重写事务管理器 ，事务提交之后就去查询TreadLocal当中待发送的消息，</p><p>发送完成一条数据库就删除一条。</p><p>3.就算消息发送失败了，采用定时任务不断地重试，来确保消息发送正确。</p><p>消息处理的一致性是非常复杂的</p><p>消息中间件三大功能：应用的解耦 削峰填谷 <strong>数据分发</strong></p><p><a href="https://www.bilibili.com/video/BV1Dh411P7b9?p=4&vd_source=b16bc6370b4580d541ef490d09f1b6aa">04.常见消息中间件介绍_哔哩哔哩_bilibili</a></p><p>kafaka是一种高吞吐量的分布式订阅消息系统，通常是由于吞吐量的要求而通过处理日志和日志聚合来解决。</p><img src="/2022/08/23/RocketMQ%E7%81%AB%E7%AE%AD%E5%86%B2%E5%87%BB/image-20230826203457811.png" class="" title="image-20230826203457811"><p>RabbitMQ虽然是万但是很多小公司其实都是达不到这个级别的</p><p>Broker代理服务器：负责接收生产者的请求，把消息存储到中间件当中，接受消费者的请求，把消息推送给消费者。</p><p>命名服务NameSever：类似注册中心，管理代理服务器的注册中心，管理代理服务器的IP和端口</p><p>封装成Message对象 用户ID和积分数量</p><p><strong>topic主题：按照业务进行划分，把不同的消息放在不同的主题之下。</strong></p><p><strong>消息队列MessageQueue:实际消息在Topic存储的数据结构</strong></p><p><strong>Tag可以给消息设置标签，进行消息的过滤</strong></p><p>这个东西不是跟着我写的网关一样吗？？？</p><img src="/2022/08/23/RocketMQ%E7%81%AB%E7%AE%AD%E5%86%B2%E5%87%BB/image-20230826204907496.png" class="" title="image-20230826204907496"><p>rocketMQ部署</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#docker 拉取</span><br><span class="line">docker pull foxiswho/rocketmq:4.8.0</span><br><span class="line">#启动nameserver</span><br><span class="line">docker run -d -v /usr/local/rocketmq/logs:/opt/docker/rocketmq/logs \</span><br><span class="line">      --name rmqnamesrv \</span><br><span class="line">      -e &quot;JAVA_OPT_EXT=-Xms512M -Xmx512M -Xmn128m&quot; \</span><br><span class="line">      -p 9876:9876 \</span><br><span class="line">      foxiswho/rocketmq:4.8.0 \</span><br><span class="line">      sh mqnamesrv</span><br><span class="line">#broker.conf</span><br><span class="line">brokerIP1= 120.78.190.233</span><br><span class="line">namesrvAddr= 120.78.190.233:9876</span><br><span class="line">brokerName=broker_all</span><br><span class="line">#启动broker</span><br><span class="line">docker run -d  -v /opt/docker/rocketmq/logs:/usr/local/rocketmq/logs -v /opt/docker/rocketmq/store:/usr/local/rocketmq/store \</span><br><span class="line">      -v /opt/docker/rocketmq/conf:/usr/local/rocketmq/conf \</span><br><span class="line">      --name rmqbroker \</span><br><span class="line">      -e &quot;NAMESRV_ADDR= 47.93.38.210:9876&quot; \</span><br><span class="line">      -e &quot;JAVA_OPT_EXT=-Xms512M -Xmx512M -Xmn128m&quot; \</span><br><span class="line">      -p 10911:10911 -p 10912:10912 -p 10909:10909 \</span><br><span class="line">      foxiswho/rocketmq:4.8.0 \</span><br><span class="line">      sh mqbroker -c /usr/local/rocketmq/conf/broker.conf</span><br><span class="line">docker run --name rmqconsole --link rmqnamesrv:rmqnamesrv \</span><br><span class="line">-e &quot;JAVA_OPTS=-Drocketmq.namesrv.addr=120.78.190.233:9876 -Dcom.rocketmq.sendMessageWithVIPChannel=false&quot; \</span><br><span class="line">-p 8180:8080 -t styletang/rocketmq-console-ng</span><br></pre></td></tr></table></figure><p>重命名是mv指令</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis缓存技术再整理</title>
      <link href="/2022/08/23/redis%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF%E5%86%8D%E6%95%B4%E7%90%86/"/>
      <url>/2022/08/23/redis%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF%E5%86%8D%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="基本常见的数据类型"><a href="#基本常见的数据类型" class="headerlink" title="基本常见的数据类型"></a>基本常见的数据类型</h2><p>字符串 hash  list set  zset</p><p>字符串： </p><p>哈希： Hash的命令前面多了个H，类似java里面的Map&lt;String,Map&lt;String,String&gt;&gt; 这种格式，比较适合存储类这种数据。</p><p>List:  类似LinkedList一样，</p><p>向头部添加数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lpush linkedlist 1 2 3</span><br></pre></td></tr></table></figure><p>– 向尾部添加数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpush linkedlist 1 2 3</span><br></pre></td></tr></table></figure><p>向指定元素前面后面插入元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linsert linkedlist before/after 1 4</span><br></pre></td></tr></table></figure><p>blpop有点类似阻塞的这种形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blpop linkedlist 10</span><br></pre></td></tr></table></figure><img src="/2022/08/23/redis%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF%E5%86%8D%E6%95%B4%E7%90%86/image-20230824150147789.png" class="" title="image-20230824150147789"><p>set：跟着HashSet一样可以过滤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sadd &lt;key&gt; &lt;value&gt;</span><br></pre></td></tr></table></figure><p>ZSet 类似java里面的TreeSet </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zadd &lt;key&gt; [&lt;value&gt; &lt;score&gt;]...</span><br></pre></td></tr></table></figure><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>RDB快照</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save</span><br><span class="line">-- 注意上面这个命令是直接保存，会占用一定的时间，也可以单独开一个子进程后台执行保存</span><br><span class="line">bgsave</span><br></pre></td></tr></table></figure><p>执行后，会在服务端目录下生成一个dump.rdb文件，而这个文件中就保存了内存中存放的数据，当服务器重启后，会自动加载里面的内容到对应数据库中。保存后我们可以关闭服务器：</p><img src="/2022/08/23/redis%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF%E5%86%8D%E6%95%B4%E7%90%86/image-20230824171112221.png" class="" title="image-20230824171112221"><p>AOF</p><p>然RDB能够很好地解决数据持久化问题，但是它的缺点也很明显：每次都需要去完整地保存整个数据库中的数据，同时后台保存过程中也会产生额外的内存开销，最严重的是它并不是实时保存的，如果在自动保存触发之前服务器崩溃，那么依然会导致少量数据的丢失。</p><p>而AOF就是另一种方式，它会以日志的形式将我们每次执行的命令都进行保存，服务器重启时会将所有命令依次执行，通过这种重演的方式将数据恢</p><p>AOF重写机制</p><p>但是，我们多久写一次日志呢？我们可以自己配置保存策略，有三种策略：</p><ul><li>always：每次执行写操作都会保存一次</li><li>everysec：每秒保存一次（默认配置），这样就算丢失数据也只会丢一秒以内的数据</li><li>no：看系统心情保存</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 注意得改成也是</span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line"># appendfsync always</span><br><span class="line">appendfsync everysec</span><br><span class="line"># appendfsync no</span><br></pre></td></tr></table></figure><p>优缺点：</p><ul><li>AOF：<ul><li>优点：存储速度快、消耗资源少、支持实时存储</li><li>缺点：加载速度慢、数据体积大</li></ul></li><li>RDB：<ul><li>优点：加载速度快、数据体积小</li><li>缺点：存储速度慢大量消耗资源、会发生数据丢失</li></ul></li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>开启事务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multi</span><br></pre></td></tr></table></figure><p>执行事务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec</span><br></pre></td></tr></table></figure><p>取消事务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">discard</span><br></pre></td></tr></table></figure><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>又提到锁了，实际上这个概念对我们来说已经不算是陌生了。实际上在Redis中也会出现多个命令同时竞争同一个数据的情况，比如现在有两条命令同时执行，他们都要去修改a的值，那么这个时候就只能动用锁机制来保证同一时间只能有一个命令操作。</p><p>虽然Redis中也有锁机制，但是它是一种乐观锁，不同于MySQL，我们在MySQL中认识的锁是悲观锁，那么什么是乐观锁什么是悲观锁呢？</p><ul><li>悲观锁：时刻认为别人会来抢占资源，禁止一切外来访问，直到释放锁，具有强烈的排他性质。</li><li>乐观锁：并不认为会有人来抢占资源，所以会直接对数据进行操作，在操作时再去验证是否有其他人抢占资源。</li></ul><p>Redis中可以使用watch来监视一个目标，如果执行事务之前被监视目标发生了修改，则取消本次事务：</p><p>是一种乐观锁 watch来监控 利用的是版本号 并不是实体的数值</p><h2 id="SpringBoot整合redis"><a href="#SpringBoot整合redis" class="headerlink" title="SpringBoot整合redis"></a>SpringBoot整合redis</h2><p>我们接着来看如何在SpringBoot项目中整合Redis操作框架，只需要一个starter即可，但是它底层没有用Jedis，而是Lettuce</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>starter提供的默认配置会去连接本地的Redis服务器，并使用0号数据库，当然你也可以手动进行修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">  #Redis服务器地址</span><br><span class="line">    host: 192.168.10.3</span><br><span class="line">    #端口</span><br><span class="line">    port: 6379</span><br><span class="line">    #使用几号数据库</span><br><span class="line">    database: 0</span><br></pre></td></tr></table></figure><p>默认定义好了两个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by FernFlower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.springframework.boot.autoconfigure.data.redis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnClass;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnSingleCandidate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Import;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisOperations;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(</span></span><br><span class="line"><span class="meta">    proxyBeanMethods = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;RedisOperations.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;RedisProperties.class&#125;)</span></span><br><span class="line"><span class="meta">@Import(&#123;LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisAutoConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(</span></span><br><span class="line"><span class="meta">        name = &#123;&quot;redisTemplate&quot;&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line">    <span class="keyword">public</span> StringRedisTemplate <span class="title function_">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        <span class="type">StringRedisTemplate</span> <span class="variable">template</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisTemplate</span>();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>默认定义了一个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.wsy.code.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        stringRedisTemplate.setEnableTransactionSupport(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        stringRedisTemplate.multi();</span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;d&quot;</span>,<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        stringRedisTemplate.exec();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><h2 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h2>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程</title>
      <link href="/2022/08/07/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/08/07/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="线程的创建和启动"><a href="#线程的创建和启动" class="headerlink" title="线程的创建和启动"></a>线程的创建和启动</h3><p>通过创建Thread对象来创建一个新的线程，Thread构造方法中需要传入一个Runnable接口的实现（其实就是编写要在另一个线程执行的内容逻辑）同时Runnable只有一个未实现方法，因此可以直接使用lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是一号线程：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是二号线程：&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然<code>stop()</code>方法能够终止此线程，但是并不是所推荐的做法，有关线程中断相关问题，我们会在后面继续了解。</p><h3 id="线程的休眠和中断"><a href="#线程的休眠和中断" class="headerlink" title="线程的休眠和中断"></a>线程的休眠和中断</h3><p>我们前面提到，一个线程处于运行状态下，线程的下一个状态会出现以下情况：</p><ul><li>当CPU给予的运行时间结束时，会从运行状态回到就绪（可运行）状态，等待下一次获得CPU资源。</li><li>当线程进入休眠 &#x2F; 阻塞(如等待IO请求) &#x2F; 手动调用<code>wait()</code>方法时，会使得线程处于等待状态，当等待状态结束后会回到就绪状态。</li><li>当线程出现异常或错误 &#x2F; 被<code>stop()</code> 方法强行停止 &#x2F; 所有代码执行结束时，会使得线程的运行终止。</li></ul><p>而这个部分我们着重了解一下线程的休眠和中断，首先我们来了解一下如何使得线程进如休眠状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);  <span class="comment">//休眠10秒</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);   <span class="comment">//休眠3秒，一定比线程t先醒来</span></span><br><span class="line">        t.interrupt();   <span class="comment">//调用t的interrupt方法</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/07/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20230807200215034.png" class="" title="image-20230807200215034"><p>我们发现，每一个Thread对象中，都有一个<code>interrupt()</code>方法，调用此方法后，会给指定线程添加一个中断标记以告知线程需要立即停止运行或是进行其他操作，由线程来响应此中断并进行相应的处理，我们前面提到的<code>stop()</code>方法是强制终止线程，这样的做法虽然简单粗暴，但是很有可能导致资源不能完全释放，而类似这样的发送通知来告知线程需要中断，让线程自行处理后续，会更加合理一些，也是更加推荐的做法。我们来看看interrupt的用法：</p><p>通过<code>isInterrupted()</code>可以判断线程是否存在中断标志，如果存在，说明外部希望当前线程立即停止，也有可能是给当前线程发送一个其他的信号，如果我们并不是希望收到中断信号就是结束程序，而是通知程序做其他事情，我们可以在收到中断信号后，复位中断标记，然后继续做我们的事情：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程开始运行！&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;   <span class="comment">//无限循环</span></span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().isInterrupted())&#123;   <span class="comment">//判断是否存在中断标志</span></span><br><span class="line">                <span class="keyword">break</span>;   <span class="comment">//响应中断</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程被中断了！&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);   <span class="comment">//休眠3秒，一定比线程t先醒来</span></span><br><span class="line">        t.interrupt();   <span class="comment">//调用t的interrupt方法</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>实际上，Java程序中的每个线程并不是平均分配CPU时间的，为了使得线程资源分配更加合理，Java采用的是抢占式调度方式，优先级越高的线程，优先使用CPU资源！我们希望CPU花费更多的时间去处理更重要的任务，而不太重要的任务，则可以先让出一部分资源。线程的优先级一般分为以下三种：</p><ul><li>MIN_PRIORITY 最低优先级</li><li>MAX_PRIORITY 最高优先级</li><li>NOM_PRIORITY 常规优先级</li></ul><h3 id="线程的礼让和加入"><a href="#线程的礼让和加入" class="headerlink" title="线程的礼让和加入"></a>线程的礼让和加入</h3><p>我们还可以在当前线程的工作不重要时，将CPU资源让位给其他线程，通过使用<code>yield()</code>方法来将当前资源让位给其他同优先级线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.wsy.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JUC_04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程1开始运行！&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;让位！&quot;</span>);</span><br><span class="line">                    Thread.<span class="keyword">yield</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;1打印：&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程1结束！&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程2开始运行！&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;2打印：&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们希望一个线程等待另一个线程执行完成后再继续进行，我们可以使用<code>join()</code>方法来实现线程的加入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.wsy.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JUC_05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程1开始运行！&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;1打印：&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程1结束！&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程2开始运行！&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;2打印：&quot;</span>+i);</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">10</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程1加入到此线程！&quot;</span>);</span><br><span class="line">                        t1.join();    <span class="comment">//在i==10时，让线程1加入，先完成线程1的内容，在继续当前内容</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="wait和notify方法"><a href="#wait和notify方法" class="headerlink" title="wait和notify方法"></a>wait和notify方法</h3><p>其实我们之前可能就发现了，Object类还有三个方法我们从来没有使用过，分别是<code>wait()</code>、<code>notify()</code>以及<code>notifyAll()</code>，他们其实是需要配合synchronized来使用的（实际上锁就是依附于对象存在的，每个对象都应该有针对于锁的一些操作，所以说就这样设计了）当然，只有在同步代码块中才能使用这些方法，正常情况下会报错，我们来看看他们的作用是什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.wsy.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JUC_07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;开始等待&quot;</span>);</span><br><span class="line">                    o1.wait();     <span class="comment">//进入等待状态并释放锁</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;等待结束！&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;开始唤醒！&quot;</span>);</span><br><span class="line">                o1.notify();     <span class="comment">//唤醒处于等待状态的线程</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                    System.out.println(i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//唤醒后依然需要等待这里的锁释放之前等待的线程才能继续</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在InheritableThreadLocal存放的内容，会自动向子线程传递。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.wsy.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JUC_09</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ThreadLocal&lt;String&gt; local = <span class="keyword">new</span> <span class="title class_">InheritableThreadLocal</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            local.set(<span class="string">&quot;yyds&quot;</span>);</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(local.get());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程基本功 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
